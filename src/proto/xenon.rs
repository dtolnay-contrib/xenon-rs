// This file is generated by rust-protobuf 2.22.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `xenon.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_22_0;

#[derive(PartialEq,Clone,Default)]
pub struct Empty {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Empty {
    fn default() -> &'a Empty {
        <Empty as ::protobuf::Message>::default_instance()
    }
}

impl Empty {
    pub fn new() -> Empty {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Empty {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Empty {
        Empty::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Empty>(
                "Empty",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Empty {
        static instance: ::protobuf::rt::LazyV2<Empty> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Empty::new)
    }
}

impl ::protobuf::Clear for Empty {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Empty {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Empty {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Properties {
    // message fields
    pub properties: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Properties {
    fn default() -> &'a Properties {
        <Properties as ::protobuf::Message>::default_instance()
    }
}

impl Properties {
    pub fn new() -> Properties {
        ::std::default::Default::default()
    }

    // repeated .xenon.Properties.PropertiesEntry properties = 1;


    pub fn get_properties(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.properties
    }
    pub fn clear_properties(&mut self) {
        self.properties.clear();
    }

    // Param is passed by value, moved
    pub fn set_properties(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.properties = v;
    }

    // Mutable pointer to the field.
    pub fn mut_properties(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.properties
    }

    // Take field
    pub fn take_properties(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.properties, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for Properties {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.properties)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(1, &self.properties);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(1, &self.properties, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Properties {
        Properties::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "properties",
                |m: &Properties| { &m.properties },
                |m: &mut Properties| { &mut m.properties },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Properties>(
                "Properties",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Properties {
        static instance: ::protobuf::rt::LazyV2<Properties> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Properties::new)
    }
}

impl ::protobuf::Clear for Properties {
    fn clear(&mut self) {
        self.properties.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Properties {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Properties {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PropertyDescription {
    // message fields
    pub name: ::std::string::String,
    pub description: ::std::string::String,
    pub default_value: ::std::string::String,
    pub field_type: PropertyDescription_Type,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PropertyDescription {
    fn default() -> &'a PropertyDescription {
        <PropertyDescription as ::protobuf::Message>::default_instance()
    }
}

impl PropertyDescription {
    pub fn new() -> PropertyDescription {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string description = 2;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // string default_value = 3;


    pub fn get_default_value(&self) -> &str {
        &self.default_value
    }
    pub fn clear_default_value(&mut self) {
        self.default_value.clear();
    }

    // Param is passed by value, moved
    pub fn set_default_value(&mut self, v: ::std::string::String) {
        self.default_value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_default_value(&mut self) -> &mut ::std::string::String {
        &mut self.default_value
    }

    // Take field
    pub fn take_default_value(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.default_value, ::std::string::String::new())
    }

    // .xenon.PropertyDescription.Type type = 4;


    pub fn get_field_type(&self) -> PropertyDescription_Type {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = PropertyDescription_Type::STRING;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: PropertyDescription_Type) {
        self.field_type = v;
    }
}

impl ::protobuf::Message for PropertyDescription {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.default_value)?;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 4, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.description);
        }
        if !self.default_value.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.default_value);
        }
        if self.field_type != PropertyDescription_Type::STRING {
            my_size += ::protobuf::rt::enum_size(4, self.field_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.description.is_empty() {
            os.write_string(2, &self.description)?;
        }
        if !self.default_value.is_empty() {
            os.write_string(3, &self.default_value)?;
        }
        if self.field_type != PropertyDescription_Type::STRING {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PropertyDescription {
        PropertyDescription::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &PropertyDescription| { &m.name },
                |m: &mut PropertyDescription| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "description",
                |m: &PropertyDescription| { &m.description },
                |m: &mut PropertyDescription| { &mut m.description },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "default_value",
                |m: &PropertyDescription| { &m.default_value },
                |m: &mut PropertyDescription| { &mut m.default_value },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PropertyDescription_Type>>(
                "type",
                |m: &PropertyDescription| { &m.field_type },
                |m: &mut PropertyDescription| { &mut m.field_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PropertyDescription>(
                "PropertyDescription",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PropertyDescription {
        static instance: ::protobuf::rt::LazyV2<PropertyDescription> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PropertyDescription::new)
    }
}

impl ::protobuf::Clear for PropertyDescription {
    fn clear(&mut self) {
        self.name.clear();
        self.description.clear();
        self.default_value.clear();
        self.field_type = PropertyDescription_Type::STRING;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PropertyDescription {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PropertyDescription {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PropertyDescription_Type {
    STRING = 0,
    BOOLEAN = 1,
    INTEGER = 2,
    DOUBLE = 3,
    LONG = 4,
    SIZE = 5,
    NATURAL = 6,
}

impl ::protobuf::ProtobufEnum for PropertyDescription_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PropertyDescription_Type> {
        match value {
            0 => ::std::option::Option::Some(PropertyDescription_Type::STRING),
            1 => ::std::option::Option::Some(PropertyDescription_Type::BOOLEAN),
            2 => ::std::option::Option::Some(PropertyDescription_Type::INTEGER),
            3 => ::std::option::Option::Some(PropertyDescription_Type::DOUBLE),
            4 => ::std::option::Option::Some(PropertyDescription_Type::LONG),
            5 => ::std::option::Option::Some(PropertyDescription_Type::SIZE),
            6 => ::std::option::Option::Some(PropertyDescription_Type::NATURAL),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PropertyDescription_Type] = &[
            PropertyDescription_Type::STRING,
            PropertyDescription_Type::BOOLEAN,
            PropertyDescription_Type::INTEGER,
            PropertyDescription_Type::DOUBLE,
            PropertyDescription_Type::LONG,
            PropertyDescription_Type::SIZE,
            PropertyDescription_Type::NATURAL,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<PropertyDescription_Type>("PropertyDescription.Type", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for PropertyDescription_Type {
}

impl ::std::default::Default for PropertyDescription_Type {
    fn default() -> Self {
        PropertyDescription_Type::STRING
    }
}

impl ::protobuf::reflect::ProtobufValue for PropertyDescription_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PropertyDescriptions {
    // message fields
    pub properties: ::protobuf::RepeatedField<PropertyDescription>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PropertyDescriptions {
    fn default() -> &'a PropertyDescriptions {
        <PropertyDescriptions as ::protobuf::Message>::default_instance()
    }
}

impl PropertyDescriptions {
    pub fn new() -> PropertyDescriptions {
        ::std::default::Default::default()
    }

    // repeated .xenon.PropertyDescription properties = 1;


    pub fn get_properties(&self) -> &[PropertyDescription] {
        &self.properties
    }
    pub fn clear_properties(&mut self) {
        self.properties.clear();
    }

    // Param is passed by value, moved
    pub fn set_properties(&mut self, v: ::protobuf::RepeatedField<PropertyDescription>) {
        self.properties = v;
    }

    // Mutable pointer to the field.
    pub fn mut_properties(&mut self) -> &mut ::protobuf::RepeatedField<PropertyDescription> {
        &mut self.properties
    }

    // Take field
    pub fn take_properties(&mut self) -> ::protobuf::RepeatedField<PropertyDescription> {
        ::std::mem::replace(&mut self.properties, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PropertyDescriptions {
    fn is_initialized(&self) -> bool {
        for v in &self.properties {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.properties)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.properties {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.properties {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PropertyDescriptions {
        PropertyDescriptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PropertyDescription>>(
                "properties",
                |m: &PropertyDescriptions| { &m.properties },
                |m: &mut PropertyDescriptions| { &mut m.properties },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PropertyDescriptions>(
                "PropertyDescriptions",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PropertyDescriptions {
        static instance: ::protobuf::rt::LazyV2<PropertyDescriptions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PropertyDescriptions::new)
    }
}

impl ::protobuf::Clear for PropertyDescriptions {
    fn clear(&mut self) {
        self.properties.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PropertyDescriptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PropertyDescriptions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SchedulerAdaptorDescription {
    // message fields
    pub name: ::std::string::String,
    pub description: ::std::string::String,
    pub supported_locations: ::protobuf::RepeatedField<::std::string::String>,
    pub supported_properties: ::protobuf::RepeatedField<PropertyDescription>,
    pub is_embedded: bool,
    pub supports_interactive: bool,
    pub supports_batch: bool,
    pub uses_file_system: bool,
    pub supported_credentials: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SchedulerAdaptorDescription {
    fn default() -> &'a SchedulerAdaptorDescription {
        <SchedulerAdaptorDescription as ::protobuf::Message>::default_instance()
    }
}

impl SchedulerAdaptorDescription {
    pub fn new() -> SchedulerAdaptorDescription {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string description = 2;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // repeated string supported_locations = 3;


    pub fn get_supported_locations(&self) -> &[::std::string::String] {
        &self.supported_locations
    }
    pub fn clear_supported_locations(&mut self) {
        self.supported_locations.clear();
    }

    // Param is passed by value, moved
    pub fn set_supported_locations(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.supported_locations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_supported_locations(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.supported_locations
    }

    // Take field
    pub fn take_supported_locations(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.supported_locations, ::protobuf::RepeatedField::new())
    }

    // repeated .xenon.PropertyDescription supported_properties = 4;


    pub fn get_supported_properties(&self) -> &[PropertyDescription] {
        &self.supported_properties
    }
    pub fn clear_supported_properties(&mut self) {
        self.supported_properties.clear();
    }

    // Param is passed by value, moved
    pub fn set_supported_properties(&mut self, v: ::protobuf::RepeatedField<PropertyDescription>) {
        self.supported_properties = v;
    }

    // Mutable pointer to the field.
    pub fn mut_supported_properties(&mut self) -> &mut ::protobuf::RepeatedField<PropertyDescription> {
        &mut self.supported_properties
    }

    // Take field
    pub fn take_supported_properties(&mut self) -> ::protobuf::RepeatedField<PropertyDescription> {
        ::std::mem::replace(&mut self.supported_properties, ::protobuf::RepeatedField::new())
    }

    // bool is_embedded = 5;


    pub fn get_is_embedded(&self) -> bool {
        self.is_embedded
    }
    pub fn clear_is_embedded(&mut self) {
        self.is_embedded = false;
    }

    // Param is passed by value, moved
    pub fn set_is_embedded(&mut self, v: bool) {
        self.is_embedded = v;
    }

    // bool supports_interactive = 6;


    pub fn get_supports_interactive(&self) -> bool {
        self.supports_interactive
    }
    pub fn clear_supports_interactive(&mut self) {
        self.supports_interactive = false;
    }

    // Param is passed by value, moved
    pub fn set_supports_interactive(&mut self, v: bool) {
        self.supports_interactive = v;
    }

    // bool supports_batch = 7;


    pub fn get_supports_batch(&self) -> bool {
        self.supports_batch
    }
    pub fn clear_supports_batch(&mut self) {
        self.supports_batch = false;
    }

    // Param is passed by value, moved
    pub fn set_supports_batch(&mut self, v: bool) {
        self.supports_batch = v;
    }

    // bool uses_file_system = 8;


    pub fn get_uses_file_system(&self) -> bool {
        self.uses_file_system
    }
    pub fn clear_uses_file_system(&mut self) {
        self.uses_file_system = false;
    }

    // Param is passed by value, moved
    pub fn set_uses_file_system(&mut self, v: bool) {
        self.uses_file_system = v;
    }

    // repeated string supported_credentials = 9;


    pub fn get_supported_credentials(&self) -> &[::std::string::String] {
        &self.supported_credentials
    }
    pub fn clear_supported_credentials(&mut self) {
        self.supported_credentials.clear();
    }

    // Param is passed by value, moved
    pub fn set_supported_credentials(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.supported_credentials = v;
    }

    // Mutable pointer to the field.
    pub fn mut_supported_credentials(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.supported_credentials
    }

    // Take field
    pub fn take_supported_credentials(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.supported_credentials, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for SchedulerAdaptorDescription {
    fn is_initialized(&self) -> bool {
        for v in &self.supported_properties {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.supported_locations)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.supported_properties)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_embedded = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.supports_interactive = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.supports_batch = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.uses_file_system = tmp;
                },
                9 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.supported_credentials)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.description);
        }
        for value in &self.supported_locations {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.supported_properties {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.is_embedded != false {
            my_size += 2;
        }
        if self.supports_interactive != false {
            my_size += 2;
        }
        if self.supports_batch != false {
            my_size += 2;
        }
        if self.uses_file_system != false {
            my_size += 2;
        }
        for value in &self.supported_credentials {
            my_size += ::protobuf::rt::string_size(9, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.description.is_empty() {
            os.write_string(2, &self.description)?;
        }
        for v in &self.supported_locations {
            os.write_string(3, &v)?;
        };
        for v in &self.supported_properties {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.is_embedded != false {
            os.write_bool(5, self.is_embedded)?;
        }
        if self.supports_interactive != false {
            os.write_bool(6, self.supports_interactive)?;
        }
        if self.supports_batch != false {
            os.write_bool(7, self.supports_batch)?;
        }
        if self.uses_file_system != false {
            os.write_bool(8, self.uses_file_system)?;
        }
        for v in &self.supported_credentials {
            os.write_string(9, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SchedulerAdaptorDescription {
        SchedulerAdaptorDescription::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &SchedulerAdaptorDescription| { &m.name },
                |m: &mut SchedulerAdaptorDescription| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "description",
                |m: &SchedulerAdaptorDescription| { &m.description },
                |m: &mut SchedulerAdaptorDescription| { &mut m.description },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "supported_locations",
                |m: &SchedulerAdaptorDescription| { &m.supported_locations },
                |m: &mut SchedulerAdaptorDescription| { &mut m.supported_locations },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PropertyDescription>>(
                "supported_properties",
                |m: &SchedulerAdaptorDescription| { &m.supported_properties },
                |m: &mut SchedulerAdaptorDescription| { &mut m.supported_properties },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_embedded",
                |m: &SchedulerAdaptorDescription| { &m.is_embedded },
                |m: &mut SchedulerAdaptorDescription| { &mut m.is_embedded },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "supports_interactive",
                |m: &SchedulerAdaptorDescription| { &m.supports_interactive },
                |m: &mut SchedulerAdaptorDescription| { &mut m.supports_interactive },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "supports_batch",
                |m: &SchedulerAdaptorDescription| { &m.supports_batch },
                |m: &mut SchedulerAdaptorDescription| { &mut m.supports_batch },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "uses_file_system",
                |m: &SchedulerAdaptorDescription| { &m.uses_file_system },
                |m: &mut SchedulerAdaptorDescription| { &mut m.uses_file_system },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "supported_credentials",
                |m: &SchedulerAdaptorDescription| { &m.supported_credentials },
                |m: &mut SchedulerAdaptorDescription| { &mut m.supported_credentials },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SchedulerAdaptorDescription>(
                "SchedulerAdaptorDescription",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SchedulerAdaptorDescription {
        static instance: ::protobuf::rt::LazyV2<SchedulerAdaptorDescription> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SchedulerAdaptorDescription::new)
    }
}

impl ::protobuf::Clear for SchedulerAdaptorDescription {
    fn clear(&mut self) {
        self.name.clear();
        self.description.clear();
        self.supported_locations.clear();
        self.supported_properties.clear();
        self.is_embedded = false;
        self.supports_interactive = false;
        self.supports_batch = false;
        self.uses_file_system = false;
        self.supported_credentials.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SchedulerAdaptorDescription {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SchedulerAdaptorDescription {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SchedulerAdaptorDescriptions {
    // message fields
    pub descriptions: ::protobuf::RepeatedField<SchedulerAdaptorDescription>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SchedulerAdaptorDescriptions {
    fn default() -> &'a SchedulerAdaptorDescriptions {
        <SchedulerAdaptorDescriptions as ::protobuf::Message>::default_instance()
    }
}

impl SchedulerAdaptorDescriptions {
    pub fn new() -> SchedulerAdaptorDescriptions {
        ::std::default::Default::default()
    }

    // repeated .xenon.SchedulerAdaptorDescription descriptions = 1;


    pub fn get_descriptions(&self) -> &[SchedulerAdaptorDescription] {
        &self.descriptions
    }
    pub fn clear_descriptions(&mut self) {
        self.descriptions.clear();
    }

    // Param is passed by value, moved
    pub fn set_descriptions(&mut self, v: ::protobuf::RepeatedField<SchedulerAdaptorDescription>) {
        self.descriptions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_descriptions(&mut self) -> &mut ::protobuf::RepeatedField<SchedulerAdaptorDescription> {
        &mut self.descriptions
    }

    // Take field
    pub fn take_descriptions(&mut self) -> ::protobuf::RepeatedField<SchedulerAdaptorDescription> {
        ::std::mem::replace(&mut self.descriptions, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for SchedulerAdaptorDescriptions {
    fn is_initialized(&self) -> bool {
        for v in &self.descriptions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.descriptions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.descriptions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.descriptions {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SchedulerAdaptorDescriptions {
        SchedulerAdaptorDescriptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SchedulerAdaptorDescription>>(
                "descriptions",
                |m: &SchedulerAdaptorDescriptions| { &m.descriptions },
                |m: &mut SchedulerAdaptorDescriptions| { &mut m.descriptions },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SchedulerAdaptorDescriptions>(
                "SchedulerAdaptorDescriptions",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SchedulerAdaptorDescriptions {
        static instance: ::protobuf::rt::LazyV2<SchedulerAdaptorDescriptions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SchedulerAdaptorDescriptions::new)
    }
}

impl ::protobuf::Clear for SchedulerAdaptorDescriptions {
    fn clear(&mut self) {
        self.descriptions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SchedulerAdaptorDescriptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SchedulerAdaptorDescriptions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FileSystemAdaptorDescription {
    // message fields
    pub name: ::std::string::String,
    pub description: ::std::string::String,
    pub supported_locations: ::protobuf::RepeatedField<::std::string::String>,
    pub supported_properties: ::protobuf::RepeatedField<PropertyDescription>,
    pub supports_third_party_copy: bool,
    pub can_create_symboliclinks: bool,
    pub can_read_symboliclinks: bool,
    pub is_connectionless: bool,
    pub supported_credentials: ::protobuf::RepeatedField<::std::string::String>,
    pub supports_reading_posix_permissions: bool,
    pub supports_setting_posix_permissions: bool,
    pub supports_rename: bool,
    pub can_append: bool,
    pub needs_size_beforehand: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FileSystemAdaptorDescription {
    fn default() -> &'a FileSystemAdaptorDescription {
        <FileSystemAdaptorDescription as ::protobuf::Message>::default_instance()
    }
}

impl FileSystemAdaptorDescription {
    pub fn new() -> FileSystemAdaptorDescription {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string description = 2;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // repeated string supported_locations = 3;


    pub fn get_supported_locations(&self) -> &[::std::string::String] {
        &self.supported_locations
    }
    pub fn clear_supported_locations(&mut self) {
        self.supported_locations.clear();
    }

    // Param is passed by value, moved
    pub fn set_supported_locations(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.supported_locations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_supported_locations(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.supported_locations
    }

    // Take field
    pub fn take_supported_locations(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.supported_locations, ::protobuf::RepeatedField::new())
    }

    // repeated .xenon.PropertyDescription supported_properties = 4;


    pub fn get_supported_properties(&self) -> &[PropertyDescription] {
        &self.supported_properties
    }
    pub fn clear_supported_properties(&mut self) {
        self.supported_properties.clear();
    }

    // Param is passed by value, moved
    pub fn set_supported_properties(&mut self, v: ::protobuf::RepeatedField<PropertyDescription>) {
        self.supported_properties = v;
    }

    // Mutable pointer to the field.
    pub fn mut_supported_properties(&mut self) -> &mut ::protobuf::RepeatedField<PropertyDescription> {
        &mut self.supported_properties
    }

    // Take field
    pub fn take_supported_properties(&mut self) -> ::protobuf::RepeatedField<PropertyDescription> {
        ::std::mem::replace(&mut self.supported_properties, ::protobuf::RepeatedField::new())
    }

    // bool supports_third_party_copy = 5;


    pub fn get_supports_third_party_copy(&self) -> bool {
        self.supports_third_party_copy
    }
    pub fn clear_supports_third_party_copy(&mut self) {
        self.supports_third_party_copy = false;
    }

    // Param is passed by value, moved
    pub fn set_supports_third_party_copy(&mut self, v: bool) {
        self.supports_third_party_copy = v;
    }

    // bool can_create_symboliclinks = 6;


    pub fn get_can_create_symboliclinks(&self) -> bool {
        self.can_create_symboliclinks
    }
    pub fn clear_can_create_symboliclinks(&mut self) {
        self.can_create_symboliclinks = false;
    }

    // Param is passed by value, moved
    pub fn set_can_create_symboliclinks(&mut self, v: bool) {
        self.can_create_symboliclinks = v;
    }

    // bool can_read_symboliclinks = 7;


    pub fn get_can_read_symboliclinks(&self) -> bool {
        self.can_read_symboliclinks
    }
    pub fn clear_can_read_symboliclinks(&mut self) {
        self.can_read_symboliclinks = false;
    }

    // Param is passed by value, moved
    pub fn set_can_read_symboliclinks(&mut self, v: bool) {
        self.can_read_symboliclinks = v;
    }

    // bool is_connectionless = 8;


    pub fn get_is_connectionless(&self) -> bool {
        self.is_connectionless
    }
    pub fn clear_is_connectionless(&mut self) {
        self.is_connectionless = false;
    }

    // Param is passed by value, moved
    pub fn set_is_connectionless(&mut self, v: bool) {
        self.is_connectionless = v;
    }

    // repeated string supported_credentials = 9;


    pub fn get_supported_credentials(&self) -> &[::std::string::String] {
        &self.supported_credentials
    }
    pub fn clear_supported_credentials(&mut self) {
        self.supported_credentials.clear();
    }

    // Param is passed by value, moved
    pub fn set_supported_credentials(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.supported_credentials = v;
    }

    // Mutable pointer to the field.
    pub fn mut_supported_credentials(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.supported_credentials
    }

    // Take field
    pub fn take_supported_credentials(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.supported_credentials, ::protobuf::RepeatedField::new())
    }

    // bool supports_reading_posix_permissions = 10;


    pub fn get_supports_reading_posix_permissions(&self) -> bool {
        self.supports_reading_posix_permissions
    }
    pub fn clear_supports_reading_posix_permissions(&mut self) {
        self.supports_reading_posix_permissions = false;
    }

    // Param is passed by value, moved
    pub fn set_supports_reading_posix_permissions(&mut self, v: bool) {
        self.supports_reading_posix_permissions = v;
    }

    // bool supports_setting_posix_permissions = 11;


    pub fn get_supports_setting_posix_permissions(&self) -> bool {
        self.supports_setting_posix_permissions
    }
    pub fn clear_supports_setting_posix_permissions(&mut self) {
        self.supports_setting_posix_permissions = false;
    }

    // Param is passed by value, moved
    pub fn set_supports_setting_posix_permissions(&mut self, v: bool) {
        self.supports_setting_posix_permissions = v;
    }

    // bool supports_rename = 12;


    pub fn get_supports_rename(&self) -> bool {
        self.supports_rename
    }
    pub fn clear_supports_rename(&mut self) {
        self.supports_rename = false;
    }

    // Param is passed by value, moved
    pub fn set_supports_rename(&mut self, v: bool) {
        self.supports_rename = v;
    }

    // bool can_append = 13;


    pub fn get_can_append(&self) -> bool {
        self.can_append
    }
    pub fn clear_can_append(&mut self) {
        self.can_append = false;
    }

    // Param is passed by value, moved
    pub fn set_can_append(&mut self, v: bool) {
        self.can_append = v;
    }

    // bool needs_size_beforehand = 14;


    pub fn get_needs_size_beforehand(&self) -> bool {
        self.needs_size_beforehand
    }
    pub fn clear_needs_size_beforehand(&mut self) {
        self.needs_size_beforehand = false;
    }

    // Param is passed by value, moved
    pub fn set_needs_size_beforehand(&mut self, v: bool) {
        self.needs_size_beforehand = v;
    }
}

impl ::protobuf::Message for FileSystemAdaptorDescription {
    fn is_initialized(&self) -> bool {
        for v in &self.supported_properties {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.supported_locations)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.supported_properties)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.supports_third_party_copy = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.can_create_symboliclinks = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.can_read_symboliclinks = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_connectionless = tmp;
                },
                9 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.supported_credentials)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.supports_reading_posix_permissions = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.supports_setting_posix_permissions = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.supports_rename = tmp;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.can_append = tmp;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.needs_size_beforehand = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.description);
        }
        for value in &self.supported_locations {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.supported_properties {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.supports_third_party_copy != false {
            my_size += 2;
        }
        if self.can_create_symboliclinks != false {
            my_size += 2;
        }
        if self.can_read_symboliclinks != false {
            my_size += 2;
        }
        if self.is_connectionless != false {
            my_size += 2;
        }
        for value in &self.supported_credentials {
            my_size += ::protobuf::rt::string_size(9, &value);
        };
        if self.supports_reading_posix_permissions != false {
            my_size += 2;
        }
        if self.supports_setting_posix_permissions != false {
            my_size += 2;
        }
        if self.supports_rename != false {
            my_size += 2;
        }
        if self.can_append != false {
            my_size += 2;
        }
        if self.needs_size_beforehand != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.description.is_empty() {
            os.write_string(2, &self.description)?;
        }
        for v in &self.supported_locations {
            os.write_string(3, &v)?;
        };
        for v in &self.supported_properties {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.supports_third_party_copy != false {
            os.write_bool(5, self.supports_third_party_copy)?;
        }
        if self.can_create_symboliclinks != false {
            os.write_bool(6, self.can_create_symboliclinks)?;
        }
        if self.can_read_symboliclinks != false {
            os.write_bool(7, self.can_read_symboliclinks)?;
        }
        if self.is_connectionless != false {
            os.write_bool(8, self.is_connectionless)?;
        }
        for v in &self.supported_credentials {
            os.write_string(9, &v)?;
        };
        if self.supports_reading_posix_permissions != false {
            os.write_bool(10, self.supports_reading_posix_permissions)?;
        }
        if self.supports_setting_posix_permissions != false {
            os.write_bool(11, self.supports_setting_posix_permissions)?;
        }
        if self.supports_rename != false {
            os.write_bool(12, self.supports_rename)?;
        }
        if self.can_append != false {
            os.write_bool(13, self.can_append)?;
        }
        if self.needs_size_beforehand != false {
            os.write_bool(14, self.needs_size_beforehand)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FileSystemAdaptorDescription {
        FileSystemAdaptorDescription::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &FileSystemAdaptorDescription| { &m.name },
                |m: &mut FileSystemAdaptorDescription| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "description",
                |m: &FileSystemAdaptorDescription| { &m.description },
                |m: &mut FileSystemAdaptorDescription| { &mut m.description },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "supported_locations",
                |m: &FileSystemAdaptorDescription| { &m.supported_locations },
                |m: &mut FileSystemAdaptorDescription| { &mut m.supported_locations },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PropertyDescription>>(
                "supported_properties",
                |m: &FileSystemAdaptorDescription| { &m.supported_properties },
                |m: &mut FileSystemAdaptorDescription| { &mut m.supported_properties },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "supports_third_party_copy",
                |m: &FileSystemAdaptorDescription| { &m.supports_third_party_copy },
                |m: &mut FileSystemAdaptorDescription| { &mut m.supports_third_party_copy },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "can_create_symboliclinks",
                |m: &FileSystemAdaptorDescription| { &m.can_create_symboliclinks },
                |m: &mut FileSystemAdaptorDescription| { &mut m.can_create_symboliclinks },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "can_read_symboliclinks",
                |m: &FileSystemAdaptorDescription| { &m.can_read_symboliclinks },
                |m: &mut FileSystemAdaptorDescription| { &mut m.can_read_symboliclinks },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_connectionless",
                |m: &FileSystemAdaptorDescription| { &m.is_connectionless },
                |m: &mut FileSystemAdaptorDescription| { &mut m.is_connectionless },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "supported_credentials",
                |m: &FileSystemAdaptorDescription| { &m.supported_credentials },
                |m: &mut FileSystemAdaptorDescription| { &mut m.supported_credentials },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "supports_reading_posix_permissions",
                |m: &FileSystemAdaptorDescription| { &m.supports_reading_posix_permissions },
                |m: &mut FileSystemAdaptorDescription| { &mut m.supports_reading_posix_permissions },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "supports_setting_posix_permissions",
                |m: &FileSystemAdaptorDescription| { &m.supports_setting_posix_permissions },
                |m: &mut FileSystemAdaptorDescription| { &mut m.supports_setting_posix_permissions },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "supports_rename",
                |m: &FileSystemAdaptorDescription| { &m.supports_rename },
                |m: &mut FileSystemAdaptorDescription| { &mut m.supports_rename },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "can_append",
                |m: &FileSystemAdaptorDescription| { &m.can_append },
                |m: &mut FileSystemAdaptorDescription| { &mut m.can_append },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "needs_size_beforehand",
                |m: &FileSystemAdaptorDescription| { &m.needs_size_beforehand },
                |m: &mut FileSystemAdaptorDescription| { &mut m.needs_size_beforehand },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FileSystemAdaptorDescription>(
                "FileSystemAdaptorDescription",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FileSystemAdaptorDescription {
        static instance: ::protobuf::rt::LazyV2<FileSystemAdaptorDescription> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FileSystemAdaptorDescription::new)
    }
}

impl ::protobuf::Clear for FileSystemAdaptorDescription {
    fn clear(&mut self) {
        self.name.clear();
        self.description.clear();
        self.supported_locations.clear();
        self.supported_properties.clear();
        self.supports_third_party_copy = false;
        self.can_create_symboliclinks = false;
        self.can_read_symboliclinks = false;
        self.is_connectionless = false;
        self.supported_credentials.clear();
        self.supports_reading_posix_permissions = false;
        self.supports_setting_posix_permissions = false;
        self.supports_rename = false;
        self.can_append = false;
        self.needs_size_beforehand = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FileSystemAdaptorDescription {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileSystemAdaptorDescription {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FileSystemAdaptorDescriptions {
    // message fields
    pub descriptions: ::protobuf::RepeatedField<FileSystemAdaptorDescription>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FileSystemAdaptorDescriptions {
    fn default() -> &'a FileSystemAdaptorDescriptions {
        <FileSystemAdaptorDescriptions as ::protobuf::Message>::default_instance()
    }
}

impl FileSystemAdaptorDescriptions {
    pub fn new() -> FileSystemAdaptorDescriptions {
        ::std::default::Default::default()
    }

    // repeated .xenon.FileSystemAdaptorDescription descriptions = 1;


    pub fn get_descriptions(&self) -> &[FileSystemAdaptorDescription] {
        &self.descriptions
    }
    pub fn clear_descriptions(&mut self) {
        self.descriptions.clear();
    }

    // Param is passed by value, moved
    pub fn set_descriptions(&mut self, v: ::protobuf::RepeatedField<FileSystemAdaptorDescription>) {
        self.descriptions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_descriptions(&mut self) -> &mut ::protobuf::RepeatedField<FileSystemAdaptorDescription> {
        &mut self.descriptions
    }

    // Take field
    pub fn take_descriptions(&mut self) -> ::protobuf::RepeatedField<FileSystemAdaptorDescription> {
        ::std::mem::replace(&mut self.descriptions, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for FileSystemAdaptorDescriptions {
    fn is_initialized(&self) -> bool {
        for v in &self.descriptions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.descriptions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.descriptions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.descriptions {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FileSystemAdaptorDescriptions {
        FileSystemAdaptorDescriptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FileSystemAdaptorDescription>>(
                "descriptions",
                |m: &FileSystemAdaptorDescriptions| { &m.descriptions },
                |m: &mut FileSystemAdaptorDescriptions| { &mut m.descriptions },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FileSystemAdaptorDescriptions>(
                "FileSystemAdaptorDescriptions",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FileSystemAdaptorDescriptions {
        static instance: ::protobuf::rt::LazyV2<FileSystemAdaptorDescriptions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FileSystemAdaptorDescriptions::new)
    }
}

impl ::protobuf::Clear for FileSystemAdaptorDescriptions {
    fn clear(&mut self) {
        self.descriptions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FileSystemAdaptorDescriptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileSystemAdaptorDescriptions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AdaptorName {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AdaptorName {
    fn default() -> &'a AdaptorName {
        <AdaptorName as ::protobuf::Message>::default_instance()
    }
}

impl AdaptorName {
    pub fn new() -> AdaptorName {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AdaptorName {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AdaptorName {
        AdaptorName::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &AdaptorName| { &m.name },
                |m: &mut AdaptorName| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AdaptorName>(
                "AdaptorName",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AdaptorName {
        static instance: ::protobuf::rt::LazyV2<AdaptorName> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AdaptorName::new)
    }
}

impl ::protobuf::Clear for AdaptorName {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AdaptorName {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AdaptorName {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AdaptorNames {
    // message fields
    pub name: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AdaptorNames {
    fn default() -> &'a AdaptorNames {
        <AdaptorNames as ::protobuf::Message>::default_instance()
    }
}

impl AdaptorNames {
    pub fn new() -> AdaptorNames {
        ::std::default::Default::default()
    }

    // repeated string name = 1;


    pub fn get_name(&self) -> &[::std::string::String] {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.name = v;
    }

    // Mutable pointer to the field.
    pub fn mut_name(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.name, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for AdaptorNames {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.name {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.name {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AdaptorNames {
        AdaptorNames::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &AdaptorNames| { &m.name },
                |m: &mut AdaptorNames| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AdaptorNames>(
                "AdaptorNames",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AdaptorNames {
        static instance: ::protobuf::rt::LazyV2<AdaptorNames> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AdaptorNames::new)
    }
}

impl ::protobuf::Clear for AdaptorNames {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AdaptorNames {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AdaptorNames {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CertificateCredential {
    // message fields
    pub certfile: ::std::string::String,
    pub passphrase: ::std::string::String,
    pub username: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CertificateCredential {
    fn default() -> &'a CertificateCredential {
        <CertificateCredential as ::protobuf::Message>::default_instance()
    }
}

impl CertificateCredential {
    pub fn new() -> CertificateCredential {
        ::std::default::Default::default()
    }

    // string certfile = 1;


    pub fn get_certfile(&self) -> &str {
        &self.certfile
    }
    pub fn clear_certfile(&mut self) {
        self.certfile.clear();
    }

    // Param is passed by value, moved
    pub fn set_certfile(&mut self, v: ::std::string::String) {
        self.certfile = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_certfile(&mut self) -> &mut ::std::string::String {
        &mut self.certfile
    }

    // Take field
    pub fn take_certfile(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.certfile, ::std::string::String::new())
    }

    // string passphrase = 2;


    pub fn get_passphrase(&self) -> &str {
        &self.passphrase
    }
    pub fn clear_passphrase(&mut self) {
        self.passphrase.clear();
    }

    // Param is passed by value, moved
    pub fn set_passphrase(&mut self, v: ::std::string::String) {
        self.passphrase = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_passphrase(&mut self) -> &mut ::std::string::String {
        &mut self.passphrase
    }

    // Take field
    pub fn take_passphrase(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.passphrase, ::std::string::String::new())
    }

    // string username = 3;


    pub fn get_username(&self) -> &str {
        &self.username
    }
    pub fn clear_username(&mut self) {
        self.username.clear();
    }

    // Param is passed by value, moved
    pub fn set_username(&mut self, v: ::std::string::String) {
        self.username = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_username(&mut self) -> &mut ::std::string::String {
        &mut self.username
    }

    // Take field
    pub fn take_username(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.username, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CertificateCredential {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.certfile)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.passphrase)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.username)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.certfile.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.certfile);
        }
        if !self.passphrase.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.passphrase);
        }
        if !self.username.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.username);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.certfile.is_empty() {
            os.write_string(1, &self.certfile)?;
        }
        if !self.passphrase.is_empty() {
            os.write_string(2, &self.passphrase)?;
        }
        if !self.username.is_empty() {
            os.write_string(3, &self.username)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CertificateCredential {
        CertificateCredential::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "certfile",
                |m: &CertificateCredential| { &m.certfile },
                |m: &mut CertificateCredential| { &mut m.certfile },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "passphrase",
                |m: &CertificateCredential| { &m.passphrase },
                |m: &mut CertificateCredential| { &mut m.passphrase },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "username",
                |m: &CertificateCredential| { &m.username },
                |m: &mut CertificateCredential| { &mut m.username },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CertificateCredential>(
                "CertificateCredential",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CertificateCredential {
        static instance: ::protobuf::rt::LazyV2<CertificateCredential> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CertificateCredential::new)
    }
}

impl ::protobuf::Clear for CertificateCredential {
    fn clear(&mut self) {
        self.certfile.clear();
        self.passphrase.clear();
        self.username.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CertificateCredential {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CertificateCredential {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PasswordCredential {
    // message fields
    pub username: ::std::string::String,
    pub password: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PasswordCredential {
    fn default() -> &'a PasswordCredential {
        <PasswordCredential as ::protobuf::Message>::default_instance()
    }
}

impl PasswordCredential {
    pub fn new() -> PasswordCredential {
        ::std::default::Default::default()
    }

    // string username = 1;


    pub fn get_username(&self) -> &str {
        &self.username
    }
    pub fn clear_username(&mut self) {
        self.username.clear();
    }

    // Param is passed by value, moved
    pub fn set_username(&mut self, v: ::std::string::String) {
        self.username = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_username(&mut self) -> &mut ::std::string::String {
        &mut self.username
    }

    // Take field
    pub fn take_username(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.username, ::std::string::String::new())
    }

    // string password = 2;


    pub fn get_password(&self) -> &str {
        &self.password
    }
    pub fn clear_password(&mut self) {
        self.password.clear();
    }

    // Param is passed by value, moved
    pub fn set_password(&mut self, v: ::std::string::String) {
        self.password = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_password(&mut self) -> &mut ::std::string::String {
        &mut self.password
    }

    // Take field
    pub fn take_password(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.password, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PasswordCredential {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.username)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.password)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.username.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.username);
        }
        if !self.password.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.password);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.username.is_empty() {
            os.write_string(1, &self.username)?;
        }
        if !self.password.is_empty() {
            os.write_string(2, &self.password)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PasswordCredential {
        PasswordCredential::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "username",
                |m: &PasswordCredential| { &m.username },
                |m: &mut PasswordCredential| { &mut m.username },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "password",
                |m: &PasswordCredential| { &m.password },
                |m: &mut PasswordCredential| { &mut m.password },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PasswordCredential>(
                "PasswordCredential",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PasswordCredential {
        static instance: ::protobuf::rt::LazyV2<PasswordCredential> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PasswordCredential::new)
    }
}

impl ::protobuf::Clear for PasswordCredential {
    fn clear(&mut self) {
        self.username.clear();
        self.password.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PasswordCredential {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PasswordCredential {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DefaultCredential {
    // message fields
    pub username: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DefaultCredential {
    fn default() -> &'a DefaultCredential {
        <DefaultCredential as ::protobuf::Message>::default_instance()
    }
}

impl DefaultCredential {
    pub fn new() -> DefaultCredential {
        ::std::default::Default::default()
    }

    // string username = 1;


    pub fn get_username(&self) -> &str {
        &self.username
    }
    pub fn clear_username(&mut self) {
        self.username.clear();
    }

    // Param is passed by value, moved
    pub fn set_username(&mut self, v: ::std::string::String) {
        self.username = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_username(&mut self) -> &mut ::std::string::String {
        &mut self.username
    }

    // Take field
    pub fn take_username(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.username, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DefaultCredential {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.username)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.username.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.username);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.username.is_empty() {
            os.write_string(1, &self.username)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DefaultCredential {
        DefaultCredential::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "username",
                |m: &DefaultCredential| { &m.username },
                |m: &mut DefaultCredential| { &mut m.username },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DefaultCredential>(
                "DefaultCredential",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DefaultCredential {
        static instance: ::protobuf::rt::LazyV2<DefaultCredential> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DefaultCredential::new)
    }
}

impl ::protobuf::Clear for DefaultCredential {
    fn clear(&mut self) {
        self.username.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DefaultCredential {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DefaultCredential {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct KeytabCredential {
    // message fields
    pub username: ::std::string::String,
    pub keytabfile: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a KeytabCredential {
    fn default() -> &'a KeytabCredential {
        <KeytabCredential as ::protobuf::Message>::default_instance()
    }
}

impl KeytabCredential {
    pub fn new() -> KeytabCredential {
        ::std::default::Default::default()
    }

    // string username = 1;


    pub fn get_username(&self) -> &str {
        &self.username
    }
    pub fn clear_username(&mut self) {
        self.username.clear();
    }

    // Param is passed by value, moved
    pub fn set_username(&mut self, v: ::std::string::String) {
        self.username = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_username(&mut self) -> &mut ::std::string::String {
        &mut self.username
    }

    // Take field
    pub fn take_username(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.username, ::std::string::String::new())
    }

    // string keytabfile = 2;


    pub fn get_keytabfile(&self) -> &str {
        &self.keytabfile
    }
    pub fn clear_keytabfile(&mut self) {
        self.keytabfile.clear();
    }

    // Param is passed by value, moved
    pub fn set_keytabfile(&mut self, v: ::std::string::String) {
        self.keytabfile = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_keytabfile(&mut self) -> &mut ::std::string::String {
        &mut self.keytabfile
    }

    // Take field
    pub fn take_keytabfile(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.keytabfile, ::std::string::String::new())
    }
}

impl ::protobuf::Message for KeytabCredential {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.username)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.keytabfile)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.username.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.username);
        }
        if !self.keytabfile.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.keytabfile);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.username.is_empty() {
            os.write_string(1, &self.username)?;
        }
        if !self.keytabfile.is_empty() {
            os.write_string(2, &self.keytabfile)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KeytabCredential {
        KeytabCredential::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "username",
                |m: &KeytabCredential| { &m.username },
                |m: &mut KeytabCredential| { &mut m.username },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "keytabfile",
                |m: &KeytabCredential| { &m.keytabfile },
                |m: &mut KeytabCredential| { &mut m.keytabfile },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<KeytabCredential>(
                "KeytabCredential",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static KeytabCredential {
        static instance: ::protobuf::rt::LazyV2<KeytabCredential> = ::protobuf::rt::LazyV2::INIT;
        instance.get(KeytabCredential::new)
    }
}

impl ::protobuf::Clear for KeytabCredential {
    fn clear(&mut self) {
        self.username.clear();
        self.keytabfile.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for KeytabCredential {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeytabCredential {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UserCredential {
    // message oneof groups
    pub entry: ::std::option::Option<UserCredential_oneof_entry>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UserCredential {
    fn default() -> &'a UserCredential {
        <UserCredential as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum UserCredential_oneof_entry {
    certificate_credential(CertificateCredential),
    password_credential(PasswordCredential),
    default_credential(DefaultCredential),
    keytab_credential(KeytabCredential),
}

impl UserCredential {
    pub fn new() -> UserCredential {
        ::std::default::Default::default()
    }

    // .xenon.CertificateCredential certificate_credential = 1;


    pub fn get_certificate_credential(&self) -> &CertificateCredential {
        match self.entry {
            ::std::option::Option::Some(UserCredential_oneof_entry::certificate_credential(ref v)) => v,
            _ => <CertificateCredential as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_certificate_credential(&mut self) {
        self.entry = ::std::option::Option::None;
    }

    pub fn has_certificate_credential(&self) -> bool {
        match self.entry {
            ::std::option::Option::Some(UserCredential_oneof_entry::certificate_credential(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_certificate_credential(&mut self, v: CertificateCredential) {
        self.entry = ::std::option::Option::Some(UserCredential_oneof_entry::certificate_credential(v))
    }

    // Mutable pointer to the field.
    pub fn mut_certificate_credential(&mut self) -> &mut CertificateCredential {
        if let ::std::option::Option::Some(UserCredential_oneof_entry::certificate_credential(_)) = self.entry {
        } else {
            self.entry = ::std::option::Option::Some(UserCredential_oneof_entry::certificate_credential(CertificateCredential::new()));
        }
        match self.entry {
            ::std::option::Option::Some(UserCredential_oneof_entry::certificate_credential(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_certificate_credential(&mut self) -> CertificateCredential {
        if self.has_certificate_credential() {
            match self.entry.take() {
                ::std::option::Option::Some(UserCredential_oneof_entry::certificate_credential(v)) => v,
                _ => panic!(),
            }
        } else {
            CertificateCredential::new()
        }
    }

    // .xenon.PasswordCredential password_credential = 2;


    pub fn get_password_credential(&self) -> &PasswordCredential {
        match self.entry {
            ::std::option::Option::Some(UserCredential_oneof_entry::password_credential(ref v)) => v,
            _ => <PasswordCredential as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_password_credential(&mut self) {
        self.entry = ::std::option::Option::None;
    }

    pub fn has_password_credential(&self) -> bool {
        match self.entry {
            ::std::option::Option::Some(UserCredential_oneof_entry::password_credential(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_password_credential(&mut self, v: PasswordCredential) {
        self.entry = ::std::option::Option::Some(UserCredential_oneof_entry::password_credential(v))
    }

    // Mutable pointer to the field.
    pub fn mut_password_credential(&mut self) -> &mut PasswordCredential {
        if let ::std::option::Option::Some(UserCredential_oneof_entry::password_credential(_)) = self.entry {
        } else {
            self.entry = ::std::option::Option::Some(UserCredential_oneof_entry::password_credential(PasswordCredential::new()));
        }
        match self.entry {
            ::std::option::Option::Some(UserCredential_oneof_entry::password_credential(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_password_credential(&mut self) -> PasswordCredential {
        if self.has_password_credential() {
            match self.entry.take() {
                ::std::option::Option::Some(UserCredential_oneof_entry::password_credential(v)) => v,
                _ => panic!(),
            }
        } else {
            PasswordCredential::new()
        }
    }

    // .xenon.DefaultCredential default_credential = 3;


    pub fn get_default_credential(&self) -> &DefaultCredential {
        match self.entry {
            ::std::option::Option::Some(UserCredential_oneof_entry::default_credential(ref v)) => v,
            _ => <DefaultCredential as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_default_credential(&mut self) {
        self.entry = ::std::option::Option::None;
    }

    pub fn has_default_credential(&self) -> bool {
        match self.entry {
            ::std::option::Option::Some(UserCredential_oneof_entry::default_credential(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_default_credential(&mut self, v: DefaultCredential) {
        self.entry = ::std::option::Option::Some(UserCredential_oneof_entry::default_credential(v))
    }

    // Mutable pointer to the field.
    pub fn mut_default_credential(&mut self) -> &mut DefaultCredential {
        if let ::std::option::Option::Some(UserCredential_oneof_entry::default_credential(_)) = self.entry {
        } else {
            self.entry = ::std::option::Option::Some(UserCredential_oneof_entry::default_credential(DefaultCredential::new()));
        }
        match self.entry {
            ::std::option::Option::Some(UserCredential_oneof_entry::default_credential(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_default_credential(&mut self) -> DefaultCredential {
        if self.has_default_credential() {
            match self.entry.take() {
                ::std::option::Option::Some(UserCredential_oneof_entry::default_credential(v)) => v,
                _ => panic!(),
            }
        } else {
            DefaultCredential::new()
        }
    }

    // .xenon.KeytabCredential keytab_credential = 4;


    pub fn get_keytab_credential(&self) -> &KeytabCredential {
        match self.entry {
            ::std::option::Option::Some(UserCredential_oneof_entry::keytab_credential(ref v)) => v,
            _ => <KeytabCredential as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_keytab_credential(&mut self) {
        self.entry = ::std::option::Option::None;
    }

    pub fn has_keytab_credential(&self) -> bool {
        match self.entry {
            ::std::option::Option::Some(UserCredential_oneof_entry::keytab_credential(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_keytab_credential(&mut self, v: KeytabCredential) {
        self.entry = ::std::option::Option::Some(UserCredential_oneof_entry::keytab_credential(v))
    }

    // Mutable pointer to the field.
    pub fn mut_keytab_credential(&mut self) -> &mut KeytabCredential {
        if let ::std::option::Option::Some(UserCredential_oneof_entry::keytab_credential(_)) = self.entry {
        } else {
            self.entry = ::std::option::Option::Some(UserCredential_oneof_entry::keytab_credential(KeytabCredential::new()));
        }
        match self.entry {
            ::std::option::Option::Some(UserCredential_oneof_entry::keytab_credential(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_keytab_credential(&mut self) -> KeytabCredential {
        if self.has_keytab_credential() {
            match self.entry.take() {
                ::std::option::Option::Some(UserCredential_oneof_entry::keytab_credential(v)) => v,
                _ => panic!(),
            }
        } else {
            KeytabCredential::new()
        }
    }
}

impl ::protobuf::Message for UserCredential {
    fn is_initialized(&self) -> bool {
        if let Some(UserCredential_oneof_entry::certificate_credential(ref v)) = self.entry {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(UserCredential_oneof_entry::password_credential(ref v)) = self.entry {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(UserCredential_oneof_entry::default_credential(ref v)) = self.entry {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(UserCredential_oneof_entry::keytab_credential(ref v)) = self.entry {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.entry = ::std::option::Option::Some(UserCredential_oneof_entry::certificate_credential(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.entry = ::std::option::Option::Some(UserCredential_oneof_entry::password_credential(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.entry = ::std::option::Option::Some(UserCredential_oneof_entry::default_credential(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.entry = ::std::option::Option::Some(UserCredential_oneof_entry::keytab_credential(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.entry {
            match v {
                &UserCredential_oneof_entry::certificate_credential(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &UserCredential_oneof_entry::password_credential(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &UserCredential_oneof_entry::default_credential(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &UserCredential_oneof_entry::keytab_credential(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.entry {
            match v {
                &UserCredential_oneof_entry::certificate_credential(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &UserCredential_oneof_entry::password_credential(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &UserCredential_oneof_entry::default_credential(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &UserCredential_oneof_entry::keytab_credential(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UserCredential {
        UserCredential::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, CertificateCredential>(
                "certificate_credential",
                UserCredential::has_certificate_credential,
                UserCredential::get_certificate_credential,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, PasswordCredential>(
                "password_credential",
                UserCredential::has_password_credential,
                UserCredential::get_password_credential,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DefaultCredential>(
                "default_credential",
                UserCredential::has_default_credential,
                UserCredential::get_default_credential,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, KeytabCredential>(
                "keytab_credential",
                UserCredential::has_keytab_credential,
                UserCredential::get_keytab_credential,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UserCredential>(
                "UserCredential",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UserCredential {
        static instance: ::protobuf::rt::LazyV2<UserCredential> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UserCredential::new)
    }
}

impl ::protobuf::Clear for UserCredential {
    fn clear(&mut self) {
        self.entry = ::std::option::Option::None;
        self.entry = ::std::option::Option::None;
        self.entry = ::std::option::Option::None;
        self.entry = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UserCredential {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserCredential {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CredentialMap {
    // message fields
    pub entries: ::std::collections::HashMap<::std::string::String, UserCredential>,
    // message oneof groups
    pub fallback: ::std::option::Option<CredentialMap_oneof_fallback>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CredentialMap {
    fn default() -> &'a CredentialMap {
        <CredentialMap as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum CredentialMap_oneof_fallback {
    certificate_credential(CertificateCredential),
    password_credential(PasswordCredential),
    default_credential(DefaultCredential),
    keytab_credential(KeytabCredential),
}

impl CredentialMap {
    pub fn new() -> CredentialMap {
        ::std::default::Default::default()
    }

    // repeated .xenon.CredentialMap.EntriesEntry entries = 1;


    pub fn get_entries(&self) -> &::std::collections::HashMap<::std::string::String, UserCredential> {
        &self.entries
    }
    pub fn clear_entries(&mut self) {
        self.entries.clear();
    }

    // Param is passed by value, moved
    pub fn set_entries(&mut self, v: ::std::collections::HashMap<::std::string::String, UserCredential>) {
        self.entries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entries(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, UserCredential> {
        &mut self.entries
    }

    // Take field
    pub fn take_entries(&mut self) -> ::std::collections::HashMap<::std::string::String, UserCredential> {
        ::std::mem::replace(&mut self.entries, ::std::collections::HashMap::new())
    }

    // .xenon.CertificateCredential certificate_credential = 2;


    pub fn get_certificate_credential(&self) -> &CertificateCredential {
        match self.fallback {
            ::std::option::Option::Some(CredentialMap_oneof_fallback::certificate_credential(ref v)) => v,
            _ => <CertificateCredential as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_certificate_credential(&mut self) {
        self.fallback = ::std::option::Option::None;
    }

    pub fn has_certificate_credential(&self) -> bool {
        match self.fallback {
            ::std::option::Option::Some(CredentialMap_oneof_fallback::certificate_credential(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_certificate_credential(&mut self, v: CertificateCredential) {
        self.fallback = ::std::option::Option::Some(CredentialMap_oneof_fallback::certificate_credential(v))
    }

    // Mutable pointer to the field.
    pub fn mut_certificate_credential(&mut self) -> &mut CertificateCredential {
        if let ::std::option::Option::Some(CredentialMap_oneof_fallback::certificate_credential(_)) = self.fallback {
        } else {
            self.fallback = ::std::option::Option::Some(CredentialMap_oneof_fallback::certificate_credential(CertificateCredential::new()));
        }
        match self.fallback {
            ::std::option::Option::Some(CredentialMap_oneof_fallback::certificate_credential(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_certificate_credential(&mut self) -> CertificateCredential {
        if self.has_certificate_credential() {
            match self.fallback.take() {
                ::std::option::Option::Some(CredentialMap_oneof_fallback::certificate_credential(v)) => v,
                _ => panic!(),
            }
        } else {
            CertificateCredential::new()
        }
    }

    // .xenon.PasswordCredential password_credential = 3;


    pub fn get_password_credential(&self) -> &PasswordCredential {
        match self.fallback {
            ::std::option::Option::Some(CredentialMap_oneof_fallback::password_credential(ref v)) => v,
            _ => <PasswordCredential as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_password_credential(&mut self) {
        self.fallback = ::std::option::Option::None;
    }

    pub fn has_password_credential(&self) -> bool {
        match self.fallback {
            ::std::option::Option::Some(CredentialMap_oneof_fallback::password_credential(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_password_credential(&mut self, v: PasswordCredential) {
        self.fallback = ::std::option::Option::Some(CredentialMap_oneof_fallback::password_credential(v))
    }

    // Mutable pointer to the field.
    pub fn mut_password_credential(&mut self) -> &mut PasswordCredential {
        if let ::std::option::Option::Some(CredentialMap_oneof_fallback::password_credential(_)) = self.fallback {
        } else {
            self.fallback = ::std::option::Option::Some(CredentialMap_oneof_fallback::password_credential(PasswordCredential::new()));
        }
        match self.fallback {
            ::std::option::Option::Some(CredentialMap_oneof_fallback::password_credential(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_password_credential(&mut self) -> PasswordCredential {
        if self.has_password_credential() {
            match self.fallback.take() {
                ::std::option::Option::Some(CredentialMap_oneof_fallback::password_credential(v)) => v,
                _ => panic!(),
            }
        } else {
            PasswordCredential::new()
        }
    }

    // .xenon.DefaultCredential default_credential = 4;


    pub fn get_default_credential(&self) -> &DefaultCredential {
        match self.fallback {
            ::std::option::Option::Some(CredentialMap_oneof_fallback::default_credential(ref v)) => v,
            _ => <DefaultCredential as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_default_credential(&mut self) {
        self.fallback = ::std::option::Option::None;
    }

    pub fn has_default_credential(&self) -> bool {
        match self.fallback {
            ::std::option::Option::Some(CredentialMap_oneof_fallback::default_credential(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_default_credential(&mut self, v: DefaultCredential) {
        self.fallback = ::std::option::Option::Some(CredentialMap_oneof_fallback::default_credential(v))
    }

    // Mutable pointer to the field.
    pub fn mut_default_credential(&mut self) -> &mut DefaultCredential {
        if let ::std::option::Option::Some(CredentialMap_oneof_fallback::default_credential(_)) = self.fallback {
        } else {
            self.fallback = ::std::option::Option::Some(CredentialMap_oneof_fallback::default_credential(DefaultCredential::new()));
        }
        match self.fallback {
            ::std::option::Option::Some(CredentialMap_oneof_fallback::default_credential(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_default_credential(&mut self) -> DefaultCredential {
        if self.has_default_credential() {
            match self.fallback.take() {
                ::std::option::Option::Some(CredentialMap_oneof_fallback::default_credential(v)) => v,
                _ => panic!(),
            }
        } else {
            DefaultCredential::new()
        }
    }

    // .xenon.KeytabCredential keytab_credential = 5;


    pub fn get_keytab_credential(&self) -> &KeytabCredential {
        match self.fallback {
            ::std::option::Option::Some(CredentialMap_oneof_fallback::keytab_credential(ref v)) => v,
            _ => <KeytabCredential as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_keytab_credential(&mut self) {
        self.fallback = ::std::option::Option::None;
    }

    pub fn has_keytab_credential(&self) -> bool {
        match self.fallback {
            ::std::option::Option::Some(CredentialMap_oneof_fallback::keytab_credential(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_keytab_credential(&mut self, v: KeytabCredential) {
        self.fallback = ::std::option::Option::Some(CredentialMap_oneof_fallback::keytab_credential(v))
    }

    // Mutable pointer to the field.
    pub fn mut_keytab_credential(&mut self) -> &mut KeytabCredential {
        if let ::std::option::Option::Some(CredentialMap_oneof_fallback::keytab_credential(_)) = self.fallback {
        } else {
            self.fallback = ::std::option::Option::Some(CredentialMap_oneof_fallback::keytab_credential(KeytabCredential::new()));
        }
        match self.fallback {
            ::std::option::Option::Some(CredentialMap_oneof_fallback::keytab_credential(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_keytab_credential(&mut self) -> KeytabCredential {
        if self.has_keytab_credential() {
            match self.fallback.take() {
                ::std::option::Option::Some(CredentialMap_oneof_fallback::keytab_credential(v)) => v,
                _ => panic!(),
            }
        } else {
            KeytabCredential::new()
        }
    }
}

impl ::protobuf::Message for CredentialMap {
    fn is_initialized(&self) -> bool {
        if let Some(CredentialMap_oneof_fallback::certificate_credential(ref v)) = self.fallback {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(CredentialMap_oneof_fallback::password_credential(ref v)) = self.fallback {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(CredentialMap_oneof_fallback::default_credential(ref v)) = self.fallback {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(CredentialMap_oneof_fallback::keytab_credential(ref v)) = self.fallback {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<UserCredential>>(wire_type, is, &mut self.entries)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.fallback = ::std::option::Option::Some(CredentialMap_oneof_fallback::certificate_credential(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.fallback = ::std::option::Option::Some(CredentialMap_oneof_fallback::password_credential(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.fallback = ::std::option::Option::Some(CredentialMap_oneof_fallback::default_credential(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.fallback = ::std::option::Option::Some(CredentialMap_oneof_fallback::keytab_credential(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<UserCredential>>(1, &self.entries);
        if let ::std::option::Option::Some(ref v) = self.fallback {
            match v {
                &CredentialMap_oneof_fallback::certificate_credential(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &CredentialMap_oneof_fallback::password_credential(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &CredentialMap_oneof_fallback::default_credential(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &CredentialMap_oneof_fallback::keytab_credential(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<UserCredential>>(1, &self.entries, os)?;
        if let ::std::option::Option::Some(ref v) = self.fallback {
            match v {
                &CredentialMap_oneof_fallback::certificate_credential(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &CredentialMap_oneof_fallback::password_credential(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &CredentialMap_oneof_fallback::default_credential(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &CredentialMap_oneof_fallback::keytab_credential(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CredentialMap {
        CredentialMap::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<UserCredential>>(
                "entries",
                |m: &CredentialMap| { &m.entries },
                |m: &mut CredentialMap| { &mut m.entries },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, CertificateCredential>(
                "certificate_credential",
                CredentialMap::has_certificate_credential,
                CredentialMap::get_certificate_credential,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, PasswordCredential>(
                "password_credential",
                CredentialMap::has_password_credential,
                CredentialMap::get_password_credential,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DefaultCredential>(
                "default_credential",
                CredentialMap::has_default_credential,
                CredentialMap::get_default_credential,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, KeytabCredential>(
                "keytab_credential",
                CredentialMap::has_keytab_credential,
                CredentialMap::get_keytab_credential,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CredentialMap>(
                "CredentialMap",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CredentialMap {
        static instance: ::protobuf::rt::LazyV2<CredentialMap> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CredentialMap::new)
    }
}

impl ::protobuf::Clear for CredentialMap {
    fn clear(&mut self) {
        self.entries.clear();
        self.fallback = ::std::option::Option::None;
        self.fallback = ::std::option::Option::None;
        self.fallback = ::std::option::Option::None;
        self.fallback = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CredentialMap {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CredentialMap {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Location {
    // message fields
    pub location: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Location {
    fn default() -> &'a Location {
        <Location as ::protobuf::Message>::default_instance()
    }
}

impl Location {
    pub fn new() -> Location {
        ::std::default::Default::default()
    }

    // string location = 1;


    pub fn get_location(&self) -> &str {
        &self.location
    }
    pub fn clear_location(&mut self) {
        self.location.clear();
    }

    // Param is passed by value, moved
    pub fn set_location(&mut self, v: ::std::string::String) {
        self.location = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_location(&mut self) -> &mut ::std::string::String {
        &mut self.location
    }

    // Take field
    pub fn take_location(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.location, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Location {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.location)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.location.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.location);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.location.is_empty() {
            os.write_string(1, &self.location)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Location {
        Location::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "location",
                |m: &Location| { &m.location },
                |m: &mut Location| { &mut m.location },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Location>(
                "Location",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Location {
        static instance: ::protobuf::rt::LazyV2<Location> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Location::new)
    }
}

impl ::protobuf::Clear for Location {
    fn clear(&mut self) {
        self.location.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Location {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Location {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetCredentialResponse {
    // message oneof groups
    pub credential: ::std::option::Option<GetCredentialResponse_oneof_credential>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetCredentialResponse {
    fn default() -> &'a GetCredentialResponse {
        <GetCredentialResponse as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum GetCredentialResponse_oneof_credential {
    certificate_credential(CertificateCredential),
    password_credential(PasswordCredential),
    default_credential(DefaultCredential),
    credential_map(CredentialMap),
    keytab_credential(KeytabCredential),
}

impl GetCredentialResponse {
    pub fn new() -> GetCredentialResponse {
        ::std::default::Default::default()
    }

    // .xenon.CertificateCredential certificate_credential = 4;


    pub fn get_certificate_credential(&self) -> &CertificateCredential {
        match self.credential {
            ::std::option::Option::Some(GetCredentialResponse_oneof_credential::certificate_credential(ref v)) => v,
            _ => <CertificateCredential as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_certificate_credential(&mut self) {
        self.credential = ::std::option::Option::None;
    }

    pub fn has_certificate_credential(&self) -> bool {
        match self.credential {
            ::std::option::Option::Some(GetCredentialResponse_oneof_credential::certificate_credential(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_certificate_credential(&mut self, v: CertificateCredential) {
        self.credential = ::std::option::Option::Some(GetCredentialResponse_oneof_credential::certificate_credential(v))
    }

    // Mutable pointer to the field.
    pub fn mut_certificate_credential(&mut self) -> &mut CertificateCredential {
        if let ::std::option::Option::Some(GetCredentialResponse_oneof_credential::certificate_credential(_)) = self.credential {
        } else {
            self.credential = ::std::option::Option::Some(GetCredentialResponse_oneof_credential::certificate_credential(CertificateCredential::new()));
        }
        match self.credential {
            ::std::option::Option::Some(GetCredentialResponse_oneof_credential::certificate_credential(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_certificate_credential(&mut self) -> CertificateCredential {
        if self.has_certificate_credential() {
            match self.credential.take() {
                ::std::option::Option::Some(GetCredentialResponse_oneof_credential::certificate_credential(v)) => v,
                _ => panic!(),
            }
        } else {
            CertificateCredential::new()
        }
    }

    // .xenon.PasswordCredential password_credential = 5;


    pub fn get_password_credential(&self) -> &PasswordCredential {
        match self.credential {
            ::std::option::Option::Some(GetCredentialResponse_oneof_credential::password_credential(ref v)) => v,
            _ => <PasswordCredential as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_password_credential(&mut self) {
        self.credential = ::std::option::Option::None;
    }

    pub fn has_password_credential(&self) -> bool {
        match self.credential {
            ::std::option::Option::Some(GetCredentialResponse_oneof_credential::password_credential(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_password_credential(&mut self, v: PasswordCredential) {
        self.credential = ::std::option::Option::Some(GetCredentialResponse_oneof_credential::password_credential(v))
    }

    // Mutable pointer to the field.
    pub fn mut_password_credential(&mut self) -> &mut PasswordCredential {
        if let ::std::option::Option::Some(GetCredentialResponse_oneof_credential::password_credential(_)) = self.credential {
        } else {
            self.credential = ::std::option::Option::Some(GetCredentialResponse_oneof_credential::password_credential(PasswordCredential::new()));
        }
        match self.credential {
            ::std::option::Option::Some(GetCredentialResponse_oneof_credential::password_credential(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_password_credential(&mut self) -> PasswordCredential {
        if self.has_password_credential() {
            match self.credential.take() {
                ::std::option::Option::Some(GetCredentialResponse_oneof_credential::password_credential(v)) => v,
                _ => panic!(),
            }
        } else {
            PasswordCredential::new()
        }
    }

    // .xenon.DefaultCredential default_credential = 6;


    pub fn get_default_credential(&self) -> &DefaultCredential {
        match self.credential {
            ::std::option::Option::Some(GetCredentialResponse_oneof_credential::default_credential(ref v)) => v,
            _ => <DefaultCredential as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_default_credential(&mut self) {
        self.credential = ::std::option::Option::None;
    }

    pub fn has_default_credential(&self) -> bool {
        match self.credential {
            ::std::option::Option::Some(GetCredentialResponse_oneof_credential::default_credential(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_default_credential(&mut self, v: DefaultCredential) {
        self.credential = ::std::option::Option::Some(GetCredentialResponse_oneof_credential::default_credential(v))
    }

    // Mutable pointer to the field.
    pub fn mut_default_credential(&mut self) -> &mut DefaultCredential {
        if let ::std::option::Option::Some(GetCredentialResponse_oneof_credential::default_credential(_)) = self.credential {
        } else {
            self.credential = ::std::option::Option::Some(GetCredentialResponse_oneof_credential::default_credential(DefaultCredential::new()));
        }
        match self.credential {
            ::std::option::Option::Some(GetCredentialResponse_oneof_credential::default_credential(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_default_credential(&mut self) -> DefaultCredential {
        if self.has_default_credential() {
            match self.credential.take() {
                ::std::option::Option::Some(GetCredentialResponse_oneof_credential::default_credential(v)) => v,
                _ => panic!(),
            }
        } else {
            DefaultCredential::new()
        }
    }

    // .xenon.CredentialMap credential_map = 7;


    pub fn get_credential_map(&self) -> &CredentialMap {
        match self.credential {
            ::std::option::Option::Some(GetCredentialResponse_oneof_credential::credential_map(ref v)) => v,
            _ => <CredentialMap as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_credential_map(&mut self) {
        self.credential = ::std::option::Option::None;
    }

    pub fn has_credential_map(&self) -> bool {
        match self.credential {
            ::std::option::Option::Some(GetCredentialResponse_oneof_credential::credential_map(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_credential_map(&mut self, v: CredentialMap) {
        self.credential = ::std::option::Option::Some(GetCredentialResponse_oneof_credential::credential_map(v))
    }

    // Mutable pointer to the field.
    pub fn mut_credential_map(&mut self) -> &mut CredentialMap {
        if let ::std::option::Option::Some(GetCredentialResponse_oneof_credential::credential_map(_)) = self.credential {
        } else {
            self.credential = ::std::option::Option::Some(GetCredentialResponse_oneof_credential::credential_map(CredentialMap::new()));
        }
        match self.credential {
            ::std::option::Option::Some(GetCredentialResponse_oneof_credential::credential_map(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_credential_map(&mut self) -> CredentialMap {
        if self.has_credential_map() {
            match self.credential.take() {
                ::std::option::Option::Some(GetCredentialResponse_oneof_credential::credential_map(v)) => v,
                _ => panic!(),
            }
        } else {
            CredentialMap::new()
        }
    }

    // .xenon.KeytabCredential keytab_credential = 8;


    pub fn get_keytab_credential(&self) -> &KeytabCredential {
        match self.credential {
            ::std::option::Option::Some(GetCredentialResponse_oneof_credential::keytab_credential(ref v)) => v,
            _ => <KeytabCredential as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_keytab_credential(&mut self) {
        self.credential = ::std::option::Option::None;
    }

    pub fn has_keytab_credential(&self) -> bool {
        match self.credential {
            ::std::option::Option::Some(GetCredentialResponse_oneof_credential::keytab_credential(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_keytab_credential(&mut self, v: KeytabCredential) {
        self.credential = ::std::option::Option::Some(GetCredentialResponse_oneof_credential::keytab_credential(v))
    }

    // Mutable pointer to the field.
    pub fn mut_keytab_credential(&mut self) -> &mut KeytabCredential {
        if let ::std::option::Option::Some(GetCredentialResponse_oneof_credential::keytab_credential(_)) = self.credential {
        } else {
            self.credential = ::std::option::Option::Some(GetCredentialResponse_oneof_credential::keytab_credential(KeytabCredential::new()));
        }
        match self.credential {
            ::std::option::Option::Some(GetCredentialResponse_oneof_credential::keytab_credential(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_keytab_credential(&mut self) -> KeytabCredential {
        if self.has_keytab_credential() {
            match self.credential.take() {
                ::std::option::Option::Some(GetCredentialResponse_oneof_credential::keytab_credential(v)) => v,
                _ => panic!(),
            }
        } else {
            KeytabCredential::new()
        }
    }
}

impl ::protobuf::Message for GetCredentialResponse {
    fn is_initialized(&self) -> bool {
        if let Some(GetCredentialResponse_oneof_credential::certificate_credential(ref v)) = self.credential {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(GetCredentialResponse_oneof_credential::password_credential(ref v)) = self.credential {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(GetCredentialResponse_oneof_credential::default_credential(ref v)) = self.credential {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(GetCredentialResponse_oneof_credential::credential_map(ref v)) = self.credential {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(GetCredentialResponse_oneof_credential::keytab_credential(ref v)) = self.credential {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.credential = ::std::option::Option::Some(GetCredentialResponse_oneof_credential::certificate_credential(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.credential = ::std::option::Option::Some(GetCredentialResponse_oneof_credential::password_credential(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.credential = ::std::option::Option::Some(GetCredentialResponse_oneof_credential::default_credential(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.credential = ::std::option::Option::Some(GetCredentialResponse_oneof_credential::credential_map(is.read_message()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.credential = ::std::option::Option::Some(GetCredentialResponse_oneof_credential::keytab_credential(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.credential {
            match v {
                &GetCredentialResponse_oneof_credential::certificate_credential(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &GetCredentialResponse_oneof_credential::password_credential(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &GetCredentialResponse_oneof_credential::default_credential(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &GetCredentialResponse_oneof_credential::credential_map(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &GetCredentialResponse_oneof_credential::keytab_credential(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.credential {
            match v {
                &GetCredentialResponse_oneof_credential::certificate_credential(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &GetCredentialResponse_oneof_credential::password_credential(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &GetCredentialResponse_oneof_credential::default_credential(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &GetCredentialResponse_oneof_credential::credential_map(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &GetCredentialResponse_oneof_credential::keytab_credential(ref v) => {
                    os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetCredentialResponse {
        GetCredentialResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, CertificateCredential>(
                "certificate_credential",
                GetCredentialResponse::has_certificate_credential,
                GetCredentialResponse::get_certificate_credential,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, PasswordCredential>(
                "password_credential",
                GetCredentialResponse::has_password_credential,
                GetCredentialResponse::get_password_credential,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DefaultCredential>(
                "default_credential",
                GetCredentialResponse::has_default_credential,
                GetCredentialResponse::get_default_credential,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, CredentialMap>(
                "credential_map",
                GetCredentialResponse::has_credential_map,
                GetCredentialResponse::get_credential_map,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, KeytabCredential>(
                "keytab_credential",
                GetCredentialResponse::has_keytab_credential,
                GetCredentialResponse::get_keytab_credential,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetCredentialResponse>(
                "GetCredentialResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetCredentialResponse {
        static instance: ::protobuf::rt::LazyV2<GetCredentialResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetCredentialResponse::new)
    }
}

impl ::protobuf::Clear for GetCredentialResponse {
    fn clear(&mut self) {
        self.credential = ::std::option::Option::None;
        self.credential = ::std::option::Option::None;
        self.credential = ::std::option::Option::None;
        self.credential = ::std::option::Option::None;
        self.credential = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetCredentialResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetCredentialResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateFileSystemRequest {
    // message fields
    pub adaptor: ::std::string::String,
    pub location: ::std::string::String,
    pub properties: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // message oneof groups
    pub credential: ::std::option::Option<CreateFileSystemRequest_oneof_credential>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateFileSystemRequest {
    fn default() -> &'a CreateFileSystemRequest {
        <CreateFileSystemRequest as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum CreateFileSystemRequest_oneof_credential {
    certificate_credential(CertificateCredential),
    password_credential(PasswordCredential),
    default_credential(DefaultCredential),
    credential_map(CredentialMap),
    keytab_credential(KeytabCredential),
}

impl CreateFileSystemRequest {
    pub fn new() -> CreateFileSystemRequest {
        ::std::default::Default::default()
    }

    // string adaptor = 1;


    pub fn get_adaptor(&self) -> &str {
        &self.adaptor
    }
    pub fn clear_adaptor(&mut self) {
        self.adaptor.clear();
    }

    // Param is passed by value, moved
    pub fn set_adaptor(&mut self, v: ::std::string::String) {
        self.adaptor = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_adaptor(&mut self) -> &mut ::std::string::String {
        &mut self.adaptor
    }

    // Take field
    pub fn take_adaptor(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.adaptor, ::std::string::String::new())
    }

    // string location = 2;


    pub fn get_location(&self) -> &str {
        &self.location
    }
    pub fn clear_location(&mut self) {
        self.location.clear();
    }

    // Param is passed by value, moved
    pub fn set_location(&mut self, v: ::std::string::String) {
        self.location = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_location(&mut self) -> &mut ::std::string::String {
        &mut self.location
    }

    // Take field
    pub fn take_location(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.location, ::std::string::String::new())
    }

    // repeated .xenon.CreateFileSystemRequest.PropertiesEntry properties = 3;


    pub fn get_properties(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.properties
    }
    pub fn clear_properties(&mut self) {
        self.properties.clear();
    }

    // Param is passed by value, moved
    pub fn set_properties(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.properties = v;
    }

    // Mutable pointer to the field.
    pub fn mut_properties(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.properties
    }

    // Take field
    pub fn take_properties(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.properties, ::std::collections::HashMap::new())
    }

    // .xenon.CertificateCredential certificate_credential = 4;


    pub fn get_certificate_credential(&self) -> &CertificateCredential {
        match self.credential {
            ::std::option::Option::Some(CreateFileSystemRequest_oneof_credential::certificate_credential(ref v)) => v,
            _ => <CertificateCredential as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_certificate_credential(&mut self) {
        self.credential = ::std::option::Option::None;
    }

    pub fn has_certificate_credential(&self) -> bool {
        match self.credential {
            ::std::option::Option::Some(CreateFileSystemRequest_oneof_credential::certificate_credential(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_certificate_credential(&mut self, v: CertificateCredential) {
        self.credential = ::std::option::Option::Some(CreateFileSystemRequest_oneof_credential::certificate_credential(v))
    }

    // Mutable pointer to the field.
    pub fn mut_certificate_credential(&mut self) -> &mut CertificateCredential {
        if let ::std::option::Option::Some(CreateFileSystemRequest_oneof_credential::certificate_credential(_)) = self.credential {
        } else {
            self.credential = ::std::option::Option::Some(CreateFileSystemRequest_oneof_credential::certificate_credential(CertificateCredential::new()));
        }
        match self.credential {
            ::std::option::Option::Some(CreateFileSystemRequest_oneof_credential::certificate_credential(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_certificate_credential(&mut self) -> CertificateCredential {
        if self.has_certificate_credential() {
            match self.credential.take() {
                ::std::option::Option::Some(CreateFileSystemRequest_oneof_credential::certificate_credential(v)) => v,
                _ => panic!(),
            }
        } else {
            CertificateCredential::new()
        }
    }

    // .xenon.PasswordCredential password_credential = 5;


    pub fn get_password_credential(&self) -> &PasswordCredential {
        match self.credential {
            ::std::option::Option::Some(CreateFileSystemRequest_oneof_credential::password_credential(ref v)) => v,
            _ => <PasswordCredential as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_password_credential(&mut self) {
        self.credential = ::std::option::Option::None;
    }

    pub fn has_password_credential(&self) -> bool {
        match self.credential {
            ::std::option::Option::Some(CreateFileSystemRequest_oneof_credential::password_credential(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_password_credential(&mut self, v: PasswordCredential) {
        self.credential = ::std::option::Option::Some(CreateFileSystemRequest_oneof_credential::password_credential(v))
    }

    // Mutable pointer to the field.
    pub fn mut_password_credential(&mut self) -> &mut PasswordCredential {
        if let ::std::option::Option::Some(CreateFileSystemRequest_oneof_credential::password_credential(_)) = self.credential {
        } else {
            self.credential = ::std::option::Option::Some(CreateFileSystemRequest_oneof_credential::password_credential(PasswordCredential::new()));
        }
        match self.credential {
            ::std::option::Option::Some(CreateFileSystemRequest_oneof_credential::password_credential(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_password_credential(&mut self) -> PasswordCredential {
        if self.has_password_credential() {
            match self.credential.take() {
                ::std::option::Option::Some(CreateFileSystemRequest_oneof_credential::password_credential(v)) => v,
                _ => panic!(),
            }
        } else {
            PasswordCredential::new()
        }
    }

    // .xenon.DefaultCredential default_credential = 6;


    pub fn get_default_credential(&self) -> &DefaultCredential {
        match self.credential {
            ::std::option::Option::Some(CreateFileSystemRequest_oneof_credential::default_credential(ref v)) => v,
            _ => <DefaultCredential as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_default_credential(&mut self) {
        self.credential = ::std::option::Option::None;
    }

    pub fn has_default_credential(&self) -> bool {
        match self.credential {
            ::std::option::Option::Some(CreateFileSystemRequest_oneof_credential::default_credential(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_default_credential(&mut self, v: DefaultCredential) {
        self.credential = ::std::option::Option::Some(CreateFileSystemRequest_oneof_credential::default_credential(v))
    }

    // Mutable pointer to the field.
    pub fn mut_default_credential(&mut self) -> &mut DefaultCredential {
        if let ::std::option::Option::Some(CreateFileSystemRequest_oneof_credential::default_credential(_)) = self.credential {
        } else {
            self.credential = ::std::option::Option::Some(CreateFileSystemRequest_oneof_credential::default_credential(DefaultCredential::new()));
        }
        match self.credential {
            ::std::option::Option::Some(CreateFileSystemRequest_oneof_credential::default_credential(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_default_credential(&mut self) -> DefaultCredential {
        if self.has_default_credential() {
            match self.credential.take() {
                ::std::option::Option::Some(CreateFileSystemRequest_oneof_credential::default_credential(v)) => v,
                _ => panic!(),
            }
        } else {
            DefaultCredential::new()
        }
    }

    // .xenon.CredentialMap credential_map = 7;


    pub fn get_credential_map(&self) -> &CredentialMap {
        match self.credential {
            ::std::option::Option::Some(CreateFileSystemRequest_oneof_credential::credential_map(ref v)) => v,
            _ => <CredentialMap as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_credential_map(&mut self) {
        self.credential = ::std::option::Option::None;
    }

    pub fn has_credential_map(&self) -> bool {
        match self.credential {
            ::std::option::Option::Some(CreateFileSystemRequest_oneof_credential::credential_map(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_credential_map(&mut self, v: CredentialMap) {
        self.credential = ::std::option::Option::Some(CreateFileSystemRequest_oneof_credential::credential_map(v))
    }

    // Mutable pointer to the field.
    pub fn mut_credential_map(&mut self) -> &mut CredentialMap {
        if let ::std::option::Option::Some(CreateFileSystemRequest_oneof_credential::credential_map(_)) = self.credential {
        } else {
            self.credential = ::std::option::Option::Some(CreateFileSystemRequest_oneof_credential::credential_map(CredentialMap::new()));
        }
        match self.credential {
            ::std::option::Option::Some(CreateFileSystemRequest_oneof_credential::credential_map(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_credential_map(&mut self) -> CredentialMap {
        if self.has_credential_map() {
            match self.credential.take() {
                ::std::option::Option::Some(CreateFileSystemRequest_oneof_credential::credential_map(v)) => v,
                _ => panic!(),
            }
        } else {
            CredentialMap::new()
        }
    }

    // .xenon.KeytabCredential keytab_credential = 8;


    pub fn get_keytab_credential(&self) -> &KeytabCredential {
        match self.credential {
            ::std::option::Option::Some(CreateFileSystemRequest_oneof_credential::keytab_credential(ref v)) => v,
            _ => <KeytabCredential as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_keytab_credential(&mut self) {
        self.credential = ::std::option::Option::None;
    }

    pub fn has_keytab_credential(&self) -> bool {
        match self.credential {
            ::std::option::Option::Some(CreateFileSystemRequest_oneof_credential::keytab_credential(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_keytab_credential(&mut self, v: KeytabCredential) {
        self.credential = ::std::option::Option::Some(CreateFileSystemRequest_oneof_credential::keytab_credential(v))
    }

    // Mutable pointer to the field.
    pub fn mut_keytab_credential(&mut self) -> &mut KeytabCredential {
        if let ::std::option::Option::Some(CreateFileSystemRequest_oneof_credential::keytab_credential(_)) = self.credential {
        } else {
            self.credential = ::std::option::Option::Some(CreateFileSystemRequest_oneof_credential::keytab_credential(KeytabCredential::new()));
        }
        match self.credential {
            ::std::option::Option::Some(CreateFileSystemRequest_oneof_credential::keytab_credential(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_keytab_credential(&mut self) -> KeytabCredential {
        if self.has_keytab_credential() {
            match self.credential.take() {
                ::std::option::Option::Some(CreateFileSystemRequest_oneof_credential::keytab_credential(v)) => v,
                _ => panic!(),
            }
        } else {
            KeytabCredential::new()
        }
    }
}

impl ::protobuf::Message for CreateFileSystemRequest {
    fn is_initialized(&self) -> bool {
        if let Some(CreateFileSystemRequest_oneof_credential::certificate_credential(ref v)) = self.credential {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(CreateFileSystemRequest_oneof_credential::password_credential(ref v)) = self.credential {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(CreateFileSystemRequest_oneof_credential::default_credential(ref v)) = self.credential {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(CreateFileSystemRequest_oneof_credential::credential_map(ref v)) = self.credential {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(CreateFileSystemRequest_oneof_credential::keytab_credential(ref v)) = self.credential {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.adaptor)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.location)?;
                },
                3 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.properties)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.credential = ::std::option::Option::Some(CreateFileSystemRequest_oneof_credential::certificate_credential(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.credential = ::std::option::Option::Some(CreateFileSystemRequest_oneof_credential::password_credential(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.credential = ::std::option::Option::Some(CreateFileSystemRequest_oneof_credential::default_credential(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.credential = ::std::option::Option::Some(CreateFileSystemRequest_oneof_credential::credential_map(is.read_message()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.credential = ::std::option::Option::Some(CreateFileSystemRequest_oneof_credential::keytab_credential(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.adaptor.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.adaptor);
        }
        if !self.location.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.location);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(3, &self.properties);
        if let ::std::option::Option::Some(ref v) = self.credential {
            match v {
                &CreateFileSystemRequest_oneof_credential::certificate_credential(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &CreateFileSystemRequest_oneof_credential::password_credential(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &CreateFileSystemRequest_oneof_credential::default_credential(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &CreateFileSystemRequest_oneof_credential::credential_map(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &CreateFileSystemRequest_oneof_credential::keytab_credential(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.adaptor.is_empty() {
            os.write_string(1, &self.adaptor)?;
        }
        if !self.location.is_empty() {
            os.write_string(2, &self.location)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(3, &self.properties, os)?;
        if let ::std::option::Option::Some(ref v) = self.credential {
            match v {
                &CreateFileSystemRequest_oneof_credential::certificate_credential(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &CreateFileSystemRequest_oneof_credential::password_credential(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &CreateFileSystemRequest_oneof_credential::default_credential(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &CreateFileSystemRequest_oneof_credential::credential_map(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &CreateFileSystemRequest_oneof_credential::keytab_credential(ref v) => {
                    os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateFileSystemRequest {
        CreateFileSystemRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "adaptor",
                |m: &CreateFileSystemRequest| { &m.adaptor },
                |m: &mut CreateFileSystemRequest| { &mut m.adaptor },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "location",
                |m: &CreateFileSystemRequest| { &m.location },
                |m: &mut CreateFileSystemRequest| { &mut m.location },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "properties",
                |m: &CreateFileSystemRequest| { &m.properties },
                |m: &mut CreateFileSystemRequest| { &mut m.properties },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, CertificateCredential>(
                "certificate_credential",
                CreateFileSystemRequest::has_certificate_credential,
                CreateFileSystemRequest::get_certificate_credential,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, PasswordCredential>(
                "password_credential",
                CreateFileSystemRequest::has_password_credential,
                CreateFileSystemRequest::get_password_credential,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DefaultCredential>(
                "default_credential",
                CreateFileSystemRequest::has_default_credential,
                CreateFileSystemRequest::get_default_credential,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, CredentialMap>(
                "credential_map",
                CreateFileSystemRequest::has_credential_map,
                CreateFileSystemRequest::get_credential_map,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, KeytabCredential>(
                "keytab_credential",
                CreateFileSystemRequest::has_keytab_credential,
                CreateFileSystemRequest::get_keytab_credential,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateFileSystemRequest>(
                "CreateFileSystemRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateFileSystemRequest {
        static instance: ::protobuf::rt::LazyV2<CreateFileSystemRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateFileSystemRequest::new)
    }
}

impl ::protobuf::Clear for CreateFileSystemRequest {
    fn clear(&mut self) {
        self.adaptor.clear();
        self.location.clear();
        self.properties.clear();
        self.credential = ::std::option::Option::None;
        self.credential = ::std::option::Option::None;
        self.credential = ::std::option::Option::None;
        self.credential = ::std::option::Option::None;
        self.credential = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateFileSystemRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateFileSystemRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FileSystem {
    // message fields
    pub id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FileSystem {
    fn default() -> &'a FileSystem {
        <FileSystem as ::protobuf::Message>::default_instance()
    }
}

impl FileSystem {
    pub fn new() -> FileSystem {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for FileSystem {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FileSystem {
        FileSystem::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &FileSystem| { &m.id },
                |m: &mut FileSystem| { &mut m.id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FileSystem>(
                "FileSystem",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FileSystem {
        static instance: ::protobuf::rt::LazyV2<FileSystem> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FileSystem::new)
    }
}

impl ::protobuf::Clear for FileSystem {
    fn clear(&mut self) {
        self.id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FileSystem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileSystem {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FileSystems {
    // message fields
    pub filesystems: ::protobuf::RepeatedField<FileSystem>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FileSystems {
    fn default() -> &'a FileSystems {
        <FileSystems as ::protobuf::Message>::default_instance()
    }
}

impl FileSystems {
    pub fn new() -> FileSystems {
        ::std::default::Default::default()
    }

    // repeated .xenon.FileSystem filesystems = 1;


    pub fn get_filesystems(&self) -> &[FileSystem] {
        &self.filesystems
    }
    pub fn clear_filesystems(&mut self) {
        self.filesystems.clear();
    }

    // Param is passed by value, moved
    pub fn set_filesystems(&mut self, v: ::protobuf::RepeatedField<FileSystem>) {
        self.filesystems = v;
    }

    // Mutable pointer to the field.
    pub fn mut_filesystems(&mut self) -> &mut ::protobuf::RepeatedField<FileSystem> {
        &mut self.filesystems
    }

    // Take field
    pub fn take_filesystems(&mut self) -> ::protobuf::RepeatedField<FileSystem> {
        ::std::mem::replace(&mut self.filesystems, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for FileSystems {
    fn is_initialized(&self) -> bool {
        for v in &self.filesystems {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.filesystems)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.filesystems {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.filesystems {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FileSystems {
        FileSystems::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FileSystem>>(
                "filesystems",
                |m: &FileSystems| { &m.filesystems },
                |m: &mut FileSystems| { &mut m.filesystems },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FileSystems>(
                "FileSystems",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FileSystems {
        static instance: ::protobuf::rt::LazyV2<FileSystems> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FileSystems::new)
    }
}

impl ::protobuf::Clear for FileSystems {
    fn clear(&mut self) {
        self.filesystems.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FileSystems {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileSystems {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Path {
    // message fields
    pub path: ::std::string::String,
    pub separator: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Path {
    fn default() -> &'a Path {
        <Path as ::protobuf::Message>::default_instance()
    }
}

impl Path {
    pub fn new() -> Path {
        ::std::default::Default::default()
    }

    // string path = 1;


    pub fn get_path(&self) -> &str {
        &self.path
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        &mut self.path
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.path, ::std::string::String::new())
    }

    // string separator = 2;


    pub fn get_separator(&self) -> &str {
        &self.separator
    }
    pub fn clear_separator(&mut self) {
        self.separator.clear();
    }

    // Param is passed by value, moved
    pub fn set_separator(&mut self, v: ::std::string::String) {
        self.separator = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_separator(&mut self) -> &mut ::std::string::String {
        &mut self.separator
    }

    // Take field
    pub fn take_separator(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.separator, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Path {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.path)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.separator)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.path);
        }
        if !self.separator.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.separator);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.path.is_empty() {
            os.write_string(1, &self.path)?;
        }
        if !self.separator.is_empty() {
            os.write_string(2, &self.separator)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Path {
        Path::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "path",
                |m: &Path| { &m.path },
                |m: &mut Path| { &mut m.path },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "separator",
                |m: &Path| { &m.separator },
                |m: &mut Path| { &mut m.separator },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Path>(
                "Path",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Path {
        static instance: ::protobuf::rt::LazyV2<Path> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Path::new)
    }
}

impl ::protobuf::Clear for Path {
    fn clear(&mut self) {
        self.path.clear();
        self.separator.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Path {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Path {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PathRequest {
    // message fields
    pub filesystem: ::protobuf::SingularPtrField<FileSystem>,
    pub path: ::protobuf::SingularPtrField<Path>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PathRequest {
    fn default() -> &'a PathRequest {
        <PathRequest as ::protobuf::Message>::default_instance()
    }
}

impl PathRequest {
    pub fn new() -> PathRequest {
        ::std::default::Default::default()
    }

    // .xenon.FileSystem filesystem = 1;


    pub fn get_filesystem(&self) -> &FileSystem {
        self.filesystem.as_ref().unwrap_or_else(|| <FileSystem as ::protobuf::Message>::default_instance())
    }
    pub fn clear_filesystem(&mut self) {
        self.filesystem.clear();
    }

    pub fn has_filesystem(&self) -> bool {
        self.filesystem.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filesystem(&mut self, v: FileSystem) {
        self.filesystem = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filesystem(&mut self) -> &mut FileSystem {
        if self.filesystem.is_none() {
            self.filesystem.set_default();
        }
        self.filesystem.as_mut().unwrap()
    }

    // Take field
    pub fn take_filesystem(&mut self) -> FileSystem {
        self.filesystem.take().unwrap_or_else(|| FileSystem::new())
    }

    // .xenon.Path path = 2;


    pub fn get_path(&self) -> &Path {
        self.path.as_ref().unwrap_or_else(|| <Path as ::protobuf::Message>::default_instance())
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: Path) {
        self.path = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut Path {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> Path {
        self.path.take().unwrap_or_else(|| Path::new())
    }
}

impl ::protobuf::Message for PathRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.filesystem {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.path {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.filesystem)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.filesystem.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.path.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.filesystem.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.path.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PathRequest {
        PathRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FileSystem>>(
                "filesystem",
                |m: &PathRequest| { &m.filesystem },
                |m: &mut PathRequest| { &mut m.filesystem },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Path>>(
                "path",
                |m: &PathRequest| { &m.path },
                |m: &mut PathRequest| { &mut m.path },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PathRequest>(
                "PathRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PathRequest {
        static instance: ::protobuf::rt::LazyV2<PathRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PathRequest::new)
    }
}

impl ::protobuf::Clear for PathRequest {
    fn clear(&mut self) {
        self.filesystem.clear();
        self.path.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PathRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PathRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteRequest {
    // message fields
    pub filesystem: ::protobuf::SingularPtrField<FileSystem>,
    pub path: ::protobuf::SingularPtrField<Path>,
    pub recursive: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteRequest {
    fn default() -> &'a DeleteRequest {
        <DeleteRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteRequest {
    pub fn new() -> DeleteRequest {
        ::std::default::Default::default()
    }

    // .xenon.FileSystem filesystem = 1;


    pub fn get_filesystem(&self) -> &FileSystem {
        self.filesystem.as_ref().unwrap_or_else(|| <FileSystem as ::protobuf::Message>::default_instance())
    }
    pub fn clear_filesystem(&mut self) {
        self.filesystem.clear();
    }

    pub fn has_filesystem(&self) -> bool {
        self.filesystem.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filesystem(&mut self, v: FileSystem) {
        self.filesystem = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filesystem(&mut self) -> &mut FileSystem {
        if self.filesystem.is_none() {
            self.filesystem.set_default();
        }
        self.filesystem.as_mut().unwrap()
    }

    // Take field
    pub fn take_filesystem(&mut self) -> FileSystem {
        self.filesystem.take().unwrap_or_else(|| FileSystem::new())
    }

    // .xenon.Path path = 2;


    pub fn get_path(&self) -> &Path {
        self.path.as_ref().unwrap_or_else(|| <Path as ::protobuf::Message>::default_instance())
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: Path) {
        self.path = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut Path {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> Path {
        self.path.take().unwrap_or_else(|| Path::new())
    }

    // bool recursive = 3;


    pub fn get_recursive(&self) -> bool {
        self.recursive
    }
    pub fn clear_recursive(&mut self) {
        self.recursive = false;
    }

    // Param is passed by value, moved
    pub fn set_recursive(&mut self, v: bool) {
        self.recursive = v;
    }
}

impl ::protobuf::Message for DeleteRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.filesystem {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.path {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.filesystem)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.path)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.recursive = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.filesystem.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.path.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.recursive != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.filesystem.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.path.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.recursive != false {
            os.write_bool(3, self.recursive)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteRequest {
        DeleteRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FileSystem>>(
                "filesystem",
                |m: &DeleteRequest| { &m.filesystem },
                |m: &mut DeleteRequest| { &mut m.filesystem },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Path>>(
                "path",
                |m: &DeleteRequest| { &m.path },
                |m: &mut DeleteRequest| { &mut m.path },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "recursive",
                |m: &DeleteRequest| { &m.recursive },
                |m: &mut DeleteRequest| { &mut m.recursive },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteRequest>(
                "DeleteRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteRequest::new)
    }
}

impl ::protobuf::Clear for DeleteRequest {
    fn clear(&mut self) {
        self.filesystem.clear();
        self.path.clear();
        self.recursive = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CopyRequest {
    // message fields
    pub filesystem: ::protobuf::SingularPtrField<FileSystem>,
    pub source: ::protobuf::SingularPtrField<Path>,
    pub destination_filesystem: ::protobuf::SingularPtrField<FileSystem>,
    pub destination: ::protobuf::SingularPtrField<Path>,
    pub mode: CopyRequest_CopyMode,
    pub recursive: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CopyRequest {
    fn default() -> &'a CopyRequest {
        <CopyRequest as ::protobuf::Message>::default_instance()
    }
}

impl CopyRequest {
    pub fn new() -> CopyRequest {
        ::std::default::Default::default()
    }

    // .xenon.FileSystem filesystem = 1;


    pub fn get_filesystem(&self) -> &FileSystem {
        self.filesystem.as_ref().unwrap_or_else(|| <FileSystem as ::protobuf::Message>::default_instance())
    }
    pub fn clear_filesystem(&mut self) {
        self.filesystem.clear();
    }

    pub fn has_filesystem(&self) -> bool {
        self.filesystem.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filesystem(&mut self, v: FileSystem) {
        self.filesystem = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filesystem(&mut self) -> &mut FileSystem {
        if self.filesystem.is_none() {
            self.filesystem.set_default();
        }
        self.filesystem.as_mut().unwrap()
    }

    // Take field
    pub fn take_filesystem(&mut self) -> FileSystem {
        self.filesystem.take().unwrap_or_else(|| FileSystem::new())
    }

    // .xenon.Path source = 2;


    pub fn get_source(&self) -> &Path {
        self.source.as_ref().unwrap_or_else(|| <Path as ::protobuf::Message>::default_instance())
    }
    pub fn clear_source(&mut self) {
        self.source.clear();
    }

    pub fn has_source(&self) -> bool {
        self.source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: Path) {
        self.source = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source(&mut self) -> &mut Path {
        if self.source.is_none() {
            self.source.set_default();
        }
        self.source.as_mut().unwrap()
    }

    // Take field
    pub fn take_source(&mut self) -> Path {
        self.source.take().unwrap_or_else(|| Path::new())
    }

    // .xenon.FileSystem destination_filesystem = 3;


    pub fn get_destination_filesystem(&self) -> &FileSystem {
        self.destination_filesystem.as_ref().unwrap_or_else(|| <FileSystem as ::protobuf::Message>::default_instance())
    }
    pub fn clear_destination_filesystem(&mut self) {
        self.destination_filesystem.clear();
    }

    pub fn has_destination_filesystem(&self) -> bool {
        self.destination_filesystem.is_some()
    }

    // Param is passed by value, moved
    pub fn set_destination_filesystem(&mut self, v: FileSystem) {
        self.destination_filesystem = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_destination_filesystem(&mut self) -> &mut FileSystem {
        if self.destination_filesystem.is_none() {
            self.destination_filesystem.set_default();
        }
        self.destination_filesystem.as_mut().unwrap()
    }

    // Take field
    pub fn take_destination_filesystem(&mut self) -> FileSystem {
        self.destination_filesystem.take().unwrap_or_else(|| FileSystem::new())
    }

    // .xenon.Path destination = 4;


    pub fn get_destination(&self) -> &Path {
        self.destination.as_ref().unwrap_or_else(|| <Path as ::protobuf::Message>::default_instance())
    }
    pub fn clear_destination(&mut self) {
        self.destination.clear();
    }

    pub fn has_destination(&self) -> bool {
        self.destination.is_some()
    }

    // Param is passed by value, moved
    pub fn set_destination(&mut self, v: Path) {
        self.destination = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_destination(&mut self) -> &mut Path {
        if self.destination.is_none() {
            self.destination.set_default();
        }
        self.destination.as_mut().unwrap()
    }

    // Take field
    pub fn take_destination(&mut self) -> Path {
        self.destination.take().unwrap_or_else(|| Path::new())
    }

    // .xenon.CopyRequest.CopyMode mode = 5;


    pub fn get_mode(&self) -> CopyRequest_CopyMode {
        self.mode
    }
    pub fn clear_mode(&mut self) {
        self.mode = CopyRequest_CopyMode::CREATE;
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: CopyRequest_CopyMode) {
        self.mode = v;
    }

    // bool recursive = 6;


    pub fn get_recursive(&self) -> bool {
        self.recursive
    }
    pub fn clear_recursive(&mut self) {
        self.recursive = false;
    }

    // Param is passed by value, moved
    pub fn set_recursive(&mut self, v: bool) {
        self.recursive = v;
    }
}

impl ::protobuf::Message for CopyRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.filesystem {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.source {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.destination_filesystem {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.destination {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.filesystem)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.source)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.destination_filesystem)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.destination)?;
                },
                5 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.mode, 5, &mut self.unknown_fields)?
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.recursive = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.filesystem.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.source.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.destination_filesystem.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.destination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.mode != CopyRequest_CopyMode::CREATE {
            my_size += ::protobuf::rt::enum_size(5, self.mode);
        }
        if self.recursive != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.filesystem.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.source.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.destination_filesystem.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.destination.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.mode != CopyRequest_CopyMode::CREATE {
            os.write_enum(5, ::protobuf::ProtobufEnum::value(&self.mode))?;
        }
        if self.recursive != false {
            os.write_bool(6, self.recursive)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CopyRequest {
        CopyRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FileSystem>>(
                "filesystem",
                |m: &CopyRequest| { &m.filesystem },
                |m: &mut CopyRequest| { &mut m.filesystem },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Path>>(
                "source",
                |m: &CopyRequest| { &m.source },
                |m: &mut CopyRequest| { &mut m.source },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FileSystem>>(
                "destination_filesystem",
                |m: &CopyRequest| { &m.destination_filesystem },
                |m: &mut CopyRequest| { &mut m.destination_filesystem },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Path>>(
                "destination",
                |m: &CopyRequest| { &m.destination },
                |m: &mut CopyRequest| { &mut m.destination },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CopyRequest_CopyMode>>(
                "mode",
                |m: &CopyRequest| { &m.mode },
                |m: &mut CopyRequest| { &mut m.mode },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "recursive",
                |m: &CopyRequest| { &m.recursive },
                |m: &mut CopyRequest| { &mut m.recursive },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CopyRequest>(
                "CopyRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CopyRequest {
        static instance: ::protobuf::rt::LazyV2<CopyRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CopyRequest::new)
    }
}

impl ::protobuf::Clear for CopyRequest {
    fn clear(&mut self) {
        self.filesystem.clear();
        self.source.clear();
        self.destination_filesystem.clear();
        self.destination.clear();
        self.mode = CopyRequest_CopyMode::CREATE;
        self.recursive = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CopyRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CopyRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CopyRequest_CopyMode {
    CREATE = 0,
    REPLACE = 1,
    IGNORE = 2,
}

impl ::protobuf::ProtobufEnum for CopyRequest_CopyMode {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CopyRequest_CopyMode> {
        match value {
            0 => ::std::option::Option::Some(CopyRequest_CopyMode::CREATE),
            1 => ::std::option::Option::Some(CopyRequest_CopyMode::REPLACE),
            2 => ::std::option::Option::Some(CopyRequest_CopyMode::IGNORE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CopyRequest_CopyMode] = &[
            CopyRequest_CopyMode::CREATE,
            CopyRequest_CopyMode::REPLACE,
            CopyRequest_CopyMode::IGNORE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CopyRequest_CopyMode>("CopyRequest.CopyMode", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CopyRequest_CopyMode {
}

impl ::std::default::Default for CopyRequest_CopyMode {
    fn default() -> Self {
        CopyRequest_CopyMode::CREATE
    }
}

impl ::protobuf::reflect::ProtobufValue for CopyRequest_CopyMode {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RenameRequest {
    // message fields
    pub filesystem: ::protobuf::SingularPtrField<FileSystem>,
    pub source: ::protobuf::SingularPtrField<Path>,
    pub target: ::protobuf::SingularPtrField<Path>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RenameRequest {
    fn default() -> &'a RenameRequest {
        <RenameRequest as ::protobuf::Message>::default_instance()
    }
}

impl RenameRequest {
    pub fn new() -> RenameRequest {
        ::std::default::Default::default()
    }

    // .xenon.FileSystem filesystem = 1;


    pub fn get_filesystem(&self) -> &FileSystem {
        self.filesystem.as_ref().unwrap_or_else(|| <FileSystem as ::protobuf::Message>::default_instance())
    }
    pub fn clear_filesystem(&mut self) {
        self.filesystem.clear();
    }

    pub fn has_filesystem(&self) -> bool {
        self.filesystem.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filesystem(&mut self, v: FileSystem) {
        self.filesystem = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filesystem(&mut self) -> &mut FileSystem {
        if self.filesystem.is_none() {
            self.filesystem.set_default();
        }
        self.filesystem.as_mut().unwrap()
    }

    // Take field
    pub fn take_filesystem(&mut self) -> FileSystem {
        self.filesystem.take().unwrap_or_else(|| FileSystem::new())
    }

    // .xenon.Path source = 2;


    pub fn get_source(&self) -> &Path {
        self.source.as_ref().unwrap_or_else(|| <Path as ::protobuf::Message>::default_instance())
    }
    pub fn clear_source(&mut self) {
        self.source.clear();
    }

    pub fn has_source(&self) -> bool {
        self.source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: Path) {
        self.source = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source(&mut self) -> &mut Path {
        if self.source.is_none() {
            self.source.set_default();
        }
        self.source.as_mut().unwrap()
    }

    // Take field
    pub fn take_source(&mut self) -> Path {
        self.source.take().unwrap_or_else(|| Path::new())
    }

    // .xenon.Path target = 3;


    pub fn get_target(&self) -> &Path {
        self.target.as_ref().unwrap_or_else(|| <Path as ::protobuf::Message>::default_instance())
    }
    pub fn clear_target(&mut self) {
        self.target.clear();
    }

    pub fn has_target(&self) -> bool {
        self.target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target(&mut self, v: Path) {
        self.target = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_target(&mut self) -> &mut Path {
        if self.target.is_none() {
            self.target.set_default();
        }
        self.target.as_mut().unwrap()
    }

    // Take field
    pub fn take_target(&mut self) -> Path {
        self.target.take().unwrap_or_else(|| Path::new())
    }
}

impl ::protobuf::Message for RenameRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.filesystem {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.source {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.target {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.filesystem)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.source)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.target)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.filesystem.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.source.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.target.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.filesystem.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.source.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.target.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RenameRequest {
        RenameRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FileSystem>>(
                "filesystem",
                |m: &RenameRequest| { &m.filesystem },
                |m: &mut RenameRequest| { &mut m.filesystem },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Path>>(
                "source",
                |m: &RenameRequest| { &m.source },
                |m: &mut RenameRequest| { &mut m.source },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Path>>(
                "target",
                |m: &RenameRequest| { &m.target },
                |m: &mut RenameRequest| { &mut m.target },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RenameRequest>(
                "RenameRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RenameRequest {
        static instance: ::protobuf::rt::LazyV2<RenameRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RenameRequest::new)
    }
}

impl ::protobuf::Clear for RenameRequest {
    fn clear(&mut self) {
        self.filesystem.clear();
        self.source.clear();
        self.target.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RenameRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RenameRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateSymbolicLinkRequest {
    // message fields
    pub filesystem: ::protobuf::SingularPtrField<FileSystem>,
    pub link: ::protobuf::SingularPtrField<Path>,
    pub target: ::protobuf::SingularPtrField<Path>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateSymbolicLinkRequest {
    fn default() -> &'a CreateSymbolicLinkRequest {
        <CreateSymbolicLinkRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateSymbolicLinkRequest {
    pub fn new() -> CreateSymbolicLinkRequest {
        ::std::default::Default::default()
    }

    // .xenon.FileSystem filesystem = 1;


    pub fn get_filesystem(&self) -> &FileSystem {
        self.filesystem.as_ref().unwrap_or_else(|| <FileSystem as ::protobuf::Message>::default_instance())
    }
    pub fn clear_filesystem(&mut self) {
        self.filesystem.clear();
    }

    pub fn has_filesystem(&self) -> bool {
        self.filesystem.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filesystem(&mut self, v: FileSystem) {
        self.filesystem = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filesystem(&mut self) -> &mut FileSystem {
        if self.filesystem.is_none() {
            self.filesystem.set_default();
        }
        self.filesystem.as_mut().unwrap()
    }

    // Take field
    pub fn take_filesystem(&mut self) -> FileSystem {
        self.filesystem.take().unwrap_or_else(|| FileSystem::new())
    }

    // .xenon.Path link = 2;


    pub fn get_link(&self) -> &Path {
        self.link.as_ref().unwrap_or_else(|| <Path as ::protobuf::Message>::default_instance())
    }
    pub fn clear_link(&mut self) {
        self.link.clear();
    }

    pub fn has_link(&self) -> bool {
        self.link.is_some()
    }

    // Param is passed by value, moved
    pub fn set_link(&mut self, v: Path) {
        self.link = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_link(&mut self) -> &mut Path {
        if self.link.is_none() {
            self.link.set_default();
        }
        self.link.as_mut().unwrap()
    }

    // Take field
    pub fn take_link(&mut self) -> Path {
        self.link.take().unwrap_or_else(|| Path::new())
    }

    // .xenon.Path target = 3;


    pub fn get_target(&self) -> &Path {
        self.target.as_ref().unwrap_or_else(|| <Path as ::protobuf::Message>::default_instance())
    }
    pub fn clear_target(&mut self) {
        self.target.clear();
    }

    pub fn has_target(&self) -> bool {
        self.target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target(&mut self, v: Path) {
        self.target = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_target(&mut self) -> &mut Path {
        if self.target.is_none() {
            self.target.set_default();
        }
        self.target.as_mut().unwrap()
    }

    // Take field
    pub fn take_target(&mut self) -> Path {
        self.target.take().unwrap_or_else(|| Path::new())
    }
}

impl ::protobuf::Message for CreateSymbolicLinkRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.filesystem {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.link {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.target {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.filesystem)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.link)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.target)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.filesystem.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.link.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.target.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.filesystem.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.link.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.target.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateSymbolicLinkRequest {
        CreateSymbolicLinkRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FileSystem>>(
                "filesystem",
                |m: &CreateSymbolicLinkRequest| { &m.filesystem },
                |m: &mut CreateSymbolicLinkRequest| { &mut m.filesystem },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Path>>(
                "link",
                |m: &CreateSymbolicLinkRequest| { &m.link },
                |m: &mut CreateSymbolicLinkRequest| { &mut m.link },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Path>>(
                "target",
                |m: &CreateSymbolicLinkRequest| { &m.target },
                |m: &mut CreateSymbolicLinkRequest| { &mut m.target },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateSymbolicLinkRequest>(
                "CreateSymbolicLinkRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateSymbolicLinkRequest {
        static instance: ::protobuf::rt::LazyV2<CreateSymbolicLinkRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateSymbolicLinkRequest::new)
    }
}

impl ::protobuf::Clear for CreateSymbolicLinkRequest {
    fn clear(&mut self) {
        self.filesystem.clear();
        self.link.clear();
        self.target.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateSymbolicLinkRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateSymbolicLinkRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CopyOperation {
    // message fields
    pub id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CopyOperation {
    fn default() -> &'a CopyOperation {
        <CopyOperation as ::protobuf::Message>::default_instance()
    }
}

impl CopyOperation {
    pub fn new() -> CopyOperation {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CopyOperation {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CopyOperation {
        CopyOperation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &CopyOperation| { &m.id },
                |m: &mut CopyOperation| { &mut m.id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CopyOperation>(
                "CopyOperation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CopyOperation {
        static instance: ::protobuf::rt::LazyV2<CopyOperation> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CopyOperation::new)
    }
}

impl ::protobuf::Clear for CopyOperation {
    fn clear(&mut self) {
        self.id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CopyOperation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CopyOperation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CopyOperationRequest {
    // message fields
    pub filesystem: ::protobuf::SingularPtrField<FileSystem>,
    pub copy_operation: ::protobuf::SingularPtrField<CopyOperation>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CopyOperationRequest {
    fn default() -> &'a CopyOperationRequest {
        <CopyOperationRequest as ::protobuf::Message>::default_instance()
    }
}

impl CopyOperationRequest {
    pub fn new() -> CopyOperationRequest {
        ::std::default::Default::default()
    }

    // .xenon.FileSystem filesystem = 1;


    pub fn get_filesystem(&self) -> &FileSystem {
        self.filesystem.as_ref().unwrap_or_else(|| <FileSystem as ::protobuf::Message>::default_instance())
    }
    pub fn clear_filesystem(&mut self) {
        self.filesystem.clear();
    }

    pub fn has_filesystem(&self) -> bool {
        self.filesystem.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filesystem(&mut self, v: FileSystem) {
        self.filesystem = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filesystem(&mut self) -> &mut FileSystem {
        if self.filesystem.is_none() {
            self.filesystem.set_default();
        }
        self.filesystem.as_mut().unwrap()
    }

    // Take field
    pub fn take_filesystem(&mut self) -> FileSystem {
        self.filesystem.take().unwrap_or_else(|| FileSystem::new())
    }

    // .xenon.CopyOperation copy_operation = 2;


    pub fn get_copy_operation(&self) -> &CopyOperation {
        self.copy_operation.as_ref().unwrap_or_else(|| <CopyOperation as ::protobuf::Message>::default_instance())
    }
    pub fn clear_copy_operation(&mut self) {
        self.copy_operation.clear();
    }

    pub fn has_copy_operation(&self) -> bool {
        self.copy_operation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_copy_operation(&mut self, v: CopyOperation) {
        self.copy_operation = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_copy_operation(&mut self) -> &mut CopyOperation {
        if self.copy_operation.is_none() {
            self.copy_operation.set_default();
        }
        self.copy_operation.as_mut().unwrap()
    }

    // Take field
    pub fn take_copy_operation(&mut self) -> CopyOperation {
        self.copy_operation.take().unwrap_or_else(|| CopyOperation::new())
    }
}

impl ::protobuf::Message for CopyOperationRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.filesystem {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.copy_operation {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.filesystem)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.copy_operation)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.filesystem.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.copy_operation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.filesystem.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.copy_operation.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CopyOperationRequest {
        CopyOperationRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FileSystem>>(
                "filesystem",
                |m: &CopyOperationRequest| { &m.filesystem },
                |m: &mut CopyOperationRequest| { &mut m.filesystem },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CopyOperation>>(
                "copy_operation",
                |m: &CopyOperationRequest| { &m.copy_operation },
                |m: &mut CopyOperationRequest| { &mut m.copy_operation },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CopyOperationRequest>(
                "CopyOperationRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CopyOperationRequest {
        static instance: ::protobuf::rt::LazyV2<CopyOperationRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CopyOperationRequest::new)
    }
}

impl ::protobuf::Clear for CopyOperationRequest {
    fn clear(&mut self) {
        self.filesystem.clear();
        self.copy_operation.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CopyOperationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CopyOperationRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WaitUntilDoneRequest {
    // message fields
    pub filesystem: ::protobuf::SingularPtrField<FileSystem>,
    pub copy_operation: ::protobuf::SingularPtrField<CopyOperation>,
    pub timeout: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WaitUntilDoneRequest {
    fn default() -> &'a WaitUntilDoneRequest {
        <WaitUntilDoneRequest as ::protobuf::Message>::default_instance()
    }
}

impl WaitUntilDoneRequest {
    pub fn new() -> WaitUntilDoneRequest {
        ::std::default::Default::default()
    }

    // .xenon.FileSystem filesystem = 1;


    pub fn get_filesystem(&self) -> &FileSystem {
        self.filesystem.as_ref().unwrap_or_else(|| <FileSystem as ::protobuf::Message>::default_instance())
    }
    pub fn clear_filesystem(&mut self) {
        self.filesystem.clear();
    }

    pub fn has_filesystem(&self) -> bool {
        self.filesystem.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filesystem(&mut self, v: FileSystem) {
        self.filesystem = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filesystem(&mut self) -> &mut FileSystem {
        if self.filesystem.is_none() {
            self.filesystem.set_default();
        }
        self.filesystem.as_mut().unwrap()
    }

    // Take field
    pub fn take_filesystem(&mut self) -> FileSystem {
        self.filesystem.take().unwrap_or_else(|| FileSystem::new())
    }

    // .xenon.CopyOperation copy_operation = 2;


    pub fn get_copy_operation(&self) -> &CopyOperation {
        self.copy_operation.as_ref().unwrap_or_else(|| <CopyOperation as ::protobuf::Message>::default_instance())
    }
    pub fn clear_copy_operation(&mut self) {
        self.copy_operation.clear();
    }

    pub fn has_copy_operation(&self) -> bool {
        self.copy_operation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_copy_operation(&mut self, v: CopyOperation) {
        self.copy_operation = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_copy_operation(&mut self) -> &mut CopyOperation {
        if self.copy_operation.is_none() {
            self.copy_operation.set_default();
        }
        self.copy_operation.as_mut().unwrap()
    }

    // Take field
    pub fn take_copy_operation(&mut self) -> CopyOperation {
        self.copy_operation.take().unwrap_or_else(|| CopyOperation::new())
    }

    // uint64 timeout = 3;


    pub fn get_timeout(&self) -> u64 {
        self.timeout
    }
    pub fn clear_timeout(&mut self) {
        self.timeout = 0;
    }

    // Param is passed by value, moved
    pub fn set_timeout(&mut self, v: u64) {
        self.timeout = v;
    }
}

impl ::protobuf::Message for WaitUntilDoneRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.filesystem {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.copy_operation {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.filesystem)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.copy_operation)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.timeout = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.filesystem.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.copy_operation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.timeout != 0 {
            my_size += ::protobuf::rt::value_size(3, self.timeout, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.filesystem.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.copy_operation.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.timeout != 0 {
            os.write_uint64(3, self.timeout)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WaitUntilDoneRequest {
        WaitUntilDoneRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FileSystem>>(
                "filesystem",
                |m: &WaitUntilDoneRequest| { &m.filesystem },
                |m: &mut WaitUntilDoneRequest| { &mut m.filesystem },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CopyOperation>>(
                "copy_operation",
                |m: &WaitUntilDoneRequest| { &m.copy_operation },
                |m: &mut WaitUntilDoneRequest| { &mut m.copy_operation },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "timeout",
                |m: &WaitUntilDoneRequest| { &m.timeout },
                |m: &mut WaitUntilDoneRequest| { &mut m.timeout },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WaitUntilDoneRequest>(
                "WaitUntilDoneRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static WaitUntilDoneRequest {
        static instance: ::protobuf::rt::LazyV2<WaitUntilDoneRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WaitUntilDoneRequest::new)
    }
}

impl ::protobuf::Clear for WaitUntilDoneRequest {
    fn clear(&mut self) {
        self.filesystem.clear();
        self.copy_operation.clear();
        self.timeout = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WaitUntilDoneRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WaitUntilDoneRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CopyStatus {
    // message fields
    pub copy_operation: ::protobuf::SingularPtrField<CopyOperation>,
    pub bytes_copied: u64,
    pub bytes_to_copy: u64,
    pub done: bool,
    pub running: bool,
    pub state: ::std::string::String,
    pub error_message: ::std::string::String,
    pub error_type: CopyStatus_ErrorType,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CopyStatus {
    fn default() -> &'a CopyStatus {
        <CopyStatus as ::protobuf::Message>::default_instance()
    }
}

impl CopyStatus {
    pub fn new() -> CopyStatus {
        ::std::default::Default::default()
    }

    // .xenon.CopyOperation copy_operation = 1;


    pub fn get_copy_operation(&self) -> &CopyOperation {
        self.copy_operation.as_ref().unwrap_or_else(|| <CopyOperation as ::protobuf::Message>::default_instance())
    }
    pub fn clear_copy_operation(&mut self) {
        self.copy_operation.clear();
    }

    pub fn has_copy_operation(&self) -> bool {
        self.copy_operation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_copy_operation(&mut self, v: CopyOperation) {
        self.copy_operation = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_copy_operation(&mut self) -> &mut CopyOperation {
        if self.copy_operation.is_none() {
            self.copy_operation.set_default();
        }
        self.copy_operation.as_mut().unwrap()
    }

    // Take field
    pub fn take_copy_operation(&mut self) -> CopyOperation {
        self.copy_operation.take().unwrap_or_else(|| CopyOperation::new())
    }

    // uint64 bytes_copied = 2;


    pub fn get_bytes_copied(&self) -> u64 {
        self.bytes_copied
    }
    pub fn clear_bytes_copied(&mut self) {
        self.bytes_copied = 0;
    }

    // Param is passed by value, moved
    pub fn set_bytes_copied(&mut self, v: u64) {
        self.bytes_copied = v;
    }

    // uint64 bytes_to_copy = 3;


    pub fn get_bytes_to_copy(&self) -> u64 {
        self.bytes_to_copy
    }
    pub fn clear_bytes_to_copy(&mut self) {
        self.bytes_to_copy = 0;
    }

    // Param is passed by value, moved
    pub fn set_bytes_to_copy(&mut self, v: u64) {
        self.bytes_to_copy = v;
    }

    // bool done = 4;


    pub fn get_done(&self) -> bool {
        self.done
    }
    pub fn clear_done(&mut self) {
        self.done = false;
    }

    // Param is passed by value, moved
    pub fn set_done(&mut self, v: bool) {
        self.done = v;
    }

    // bool running = 5;


    pub fn get_running(&self) -> bool {
        self.running
    }
    pub fn clear_running(&mut self) {
        self.running = false;
    }

    // Param is passed by value, moved
    pub fn set_running(&mut self, v: bool) {
        self.running = v;
    }

    // string state = 6;


    pub fn get_state(&self) -> &str {
        &self.state
    }
    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: ::std::string::String) {
        self.state = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut ::std::string::String {
        &mut self.state
    }

    // Take field
    pub fn take_state(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.state, ::std::string::String::new())
    }

    // string error_message = 7;


    pub fn get_error_message(&self) -> &str {
        &self.error_message
    }
    pub fn clear_error_message(&mut self) {
        self.error_message.clear();
    }

    // Param is passed by value, moved
    pub fn set_error_message(&mut self, v: ::std::string::String) {
        self.error_message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_message(&mut self) -> &mut ::std::string::String {
        &mut self.error_message
    }

    // Take field
    pub fn take_error_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.error_message, ::std::string::String::new())
    }

    // .xenon.CopyStatus.ErrorType error_type = 8;


    pub fn get_error_type(&self) -> CopyStatus_ErrorType {
        self.error_type
    }
    pub fn clear_error_type(&mut self) {
        self.error_type = CopyStatus_ErrorType::NONE;
    }

    // Param is passed by value, moved
    pub fn set_error_type(&mut self, v: CopyStatus_ErrorType) {
        self.error_type = v;
    }
}

impl ::protobuf::Message for CopyStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.copy_operation {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.copy_operation)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.bytes_copied = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.bytes_to_copy = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.done = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.running = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.state)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.error_message)?;
                },
                8 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.error_type, 8, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.copy_operation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.bytes_copied != 0 {
            my_size += ::protobuf::rt::value_size(2, self.bytes_copied, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.bytes_to_copy != 0 {
            my_size += ::protobuf::rt::value_size(3, self.bytes_to_copy, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.done != false {
            my_size += 2;
        }
        if self.running != false {
            my_size += 2;
        }
        if !self.state.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.state);
        }
        if !self.error_message.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.error_message);
        }
        if self.error_type != CopyStatus_ErrorType::NONE {
            my_size += ::protobuf::rt::enum_size(8, self.error_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.copy_operation.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.bytes_copied != 0 {
            os.write_uint64(2, self.bytes_copied)?;
        }
        if self.bytes_to_copy != 0 {
            os.write_uint64(3, self.bytes_to_copy)?;
        }
        if self.done != false {
            os.write_bool(4, self.done)?;
        }
        if self.running != false {
            os.write_bool(5, self.running)?;
        }
        if !self.state.is_empty() {
            os.write_string(6, &self.state)?;
        }
        if !self.error_message.is_empty() {
            os.write_string(7, &self.error_message)?;
        }
        if self.error_type != CopyStatus_ErrorType::NONE {
            os.write_enum(8, ::protobuf::ProtobufEnum::value(&self.error_type))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CopyStatus {
        CopyStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CopyOperation>>(
                "copy_operation",
                |m: &CopyStatus| { &m.copy_operation },
                |m: &mut CopyStatus| { &mut m.copy_operation },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "bytes_copied",
                |m: &CopyStatus| { &m.bytes_copied },
                |m: &mut CopyStatus| { &mut m.bytes_copied },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "bytes_to_copy",
                |m: &CopyStatus| { &m.bytes_to_copy },
                |m: &mut CopyStatus| { &mut m.bytes_to_copy },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "done",
                |m: &CopyStatus| { &m.done },
                |m: &mut CopyStatus| { &mut m.done },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "running",
                |m: &CopyStatus| { &m.running },
                |m: &mut CopyStatus| { &mut m.running },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "state",
                |m: &CopyStatus| { &m.state },
                |m: &mut CopyStatus| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "error_message",
                |m: &CopyStatus| { &m.error_message },
                |m: &mut CopyStatus| { &mut m.error_message },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CopyStatus_ErrorType>>(
                "error_type",
                |m: &CopyStatus| { &m.error_type },
                |m: &mut CopyStatus| { &mut m.error_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CopyStatus>(
                "CopyStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CopyStatus {
        static instance: ::protobuf::rt::LazyV2<CopyStatus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CopyStatus::new)
    }
}

impl ::protobuf::Clear for CopyStatus {
    fn clear(&mut self) {
        self.copy_operation.clear();
        self.bytes_copied = 0;
        self.bytes_to_copy = 0;
        self.done = false;
        self.running = false;
        self.state.clear();
        self.error_message.clear();
        self.error_type = CopyStatus_ErrorType::NONE;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CopyStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CopyStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CopyStatus_ErrorType {
    NONE = 0,
    NOT_FOUND = 1,
    CANCELLED = 2,
    ALREADY_EXISTS = 3,
    NOT_CONNECTED = 4,
    XENON = 5,
}

impl ::protobuf::ProtobufEnum for CopyStatus_ErrorType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CopyStatus_ErrorType> {
        match value {
            0 => ::std::option::Option::Some(CopyStatus_ErrorType::NONE),
            1 => ::std::option::Option::Some(CopyStatus_ErrorType::NOT_FOUND),
            2 => ::std::option::Option::Some(CopyStatus_ErrorType::CANCELLED),
            3 => ::std::option::Option::Some(CopyStatus_ErrorType::ALREADY_EXISTS),
            4 => ::std::option::Option::Some(CopyStatus_ErrorType::NOT_CONNECTED),
            5 => ::std::option::Option::Some(CopyStatus_ErrorType::XENON),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CopyStatus_ErrorType] = &[
            CopyStatus_ErrorType::NONE,
            CopyStatus_ErrorType::NOT_FOUND,
            CopyStatus_ErrorType::CANCELLED,
            CopyStatus_ErrorType::ALREADY_EXISTS,
            CopyStatus_ErrorType::NOT_CONNECTED,
            CopyStatus_ErrorType::XENON,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CopyStatus_ErrorType>("CopyStatus.ErrorType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CopyStatus_ErrorType {
}

impl ::std::default::Default for CopyStatus_ErrorType {
    fn default() -> Self {
        CopyStatus_ErrorType::NONE
    }
}

impl ::protobuf::reflect::ProtobufValue for CopyStatus_ErrorType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PathAttributes {
    // message fields
    pub path: ::protobuf::SingularPtrField<Path>,
    pub creation_time: u64,
    pub group: ::std::string::String,
    pub is_directory: bool,
    pub is_executable: bool,
    pub is_hidden: bool,
    pub is_other: bool,
    pub is_readable: bool,
    pub is_regular: bool,
    pub is_symbolic_link: bool,
    pub is_writable: bool,
    pub last_access_time: u64,
    pub last_modified_time: u64,
    pub owner: ::std::string::String,
    pub permissions: ::std::vec::Vec<PosixFilePermission>,
    pub size: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PathAttributes {
    fn default() -> &'a PathAttributes {
        <PathAttributes as ::protobuf::Message>::default_instance()
    }
}

impl PathAttributes {
    pub fn new() -> PathAttributes {
        ::std::default::Default::default()
    }

    // .xenon.Path path = 1;


    pub fn get_path(&self) -> &Path {
        self.path.as_ref().unwrap_or_else(|| <Path as ::protobuf::Message>::default_instance())
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: Path) {
        self.path = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut Path {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> Path {
        self.path.take().unwrap_or_else(|| Path::new())
    }

    // uint64 creation_time = 2;


    pub fn get_creation_time(&self) -> u64 {
        self.creation_time
    }
    pub fn clear_creation_time(&mut self) {
        self.creation_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_creation_time(&mut self, v: u64) {
        self.creation_time = v;
    }

    // string group = 3;


    pub fn get_group(&self) -> &str {
        &self.group
    }
    pub fn clear_group(&mut self) {
        self.group.clear();
    }

    // Param is passed by value, moved
    pub fn set_group(&mut self, v: ::std::string::String) {
        self.group = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_group(&mut self) -> &mut ::std::string::String {
        &mut self.group
    }

    // Take field
    pub fn take_group(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.group, ::std::string::String::new())
    }

    // bool is_directory = 4;


    pub fn get_is_directory(&self) -> bool {
        self.is_directory
    }
    pub fn clear_is_directory(&mut self) {
        self.is_directory = false;
    }

    // Param is passed by value, moved
    pub fn set_is_directory(&mut self, v: bool) {
        self.is_directory = v;
    }

    // bool is_executable = 5;


    pub fn get_is_executable(&self) -> bool {
        self.is_executable
    }
    pub fn clear_is_executable(&mut self) {
        self.is_executable = false;
    }

    // Param is passed by value, moved
    pub fn set_is_executable(&mut self, v: bool) {
        self.is_executable = v;
    }

    // bool is_hidden = 6;


    pub fn get_is_hidden(&self) -> bool {
        self.is_hidden
    }
    pub fn clear_is_hidden(&mut self) {
        self.is_hidden = false;
    }

    // Param is passed by value, moved
    pub fn set_is_hidden(&mut self, v: bool) {
        self.is_hidden = v;
    }

    // bool is_other = 7;


    pub fn get_is_other(&self) -> bool {
        self.is_other
    }
    pub fn clear_is_other(&mut self) {
        self.is_other = false;
    }

    // Param is passed by value, moved
    pub fn set_is_other(&mut self, v: bool) {
        self.is_other = v;
    }

    // bool is_readable = 8;


    pub fn get_is_readable(&self) -> bool {
        self.is_readable
    }
    pub fn clear_is_readable(&mut self) {
        self.is_readable = false;
    }

    // Param is passed by value, moved
    pub fn set_is_readable(&mut self, v: bool) {
        self.is_readable = v;
    }

    // bool is_regular = 9;


    pub fn get_is_regular(&self) -> bool {
        self.is_regular
    }
    pub fn clear_is_regular(&mut self) {
        self.is_regular = false;
    }

    // Param is passed by value, moved
    pub fn set_is_regular(&mut self, v: bool) {
        self.is_regular = v;
    }

    // bool is_symbolic_link = 10;


    pub fn get_is_symbolic_link(&self) -> bool {
        self.is_symbolic_link
    }
    pub fn clear_is_symbolic_link(&mut self) {
        self.is_symbolic_link = false;
    }

    // Param is passed by value, moved
    pub fn set_is_symbolic_link(&mut self, v: bool) {
        self.is_symbolic_link = v;
    }

    // bool is_writable = 11;


    pub fn get_is_writable(&self) -> bool {
        self.is_writable
    }
    pub fn clear_is_writable(&mut self) {
        self.is_writable = false;
    }

    // Param is passed by value, moved
    pub fn set_is_writable(&mut self, v: bool) {
        self.is_writable = v;
    }

    // uint64 last_access_time = 12;


    pub fn get_last_access_time(&self) -> u64 {
        self.last_access_time
    }
    pub fn clear_last_access_time(&mut self) {
        self.last_access_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_last_access_time(&mut self, v: u64) {
        self.last_access_time = v;
    }

    // uint64 last_modified_time = 13;


    pub fn get_last_modified_time(&self) -> u64 {
        self.last_modified_time
    }
    pub fn clear_last_modified_time(&mut self) {
        self.last_modified_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_last_modified_time(&mut self, v: u64) {
        self.last_modified_time = v;
    }

    // string owner = 14;


    pub fn get_owner(&self) -> &str {
        &self.owner
    }
    pub fn clear_owner(&mut self) {
        self.owner.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner(&mut self, v: ::std::string::String) {
        self.owner = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner(&mut self) -> &mut ::std::string::String {
        &mut self.owner
    }

    // Take field
    pub fn take_owner(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.owner, ::std::string::String::new())
    }

    // repeated .xenon.PosixFilePermission permissions = 15;


    pub fn get_permissions(&self) -> &[PosixFilePermission] {
        &self.permissions
    }
    pub fn clear_permissions(&mut self) {
        self.permissions.clear();
    }

    // Param is passed by value, moved
    pub fn set_permissions(&mut self, v: ::std::vec::Vec<PosixFilePermission>) {
        self.permissions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_permissions(&mut self) -> &mut ::std::vec::Vec<PosixFilePermission> {
        &mut self.permissions
    }

    // Take field
    pub fn take_permissions(&mut self) -> ::std::vec::Vec<PosixFilePermission> {
        ::std::mem::replace(&mut self.permissions, ::std::vec::Vec::new())
    }

    // uint64 size = 16;


    pub fn get_size(&self) -> u64 {
        self.size
    }
    pub fn clear_size(&mut self) {
        self.size = 0;
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: u64) {
        self.size = v;
    }
}

impl ::protobuf::Message for PathAttributes {
    fn is_initialized(&self) -> bool {
        for v in &self.path {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.path)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.creation_time = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.group)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_directory = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_executable = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_hidden = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_other = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_readable = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_regular = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_symbolic_link = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_writable = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.last_access_time = tmp;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.last_modified_time = tmp;
                },
                14 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.owner)?;
                },
                15 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.permissions, 15, &mut self.unknown_fields)?
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.size = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.path.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.creation_time != 0 {
            my_size += ::protobuf::rt::value_size(2, self.creation_time, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.group.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.group);
        }
        if self.is_directory != false {
            my_size += 2;
        }
        if self.is_executable != false {
            my_size += 2;
        }
        if self.is_hidden != false {
            my_size += 2;
        }
        if self.is_other != false {
            my_size += 2;
        }
        if self.is_readable != false {
            my_size += 2;
        }
        if self.is_regular != false {
            my_size += 2;
        }
        if self.is_symbolic_link != false {
            my_size += 2;
        }
        if self.is_writable != false {
            my_size += 2;
        }
        if self.last_access_time != 0 {
            my_size += ::protobuf::rt::value_size(12, self.last_access_time, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.last_modified_time != 0 {
            my_size += ::protobuf::rt::value_size(13, self.last_modified_time, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.owner.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.owner);
        }
        for value in &self.permissions {
            my_size += ::protobuf::rt::enum_size(15, *value);
        };
        if self.size != 0 {
            my_size += ::protobuf::rt::value_size(16, self.size, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.path.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.creation_time != 0 {
            os.write_uint64(2, self.creation_time)?;
        }
        if !self.group.is_empty() {
            os.write_string(3, &self.group)?;
        }
        if self.is_directory != false {
            os.write_bool(4, self.is_directory)?;
        }
        if self.is_executable != false {
            os.write_bool(5, self.is_executable)?;
        }
        if self.is_hidden != false {
            os.write_bool(6, self.is_hidden)?;
        }
        if self.is_other != false {
            os.write_bool(7, self.is_other)?;
        }
        if self.is_readable != false {
            os.write_bool(8, self.is_readable)?;
        }
        if self.is_regular != false {
            os.write_bool(9, self.is_regular)?;
        }
        if self.is_symbolic_link != false {
            os.write_bool(10, self.is_symbolic_link)?;
        }
        if self.is_writable != false {
            os.write_bool(11, self.is_writable)?;
        }
        if self.last_access_time != 0 {
            os.write_uint64(12, self.last_access_time)?;
        }
        if self.last_modified_time != 0 {
            os.write_uint64(13, self.last_modified_time)?;
        }
        if !self.owner.is_empty() {
            os.write_string(14, &self.owner)?;
        }
        for v in &self.permissions {
            os.write_enum(15, ::protobuf::ProtobufEnum::value(v))?;
        };
        if self.size != 0 {
            os.write_uint64(16, self.size)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PathAttributes {
        PathAttributes::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Path>>(
                "path",
                |m: &PathAttributes| { &m.path },
                |m: &mut PathAttributes| { &mut m.path },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "creation_time",
                |m: &PathAttributes| { &m.creation_time },
                |m: &mut PathAttributes| { &mut m.creation_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "group",
                |m: &PathAttributes| { &m.group },
                |m: &mut PathAttributes| { &mut m.group },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_directory",
                |m: &PathAttributes| { &m.is_directory },
                |m: &mut PathAttributes| { &mut m.is_directory },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_executable",
                |m: &PathAttributes| { &m.is_executable },
                |m: &mut PathAttributes| { &mut m.is_executable },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_hidden",
                |m: &PathAttributes| { &m.is_hidden },
                |m: &mut PathAttributes| { &mut m.is_hidden },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_other",
                |m: &PathAttributes| { &m.is_other },
                |m: &mut PathAttributes| { &mut m.is_other },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_readable",
                |m: &PathAttributes| { &m.is_readable },
                |m: &mut PathAttributes| { &mut m.is_readable },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_regular",
                |m: &PathAttributes| { &m.is_regular },
                |m: &mut PathAttributes| { &mut m.is_regular },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_symbolic_link",
                |m: &PathAttributes| { &m.is_symbolic_link },
                |m: &mut PathAttributes| { &mut m.is_symbolic_link },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_writable",
                |m: &PathAttributes| { &m.is_writable },
                |m: &mut PathAttributes| { &mut m.is_writable },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "last_access_time",
                |m: &PathAttributes| { &m.last_access_time },
                |m: &mut PathAttributes| { &mut m.last_access_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "last_modified_time",
                |m: &PathAttributes| { &m.last_modified_time },
                |m: &mut PathAttributes| { &mut m.last_modified_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "owner",
                |m: &PathAttributes| { &m.owner },
                |m: &mut PathAttributes| { &mut m.owner },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PosixFilePermission>>(
                "permissions",
                |m: &PathAttributes| { &m.permissions },
                |m: &mut PathAttributes| { &mut m.permissions },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "size",
                |m: &PathAttributes| { &m.size },
                |m: &mut PathAttributes| { &mut m.size },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PathAttributes>(
                "PathAttributes",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PathAttributes {
        static instance: ::protobuf::rt::LazyV2<PathAttributes> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PathAttributes::new)
    }
}

impl ::protobuf::Clear for PathAttributes {
    fn clear(&mut self) {
        self.path.clear();
        self.creation_time = 0;
        self.group.clear();
        self.is_directory = false;
        self.is_executable = false;
        self.is_hidden = false;
        self.is_other = false;
        self.is_readable = false;
        self.is_regular = false;
        self.is_symbolic_link = false;
        self.is_writable = false;
        self.last_access_time = 0;
        self.last_modified_time = 0;
        self.owner.clear();
        self.permissions.clear();
        self.size = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PathAttributes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PathAttributes {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetPosixFilePermissionsRequest {
    // message fields
    pub filesystem: ::protobuf::SingularPtrField<FileSystem>,
    pub path: ::protobuf::SingularPtrField<Path>,
    pub permissions: ::std::vec::Vec<PosixFilePermission>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetPosixFilePermissionsRequest {
    fn default() -> &'a SetPosixFilePermissionsRequest {
        <SetPosixFilePermissionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl SetPosixFilePermissionsRequest {
    pub fn new() -> SetPosixFilePermissionsRequest {
        ::std::default::Default::default()
    }

    // .xenon.FileSystem filesystem = 1;


    pub fn get_filesystem(&self) -> &FileSystem {
        self.filesystem.as_ref().unwrap_or_else(|| <FileSystem as ::protobuf::Message>::default_instance())
    }
    pub fn clear_filesystem(&mut self) {
        self.filesystem.clear();
    }

    pub fn has_filesystem(&self) -> bool {
        self.filesystem.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filesystem(&mut self, v: FileSystem) {
        self.filesystem = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filesystem(&mut self) -> &mut FileSystem {
        if self.filesystem.is_none() {
            self.filesystem.set_default();
        }
        self.filesystem.as_mut().unwrap()
    }

    // Take field
    pub fn take_filesystem(&mut self) -> FileSystem {
        self.filesystem.take().unwrap_or_else(|| FileSystem::new())
    }

    // .xenon.Path path = 2;


    pub fn get_path(&self) -> &Path {
        self.path.as_ref().unwrap_or_else(|| <Path as ::protobuf::Message>::default_instance())
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: Path) {
        self.path = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut Path {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> Path {
        self.path.take().unwrap_or_else(|| Path::new())
    }

    // repeated .xenon.PosixFilePermission permissions = 3;


    pub fn get_permissions(&self) -> &[PosixFilePermission] {
        &self.permissions
    }
    pub fn clear_permissions(&mut self) {
        self.permissions.clear();
    }

    // Param is passed by value, moved
    pub fn set_permissions(&mut self, v: ::std::vec::Vec<PosixFilePermission>) {
        self.permissions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_permissions(&mut self) -> &mut ::std::vec::Vec<PosixFilePermission> {
        &mut self.permissions
    }

    // Take field
    pub fn take_permissions(&mut self) -> ::std::vec::Vec<PosixFilePermission> {
        ::std::mem::replace(&mut self.permissions, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for SetPosixFilePermissionsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.filesystem {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.path {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.filesystem)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.path)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.permissions, 3, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.filesystem.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.path.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.permissions {
            my_size += ::protobuf::rt::enum_size(3, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.filesystem.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.path.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.permissions {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(v))?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetPosixFilePermissionsRequest {
        SetPosixFilePermissionsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FileSystem>>(
                "filesystem",
                |m: &SetPosixFilePermissionsRequest| { &m.filesystem },
                |m: &mut SetPosixFilePermissionsRequest| { &mut m.filesystem },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Path>>(
                "path",
                |m: &SetPosixFilePermissionsRequest| { &m.path },
                |m: &mut SetPosixFilePermissionsRequest| { &mut m.path },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PosixFilePermission>>(
                "permissions",
                |m: &SetPosixFilePermissionsRequest| { &m.permissions },
                |m: &mut SetPosixFilePermissionsRequest| { &mut m.permissions },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SetPosixFilePermissionsRequest>(
                "SetPosixFilePermissionsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SetPosixFilePermissionsRequest {
        static instance: ::protobuf::rt::LazyV2<SetPosixFilePermissionsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SetPosixFilePermissionsRequest::new)
    }
}

impl ::protobuf::Clear for SetPosixFilePermissionsRequest {
    fn clear(&mut self) {
        self.filesystem.clear();
        self.path.clear();
        self.permissions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetPosixFilePermissionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetPosixFilePermissionsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReadFromFileResponse {
    // message fields
    pub buffer: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReadFromFileResponse {
    fn default() -> &'a ReadFromFileResponse {
        <ReadFromFileResponse as ::protobuf::Message>::default_instance()
    }
}

impl ReadFromFileResponse {
    pub fn new() -> ReadFromFileResponse {
        ::std::default::Default::default()
    }

    // bytes buffer = 1;


    pub fn get_buffer(&self) -> &[u8] {
        &self.buffer
    }
    pub fn clear_buffer(&mut self) {
        self.buffer.clear();
    }

    // Param is passed by value, moved
    pub fn set_buffer(&mut self, v: ::std::vec::Vec<u8>) {
        self.buffer = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_buffer(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.buffer
    }

    // Take field
    pub fn take_buffer(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.buffer, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for ReadFromFileResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.buffer)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.buffer.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.buffer);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.buffer.is_empty() {
            os.write_bytes(1, &self.buffer)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReadFromFileResponse {
        ReadFromFileResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "buffer",
                |m: &ReadFromFileResponse| { &m.buffer },
                |m: &mut ReadFromFileResponse| { &mut m.buffer },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReadFromFileResponse>(
                "ReadFromFileResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ReadFromFileResponse {
        static instance: ::protobuf::rt::LazyV2<ReadFromFileResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ReadFromFileResponse::new)
    }
}

impl ::protobuf::Clear for ReadFromFileResponse {
    fn clear(&mut self) {
        self.buffer.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReadFromFileResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReadFromFileResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WriteToFileRequest {
    // message fields
    pub filesystem: ::protobuf::SingularPtrField<FileSystem>,
    pub path: ::protobuf::SingularPtrField<Path>,
    pub buffer: ::std::vec::Vec<u8>,
    pub size: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WriteToFileRequest {
    fn default() -> &'a WriteToFileRequest {
        <WriteToFileRequest as ::protobuf::Message>::default_instance()
    }
}

impl WriteToFileRequest {
    pub fn new() -> WriteToFileRequest {
        ::std::default::Default::default()
    }

    // .xenon.FileSystem filesystem = 1;


    pub fn get_filesystem(&self) -> &FileSystem {
        self.filesystem.as_ref().unwrap_or_else(|| <FileSystem as ::protobuf::Message>::default_instance())
    }
    pub fn clear_filesystem(&mut self) {
        self.filesystem.clear();
    }

    pub fn has_filesystem(&self) -> bool {
        self.filesystem.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filesystem(&mut self, v: FileSystem) {
        self.filesystem = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filesystem(&mut self) -> &mut FileSystem {
        if self.filesystem.is_none() {
            self.filesystem.set_default();
        }
        self.filesystem.as_mut().unwrap()
    }

    // Take field
    pub fn take_filesystem(&mut self) -> FileSystem {
        self.filesystem.take().unwrap_or_else(|| FileSystem::new())
    }

    // .xenon.Path path = 2;


    pub fn get_path(&self) -> &Path {
        self.path.as_ref().unwrap_or_else(|| <Path as ::protobuf::Message>::default_instance())
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: Path) {
        self.path = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut Path {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> Path {
        self.path.take().unwrap_or_else(|| Path::new())
    }

    // bytes buffer = 3;


    pub fn get_buffer(&self) -> &[u8] {
        &self.buffer
    }
    pub fn clear_buffer(&mut self) {
        self.buffer.clear();
    }

    // Param is passed by value, moved
    pub fn set_buffer(&mut self, v: ::std::vec::Vec<u8>) {
        self.buffer = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_buffer(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.buffer
    }

    // Take field
    pub fn take_buffer(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.buffer, ::std::vec::Vec::new())
    }

    // uint64 size = 4;


    pub fn get_size(&self) -> u64 {
        self.size
    }
    pub fn clear_size(&mut self) {
        self.size = 0;
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: u64) {
        self.size = v;
    }
}

impl ::protobuf::Message for WriteToFileRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.filesystem {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.path {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.filesystem)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.path)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.buffer)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.size = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.filesystem.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.path.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.buffer.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.buffer);
        }
        if self.size != 0 {
            my_size += ::protobuf::rt::value_size(4, self.size, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.filesystem.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.path.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.buffer.is_empty() {
            os.write_bytes(3, &self.buffer)?;
        }
        if self.size != 0 {
            os.write_uint64(4, self.size)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WriteToFileRequest {
        WriteToFileRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FileSystem>>(
                "filesystem",
                |m: &WriteToFileRequest| { &m.filesystem },
                |m: &mut WriteToFileRequest| { &mut m.filesystem },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Path>>(
                "path",
                |m: &WriteToFileRequest| { &m.path },
                |m: &mut WriteToFileRequest| { &mut m.path },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "buffer",
                |m: &WriteToFileRequest| { &m.buffer },
                |m: &mut WriteToFileRequest| { &mut m.buffer },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "size",
                |m: &WriteToFileRequest| { &m.size },
                |m: &mut WriteToFileRequest| { &mut m.size },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WriteToFileRequest>(
                "WriteToFileRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static WriteToFileRequest {
        static instance: ::protobuf::rt::LazyV2<WriteToFileRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WriteToFileRequest::new)
    }
}

impl ::protobuf::Clear for WriteToFileRequest {
    fn clear(&mut self) {
        self.filesystem.clear();
        self.path.clear();
        self.buffer.clear();
        self.size = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WriteToFileRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WriteToFileRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AppendToFileRequest {
    // message fields
    pub filesystem: ::protobuf::SingularPtrField<FileSystem>,
    pub path: ::protobuf::SingularPtrField<Path>,
    pub buffer: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AppendToFileRequest {
    fn default() -> &'a AppendToFileRequest {
        <AppendToFileRequest as ::protobuf::Message>::default_instance()
    }
}

impl AppendToFileRequest {
    pub fn new() -> AppendToFileRequest {
        ::std::default::Default::default()
    }

    // .xenon.FileSystem filesystem = 1;


    pub fn get_filesystem(&self) -> &FileSystem {
        self.filesystem.as_ref().unwrap_or_else(|| <FileSystem as ::protobuf::Message>::default_instance())
    }
    pub fn clear_filesystem(&mut self) {
        self.filesystem.clear();
    }

    pub fn has_filesystem(&self) -> bool {
        self.filesystem.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filesystem(&mut self, v: FileSystem) {
        self.filesystem = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filesystem(&mut self) -> &mut FileSystem {
        if self.filesystem.is_none() {
            self.filesystem.set_default();
        }
        self.filesystem.as_mut().unwrap()
    }

    // Take field
    pub fn take_filesystem(&mut self) -> FileSystem {
        self.filesystem.take().unwrap_or_else(|| FileSystem::new())
    }

    // .xenon.Path path = 2;


    pub fn get_path(&self) -> &Path {
        self.path.as_ref().unwrap_or_else(|| <Path as ::protobuf::Message>::default_instance())
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: Path) {
        self.path = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut Path {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> Path {
        self.path.take().unwrap_or_else(|| Path::new())
    }

    // bytes buffer = 3;


    pub fn get_buffer(&self) -> &[u8] {
        &self.buffer
    }
    pub fn clear_buffer(&mut self) {
        self.buffer.clear();
    }

    // Param is passed by value, moved
    pub fn set_buffer(&mut self, v: ::std::vec::Vec<u8>) {
        self.buffer = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_buffer(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.buffer
    }

    // Take field
    pub fn take_buffer(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.buffer, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for AppendToFileRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.filesystem {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.path {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.filesystem)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.path)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.buffer)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.filesystem.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.path.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.buffer.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.buffer);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.filesystem.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.path.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.buffer.is_empty() {
            os.write_bytes(3, &self.buffer)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AppendToFileRequest {
        AppendToFileRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FileSystem>>(
                "filesystem",
                |m: &AppendToFileRequest| { &m.filesystem },
                |m: &mut AppendToFileRequest| { &mut m.filesystem },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Path>>(
                "path",
                |m: &AppendToFileRequest| { &m.path },
                |m: &mut AppendToFileRequest| { &mut m.path },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "buffer",
                |m: &AppendToFileRequest| { &m.buffer },
                |m: &mut AppendToFileRequest| { &mut m.buffer },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AppendToFileRequest>(
                "AppendToFileRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AppendToFileRequest {
        static instance: ::protobuf::rt::LazyV2<AppendToFileRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AppendToFileRequest::new)
    }
}

impl ::protobuf::Clear for AppendToFileRequest {
    fn clear(&mut self) {
        self.filesystem.clear();
        self.path.clear();
        self.buffer.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AppendToFileRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AppendToFileRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListRequest {
    // message fields
    pub filesystem: ::protobuf::SingularPtrField<FileSystem>,
    pub dir: ::protobuf::SingularPtrField<Path>,
    pub recursive: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListRequest {
    fn default() -> &'a ListRequest {
        <ListRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListRequest {
    pub fn new() -> ListRequest {
        ::std::default::Default::default()
    }

    // .xenon.FileSystem filesystem = 1;


    pub fn get_filesystem(&self) -> &FileSystem {
        self.filesystem.as_ref().unwrap_or_else(|| <FileSystem as ::protobuf::Message>::default_instance())
    }
    pub fn clear_filesystem(&mut self) {
        self.filesystem.clear();
    }

    pub fn has_filesystem(&self) -> bool {
        self.filesystem.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filesystem(&mut self, v: FileSystem) {
        self.filesystem = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filesystem(&mut self) -> &mut FileSystem {
        if self.filesystem.is_none() {
            self.filesystem.set_default();
        }
        self.filesystem.as_mut().unwrap()
    }

    // Take field
    pub fn take_filesystem(&mut self) -> FileSystem {
        self.filesystem.take().unwrap_or_else(|| FileSystem::new())
    }

    // .xenon.Path dir = 2;


    pub fn get_dir(&self) -> &Path {
        self.dir.as_ref().unwrap_or_else(|| <Path as ::protobuf::Message>::default_instance())
    }
    pub fn clear_dir(&mut self) {
        self.dir.clear();
    }

    pub fn has_dir(&self) -> bool {
        self.dir.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dir(&mut self, v: Path) {
        self.dir = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dir(&mut self) -> &mut Path {
        if self.dir.is_none() {
            self.dir.set_default();
        }
        self.dir.as_mut().unwrap()
    }

    // Take field
    pub fn take_dir(&mut self) -> Path {
        self.dir.take().unwrap_or_else(|| Path::new())
    }

    // bool recursive = 3;


    pub fn get_recursive(&self) -> bool {
        self.recursive
    }
    pub fn clear_recursive(&mut self) {
        self.recursive = false;
    }

    // Param is passed by value, moved
    pub fn set_recursive(&mut self, v: bool) {
        self.recursive = v;
    }
}

impl ::protobuf::Message for ListRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.filesystem {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dir {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.filesystem)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dir)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.recursive = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.filesystem.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.dir.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.recursive != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.filesystem.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.dir.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.recursive != false {
            os.write_bool(3, self.recursive)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListRequest {
        ListRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FileSystem>>(
                "filesystem",
                |m: &ListRequest| { &m.filesystem },
                |m: &mut ListRequest| { &mut m.filesystem },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Path>>(
                "dir",
                |m: &ListRequest| { &m.dir },
                |m: &mut ListRequest| { &mut m.dir },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "recursive",
                |m: &ListRequest| { &m.recursive },
                |m: &mut ListRequest| { &mut m.recursive },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListRequest>(
                "ListRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListRequest {
        static instance: ::protobuf::rt::LazyV2<ListRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListRequest::new)
    }
}

impl ::protobuf::Clear for ListRequest {
    fn clear(&mut self) {
        self.filesystem.clear();
        self.dir.clear();
        self.recursive = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetPathSeparatorResponse {
    // message fields
    pub separator: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetPathSeparatorResponse {
    fn default() -> &'a GetPathSeparatorResponse {
        <GetPathSeparatorResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetPathSeparatorResponse {
    pub fn new() -> GetPathSeparatorResponse {
        ::std::default::Default::default()
    }

    // string separator = 1;


    pub fn get_separator(&self) -> &str {
        &self.separator
    }
    pub fn clear_separator(&mut self) {
        self.separator.clear();
    }

    // Param is passed by value, moved
    pub fn set_separator(&mut self, v: ::std::string::String) {
        self.separator = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_separator(&mut self) -> &mut ::std::string::String {
        &mut self.separator
    }

    // Take field
    pub fn take_separator(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.separator, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetPathSeparatorResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.separator)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.separator.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.separator);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.separator.is_empty() {
            os.write_string(1, &self.separator)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetPathSeparatorResponse {
        GetPathSeparatorResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "separator",
                |m: &GetPathSeparatorResponse| { &m.separator },
                |m: &mut GetPathSeparatorResponse| { &mut m.separator },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetPathSeparatorResponse>(
                "GetPathSeparatorResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetPathSeparatorResponse {
        static instance: ::protobuf::rt::LazyV2<GetPathSeparatorResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetPathSeparatorResponse::new)
    }
}

impl ::protobuf::Clear for GetPathSeparatorResponse {
    fn clear(&mut self) {
        self.separator.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetPathSeparatorResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetPathSeparatorResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateSchedulerRequest {
    // message fields
    pub adaptor: ::std::string::String,
    pub location: ::std::string::String,
    pub properties: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // message oneof groups
    pub credential: ::std::option::Option<CreateSchedulerRequest_oneof_credential>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateSchedulerRequest {
    fn default() -> &'a CreateSchedulerRequest {
        <CreateSchedulerRequest as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum CreateSchedulerRequest_oneof_credential {
    certificate_credential(CertificateCredential),
    password_credential(PasswordCredential),
    default_credential(DefaultCredential),
    credential_map(CredentialMap),
    keytab_credential(KeytabCredential),
}

impl CreateSchedulerRequest {
    pub fn new() -> CreateSchedulerRequest {
        ::std::default::Default::default()
    }

    // string adaptor = 1;


    pub fn get_adaptor(&self) -> &str {
        &self.adaptor
    }
    pub fn clear_adaptor(&mut self) {
        self.adaptor.clear();
    }

    // Param is passed by value, moved
    pub fn set_adaptor(&mut self, v: ::std::string::String) {
        self.adaptor = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_adaptor(&mut self) -> &mut ::std::string::String {
        &mut self.adaptor
    }

    // Take field
    pub fn take_adaptor(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.adaptor, ::std::string::String::new())
    }

    // string location = 2;


    pub fn get_location(&self) -> &str {
        &self.location
    }
    pub fn clear_location(&mut self) {
        self.location.clear();
    }

    // Param is passed by value, moved
    pub fn set_location(&mut self, v: ::std::string::String) {
        self.location = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_location(&mut self) -> &mut ::std::string::String {
        &mut self.location
    }

    // Take field
    pub fn take_location(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.location, ::std::string::String::new())
    }

    // repeated .xenon.CreateSchedulerRequest.PropertiesEntry properties = 3;


    pub fn get_properties(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.properties
    }
    pub fn clear_properties(&mut self) {
        self.properties.clear();
    }

    // Param is passed by value, moved
    pub fn set_properties(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.properties = v;
    }

    // Mutable pointer to the field.
    pub fn mut_properties(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.properties
    }

    // Take field
    pub fn take_properties(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.properties, ::std::collections::HashMap::new())
    }

    // .xenon.CertificateCredential certificate_credential = 4;


    pub fn get_certificate_credential(&self) -> &CertificateCredential {
        match self.credential {
            ::std::option::Option::Some(CreateSchedulerRequest_oneof_credential::certificate_credential(ref v)) => v,
            _ => <CertificateCredential as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_certificate_credential(&mut self) {
        self.credential = ::std::option::Option::None;
    }

    pub fn has_certificate_credential(&self) -> bool {
        match self.credential {
            ::std::option::Option::Some(CreateSchedulerRequest_oneof_credential::certificate_credential(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_certificate_credential(&mut self, v: CertificateCredential) {
        self.credential = ::std::option::Option::Some(CreateSchedulerRequest_oneof_credential::certificate_credential(v))
    }

    // Mutable pointer to the field.
    pub fn mut_certificate_credential(&mut self) -> &mut CertificateCredential {
        if let ::std::option::Option::Some(CreateSchedulerRequest_oneof_credential::certificate_credential(_)) = self.credential {
        } else {
            self.credential = ::std::option::Option::Some(CreateSchedulerRequest_oneof_credential::certificate_credential(CertificateCredential::new()));
        }
        match self.credential {
            ::std::option::Option::Some(CreateSchedulerRequest_oneof_credential::certificate_credential(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_certificate_credential(&mut self) -> CertificateCredential {
        if self.has_certificate_credential() {
            match self.credential.take() {
                ::std::option::Option::Some(CreateSchedulerRequest_oneof_credential::certificate_credential(v)) => v,
                _ => panic!(),
            }
        } else {
            CertificateCredential::new()
        }
    }

    // .xenon.PasswordCredential password_credential = 5;


    pub fn get_password_credential(&self) -> &PasswordCredential {
        match self.credential {
            ::std::option::Option::Some(CreateSchedulerRequest_oneof_credential::password_credential(ref v)) => v,
            _ => <PasswordCredential as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_password_credential(&mut self) {
        self.credential = ::std::option::Option::None;
    }

    pub fn has_password_credential(&self) -> bool {
        match self.credential {
            ::std::option::Option::Some(CreateSchedulerRequest_oneof_credential::password_credential(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_password_credential(&mut self, v: PasswordCredential) {
        self.credential = ::std::option::Option::Some(CreateSchedulerRequest_oneof_credential::password_credential(v))
    }

    // Mutable pointer to the field.
    pub fn mut_password_credential(&mut self) -> &mut PasswordCredential {
        if let ::std::option::Option::Some(CreateSchedulerRequest_oneof_credential::password_credential(_)) = self.credential {
        } else {
            self.credential = ::std::option::Option::Some(CreateSchedulerRequest_oneof_credential::password_credential(PasswordCredential::new()));
        }
        match self.credential {
            ::std::option::Option::Some(CreateSchedulerRequest_oneof_credential::password_credential(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_password_credential(&mut self) -> PasswordCredential {
        if self.has_password_credential() {
            match self.credential.take() {
                ::std::option::Option::Some(CreateSchedulerRequest_oneof_credential::password_credential(v)) => v,
                _ => panic!(),
            }
        } else {
            PasswordCredential::new()
        }
    }

    // .xenon.DefaultCredential default_credential = 6;


    pub fn get_default_credential(&self) -> &DefaultCredential {
        match self.credential {
            ::std::option::Option::Some(CreateSchedulerRequest_oneof_credential::default_credential(ref v)) => v,
            _ => <DefaultCredential as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_default_credential(&mut self) {
        self.credential = ::std::option::Option::None;
    }

    pub fn has_default_credential(&self) -> bool {
        match self.credential {
            ::std::option::Option::Some(CreateSchedulerRequest_oneof_credential::default_credential(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_default_credential(&mut self, v: DefaultCredential) {
        self.credential = ::std::option::Option::Some(CreateSchedulerRequest_oneof_credential::default_credential(v))
    }

    // Mutable pointer to the field.
    pub fn mut_default_credential(&mut self) -> &mut DefaultCredential {
        if let ::std::option::Option::Some(CreateSchedulerRequest_oneof_credential::default_credential(_)) = self.credential {
        } else {
            self.credential = ::std::option::Option::Some(CreateSchedulerRequest_oneof_credential::default_credential(DefaultCredential::new()));
        }
        match self.credential {
            ::std::option::Option::Some(CreateSchedulerRequest_oneof_credential::default_credential(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_default_credential(&mut self) -> DefaultCredential {
        if self.has_default_credential() {
            match self.credential.take() {
                ::std::option::Option::Some(CreateSchedulerRequest_oneof_credential::default_credential(v)) => v,
                _ => panic!(),
            }
        } else {
            DefaultCredential::new()
        }
    }

    // .xenon.CredentialMap credential_map = 7;


    pub fn get_credential_map(&self) -> &CredentialMap {
        match self.credential {
            ::std::option::Option::Some(CreateSchedulerRequest_oneof_credential::credential_map(ref v)) => v,
            _ => <CredentialMap as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_credential_map(&mut self) {
        self.credential = ::std::option::Option::None;
    }

    pub fn has_credential_map(&self) -> bool {
        match self.credential {
            ::std::option::Option::Some(CreateSchedulerRequest_oneof_credential::credential_map(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_credential_map(&mut self, v: CredentialMap) {
        self.credential = ::std::option::Option::Some(CreateSchedulerRequest_oneof_credential::credential_map(v))
    }

    // Mutable pointer to the field.
    pub fn mut_credential_map(&mut self) -> &mut CredentialMap {
        if let ::std::option::Option::Some(CreateSchedulerRequest_oneof_credential::credential_map(_)) = self.credential {
        } else {
            self.credential = ::std::option::Option::Some(CreateSchedulerRequest_oneof_credential::credential_map(CredentialMap::new()));
        }
        match self.credential {
            ::std::option::Option::Some(CreateSchedulerRequest_oneof_credential::credential_map(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_credential_map(&mut self) -> CredentialMap {
        if self.has_credential_map() {
            match self.credential.take() {
                ::std::option::Option::Some(CreateSchedulerRequest_oneof_credential::credential_map(v)) => v,
                _ => panic!(),
            }
        } else {
            CredentialMap::new()
        }
    }

    // .xenon.KeytabCredential keytab_credential = 8;


    pub fn get_keytab_credential(&self) -> &KeytabCredential {
        match self.credential {
            ::std::option::Option::Some(CreateSchedulerRequest_oneof_credential::keytab_credential(ref v)) => v,
            _ => <KeytabCredential as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_keytab_credential(&mut self) {
        self.credential = ::std::option::Option::None;
    }

    pub fn has_keytab_credential(&self) -> bool {
        match self.credential {
            ::std::option::Option::Some(CreateSchedulerRequest_oneof_credential::keytab_credential(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_keytab_credential(&mut self, v: KeytabCredential) {
        self.credential = ::std::option::Option::Some(CreateSchedulerRequest_oneof_credential::keytab_credential(v))
    }

    // Mutable pointer to the field.
    pub fn mut_keytab_credential(&mut self) -> &mut KeytabCredential {
        if let ::std::option::Option::Some(CreateSchedulerRequest_oneof_credential::keytab_credential(_)) = self.credential {
        } else {
            self.credential = ::std::option::Option::Some(CreateSchedulerRequest_oneof_credential::keytab_credential(KeytabCredential::new()));
        }
        match self.credential {
            ::std::option::Option::Some(CreateSchedulerRequest_oneof_credential::keytab_credential(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_keytab_credential(&mut self) -> KeytabCredential {
        if self.has_keytab_credential() {
            match self.credential.take() {
                ::std::option::Option::Some(CreateSchedulerRequest_oneof_credential::keytab_credential(v)) => v,
                _ => panic!(),
            }
        } else {
            KeytabCredential::new()
        }
    }
}

impl ::protobuf::Message for CreateSchedulerRequest {
    fn is_initialized(&self) -> bool {
        if let Some(CreateSchedulerRequest_oneof_credential::certificate_credential(ref v)) = self.credential {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(CreateSchedulerRequest_oneof_credential::password_credential(ref v)) = self.credential {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(CreateSchedulerRequest_oneof_credential::default_credential(ref v)) = self.credential {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(CreateSchedulerRequest_oneof_credential::credential_map(ref v)) = self.credential {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(CreateSchedulerRequest_oneof_credential::keytab_credential(ref v)) = self.credential {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.adaptor)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.location)?;
                },
                3 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.properties)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.credential = ::std::option::Option::Some(CreateSchedulerRequest_oneof_credential::certificate_credential(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.credential = ::std::option::Option::Some(CreateSchedulerRequest_oneof_credential::password_credential(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.credential = ::std::option::Option::Some(CreateSchedulerRequest_oneof_credential::default_credential(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.credential = ::std::option::Option::Some(CreateSchedulerRequest_oneof_credential::credential_map(is.read_message()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.credential = ::std::option::Option::Some(CreateSchedulerRequest_oneof_credential::keytab_credential(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.adaptor.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.adaptor);
        }
        if !self.location.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.location);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(3, &self.properties);
        if let ::std::option::Option::Some(ref v) = self.credential {
            match v {
                &CreateSchedulerRequest_oneof_credential::certificate_credential(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &CreateSchedulerRequest_oneof_credential::password_credential(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &CreateSchedulerRequest_oneof_credential::default_credential(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &CreateSchedulerRequest_oneof_credential::credential_map(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &CreateSchedulerRequest_oneof_credential::keytab_credential(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.adaptor.is_empty() {
            os.write_string(1, &self.adaptor)?;
        }
        if !self.location.is_empty() {
            os.write_string(2, &self.location)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(3, &self.properties, os)?;
        if let ::std::option::Option::Some(ref v) = self.credential {
            match v {
                &CreateSchedulerRequest_oneof_credential::certificate_credential(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &CreateSchedulerRequest_oneof_credential::password_credential(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &CreateSchedulerRequest_oneof_credential::default_credential(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &CreateSchedulerRequest_oneof_credential::credential_map(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &CreateSchedulerRequest_oneof_credential::keytab_credential(ref v) => {
                    os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateSchedulerRequest {
        CreateSchedulerRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "adaptor",
                |m: &CreateSchedulerRequest| { &m.adaptor },
                |m: &mut CreateSchedulerRequest| { &mut m.adaptor },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "location",
                |m: &CreateSchedulerRequest| { &m.location },
                |m: &mut CreateSchedulerRequest| { &mut m.location },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "properties",
                |m: &CreateSchedulerRequest| { &m.properties },
                |m: &mut CreateSchedulerRequest| { &mut m.properties },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, CertificateCredential>(
                "certificate_credential",
                CreateSchedulerRequest::has_certificate_credential,
                CreateSchedulerRequest::get_certificate_credential,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, PasswordCredential>(
                "password_credential",
                CreateSchedulerRequest::has_password_credential,
                CreateSchedulerRequest::get_password_credential,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DefaultCredential>(
                "default_credential",
                CreateSchedulerRequest::has_default_credential,
                CreateSchedulerRequest::get_default_credential,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, CredentialMap>(
                "credential_map",
                CreateSchedulerRequest::has_credential_map,
                CreateSchedulerRequest::get_credential_map,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, KeytabCredential>(
                "keytab_credential",
                CreateSchedulerRequest::has_keytab_credential,
                CreateSchedulerRequest::get_keytab_credential,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateSchedulerRequest>(
                "CreateSchedulerRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateSchedulerRequest {
        static instance: ::protobuf::rt::LazyV2<CreateSchedulerRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateSchedulerRequest::new)
    }
}

impl ::protobuf::Clear for CreateSchedulerRequest {
    fn clear(&mut self) {
        self.adaptor.clear();
        self.location.clear();
        self.properties.clear();
        self.credential = ::std::option::Option::None;
        self.credential = ::std::option::Option::None;
        self.credential = ::std::option::Option::None;
        self.credential = ::std::option::Option::None;
        self.credential = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateSchedulerRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateSchedulerRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Scheduler {
    // message fields
    pub id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Scheduler {
    fn default() -> &'a Scheduler {
        <Scheduler as ::protobuf::Message>::default_instance()
    }
}

impl Scheduler {
    pub fn new() -> Scheduler {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Scheduler {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Scheduler {
        Scheduler::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &Scheduler| { &m.id },
                |m: &mut Scheduler| { &mut m.id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Scheduler>(
                "Scheduler",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Scheduler {
        static instance: ::protobuf::rt::LazyV2<Scheduler> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Scheduler::new)
    }
}

impl ::protobuf::Clear for Scheduler {
    fn clear(&mut self) {
        self.id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Scheduler {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Scheduler {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Schedulers {
    // message fields
    pub schedulers: ::protobuf::RepeatedField<Scheduler>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Schedulers {
    fn default() -> &'a Schedulers {
        <Schedulers as ::protobuf::Message>::default_instance()
    }
}

impl Schedulers {
    pub fn new() -> Schedulers {
        ::std::default::Default::default()
    }

    // repeated .xenon.Scheduler schedulers = 1;


    pub fn get_schedulers(&self) -> &[Scheduler] {
        &self.schedulers
    }
    pub fn clear_schedulers(&mut self) {
        self.schedulers.clear();
    }

    // Param is passed by value, moved
    pub fn set_schedulers(&mut self, v: ::protobuf::RepeatedField<Scheduler>) {
        self.schedulers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_schedulers(&mut self) -> &mut ::protobuf::RepeatedField<Scheduler> {
        &mut self.schedulers
    }

    // Take field
    pub fn take_schedulers(&mut self) -> ::protobuf::RepeatedField<Scheduler> {
        ::std::mem::replace(&mut self.schedulers, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Schedulers {
    fn is_initialized(&self) -> bool {
        for v in &self.schedulers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.schedulers)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.schedulers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.schedulers {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Schedulers {
        Schedulers::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Scheduler>>(
                "schedulers",
                |m: &Schedulers| { &m.schedulers },
                |m: &mut Schedulers| { &mut m.schedulers },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Schedulers>(
                "Schedulers",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Schedulers {
        static instance: ::protobuf::rt::LazyV2<Schedulers> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Schedulers::new)
    }
}

impl ::protobuf::Clear for Schedulers {
    fn clear(&mut self) {
        self.schedulers.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Schedulers {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Schedulers {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct JobDescription {
    // message fields
    pub executable: ::std::string::String,
    pub arguments: ::protobuf::RepeatedField<::std::string::String>,
    pub working_directory: ::std::string::String,
    pub environment: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub queue_name: ::std::string::String,
    pub max_runtime: u32,
    pub stderr: ::std::string::String,
    pub stdin: ::std::string::String,
    pub stdout: ::std::string::String,
    pub name: ::std::string::String,
    pub max_memory: u32,
    pub scheduler_arguments: ::protobuf::RepeatedField<::std::string::String>,
    pub tasks: u32,
    pub cores_per_task: u32,
    pub tasks_per_node: u32,
    pub start_per_task: bool,
    pub start_time: ::std::string::String,
    pub temp_space: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a JobDescription {
    fn default() -> &'a JobDescription {
        <JobDescription as ::protobuf::Message>::default_instance()
    }
}

impl JobDescription {
    pub fn new() -> JobDescription {
        ::std::default::Default::default()
    }

    // string executable = 1;


    pub fn get_executable(&self) -> &str {
        &self.executable
    }
    pub fn clear_executable(&mut self) {
        self.executable.clear();
    }

    // Param is passed by value, moved
    pub fn set_executable(&mut self, v: ::std::string::String) {
        self.executable = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_executable(&mut self) -> &mut ::std::string::String {
        &mut self.executable
    }

    // Take field
    pub fn take_executable(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.executable, ::std::string::String::new())
    }

    // repeated string arguments = 2;


    pub fn get_arguments(&self) -> &[::std::string::String] {
        &self.arguments
    }
    pub fn clear_arguments(&mut self) {
        self.arguments.clear();
    }

    // Param is passed by value, moved
    pub fn set_arguments(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.arguments = v;
    }

    // Mutable pointer to the field.
    pub fn mut_arguments(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.arguments
    }

    // Take field
    pub fn take_arguments(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.arguments, ::protobuf::RepeatedField::new())
    }

    // string working_directory = 3;


    pub fn get_working_directory(&self) -> &str {
        &self.working_directory
    }
    pub fn clear_working_directory(&mut self) {
        self.working_directory.clear();
    }

    // Param is passed by value, moved
    pub fn set_working_directory(&mut self, v: ::std::string::String) {
        self.working_directory = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_working_directory(&mut self) -> &mut ::std::string::String {
        &mut self.working_directory
    }

    // Take field
    pub fn take_working_directory(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.working_directory, ::std::string::String::new())
    }

    // repeated .xenon.JobDescription.EnvironmentEntry environment = 4;


    pub fn get_environment(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.environment
    }
    pub fn clear_environment(&mut self) {
        self.environment.clear();
    }

    // Param is passed by value, moved
    pub fn set_environment(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.environment = v;
    }

    // Mutable pointer to the field.
    pub fn mut_environment(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.environment
    }

    // Take field
    pub fn take_environment(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.environment, ::std::collections::HashMap::new())
    }

    // string queue_name = 5;


    pub fn get_queue_name(&self) -> &str {
        &self.queue_name
    }
    pub fn clear_queue_name(&mut self) {
        self.queue_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_queue_name(&mut self, v: ::std::string::String) {
        self.queue_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_queue_name(&mut self) -> &mut ::std::string::String {
        &mut self.queue_name
    }

    // Take field
    pub fn take_queue_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.queue_name, ::std::string::String::new())
    }

    // uint32 max_runtime = 6;


    pub fn get_max_runtime(&self) -> u32 {
        self.max_runtime
    }
    pub fn clear_max_runtime(&mut self) {
        self.max_runtime = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_runtime(&mut self, v: u32) {
        self.max_runtime = v;
    }

    // string stderr = 10;


    pub fn get_stderr(&self) -> &str {
        &self.stderr
    }
    pub fn clear_stderr(&mut self) {
        self.stderr.clear();
    }

    // Param is passed by value, moved
    pub fn set_stderr(&mut self, v: ::std::string::String) {
        self.stderr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stderr(&mut self) -> &mut ::std::string::String {
        &mut self.stderr
    }

    // Take field
    pub fn take_stderr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.stderr, ::std::string::String::new())
    }

    // string stdin = 11;


    pub fn get_stdin(&self) -> &str {
        &self.stdin
    }
    pub fn clear_stdin(&mut self) {
        self.stdin.clear();
    }

    // Param is passed by value, moved
    pub fn set_stdin(&mut self, v: ::std::string::String) {
        self.stdin = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stdin(&mut self) -> &mut ::std::string::String {
        &mut self.stdin
    }

    // Take field
    pub fn take_stdin(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.stdin, ::std::string::String::new())
    }

    // string stdout = 12;


    pub fn get_stdout(&self) -> &str {
        &self.stdout
    }
    pub fn clear_stdout(&mut self) {
        self.stdout.clear();
    }

    // Param is passed by value, moved
    pub fn set_stdout(&mut self, v: ::std::string::String) {
        self.stdout = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stdout(&mut self) -> &mut ::std::string::String {
        &mut self.stdout
    }

    // Take field
    pub fn take_stdout(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.stdout, ::std::string::String::new())
    }

    // string name = 14;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // uint32 max_memory = 15;


    pub fn get_max_memory(&self) -> u32 {
        self.max_memory
    }
    pub fn clear_max_memory(&mut self) {
        self.max_memory = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_memory(&mut self, v: u32) {
        self.max_memory = v;
    }

    // repeated string scheduler_arguments = 16;


    pub fn get_scheduler_arguments(&self) -> &[::std::string::String] {
        &self.scheduler_arguments
    }
    pub fn clear_scheduler_arguments(&mut self) {
        self.scheduler_arguments.clear();
    }

    // Param is passed by value, moved
    pub fn set_scheduler_arguments(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.scheduler_arguments = v;
    }

    // Mutable pointer to the field.
    pub fn mut_scheduler_arguments(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.scheduler_arguments
    }

    // Take field
    pub fn take_scheduler_arguments(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.scheduler_arguments, ::protobuf::RepeatedField::new())
    }

    // uint32 tasks = 17;


    pub fn get_tasks(&self) -> u32 {
        self.tasks
    }
    pub fn clear_tasks(&mut self) {
        self.tasks = 0;
    }

    // Param is passed by value, moved
    pub fn set_tasks(&mut self, v: u32) {
        self.tasks = v;
    }

    // uint32 cores_per_task = 18;


    pub fn get_cores_per_task(&self) -> u32 {
        self.cores_per_task
    }
    pub fn clear_cores_per_task(&mut self) {
        self.cores_per_task = 0;
    }

    // Param is passed by value, moved
    pub fn set_cores_per_task(&mut self, v: u32) {
        self.cores_per_task = v;
    }

    // uint32 tasks_per_node = 19;


    pub fn get_tasks_per_node(&self) -> u32 {
        self.tasks_per_node
    }
    pub fn clear_tasks_per_node(&mut self) {
        self.tasks_per_node = 0;
    }

    // Param is passed by value, moved
    pub fn set_tasks_per_node(&mut self, v: u32) {
        self.tasks_per_node = v;
    }

    // bool start_per_task = 20;


    pub fn get_start_per_task(&self) -> bool {
        self.start_per_task
    }
    pub fn clear_start_per_task(&mut self) {
        self.start_per_task = false;
    }

    // Param is passed by value, moved
    pub fn set_start_per_task(&mut self, v: bool) {
        self.start_per_task = v;
    }

    // string start_time = 21;


    pub fn get_start_time(&self) -> &str {
        &self.start_time
    }
    pub fn clear_start_time(&mut self) {
        self.start_time.clear();
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: ::std::string::String) {
        self.start_time = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_start_time(&mut self) -> &mut ::std::string::String {
        &mut self.start_time
    }

    // Take field
    pub fn take_start_time(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.start_time, ::std::string::String::new())
    }

    // uint32 temp_space = 22;


    pub fn get_temp_space(&self) -> u32 {
        self.temp_space
    }
    pub fn clear_temp_space(&mut self) {
        self.temp_space = 0;
    }

    // Param is passed by value, moved
    pub fn set_temp_space(&mut self, v: u32) {
        self.temp_space = v;
    }
}

impl ::protobuf::Message for JobDescription {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.executable)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.arguments)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.working_directory)?;
                },
                4 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.environment)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.queue_name)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.max_runtime = tmp;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.stderr)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.stdin)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.stdout)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.max_memory = tmp;
                },
                16 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.scheduler_arguments)?;
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tasks = tmp;
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.cores_per_task = tmp;
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tasks_per_node = tmp;
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.start_per_task = tmp;
                },
                21 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.start_time)?;
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.temp_space = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.executable.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.executable);
        }
        for value in &self.arguments {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if !self.working_directory.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.working_directory);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(4, &self.environment);
        if !self.queue_name.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.queue_name);
        }
        if self.max_runtime != 0 {
            my_size += ::protobuf::rt::value_size(6, self.max_runtime, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.stderr.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.stderr);
        }
        if !self.stdin.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.stdin);
        }
        if !self.stdout.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.stdout);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.name);
        }
        if self.max_memory != 0 {
            my_size += ::protobuf::rt::value_size(15, self.max_memory, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.scheduler_arguments {
            my_size += ::protobuf::rt::string_size(16, &value);
        };
        if self.tasks != 0 {
            my_size += ::protobuf::rt::value_size(17, self.tasks, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.cores_per_task != 0 {
            my_size += ::protobuf::rt::value_size(18, self.cores_per_task, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.tasks_per_node != 0 {
            my_size += ::protobuf::rt::value_size(19, self.tasks_per_node, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.start_per_task != false {
            my_size += 3;
        }
        if !self.start_time.is_empty() {
            my_size += ::protobuf::rt::string_size(21, &self.start_time);
        }
        if self.temp_space != 0 {
            my_size += ::protobuf::rt::value_size(22, self.temp_space, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.executable.is_empty() {
            os.write_string(1, &self.executable)?;
        }
        for v in &self.arguments {
            os.write_string(2, &v)?;
        };
        if !self.working_directory.is_empty() {
            os.write_string(3, &self.working_directory)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(4, &self.environment, os)?;
        if !self.queue_name.is_empty() {
            os.write_string(5, &self.queue_name)?;
        }
        if self.max_runtime != 0 {
            os.write_uint32(6, self.max_runtime)?;
        }
        if !self.stderr.is_empty() {
            os.write_string(10, &self.stderr)?;
        }
        if !self.stdin.is_empty() {
            os.write_string(11, &self.stdin)?;
        }
        if !self.stdout.is_empty() {
            os.write_string(12, &self.stdout)?;
        }
        if !self.name.is_empty() {
            os.write_string(14, &self.name)?;
        }
        if self.max_memory != 0 {
            os.write_uint32(15, self.max_memory)?;
        }
        for v in &self.scheduler_arguments {
            os.write_string(16, &v)?;
        };
        if self.tasks != 0 {
            os.write_uint32(17, self.tasks)?;
        }
        if self.cores_per_task != 0 {
            os.write_uint32(18, self.cores_per_task)?;
        }
        if self.tasks_per_node != 0 {
            os.write_uint32(19, self.tasks_per_node)?;
        }
        if self.start_per_task != false {
            os.write_bool(20, self.start_per_task)?;
        }
        if !self.start_time.is_empty() {
            os.write_string(21, &self.start_time)?;
        }
        if self.temp_space != 0 {
            os.write_uint32(22, self.temp_space)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> JobDescription {
        JobDescription::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "executable",
                |m: &JobDescription| { &m.executable },
                |m: &mut JobDescription| { &mut m.executable },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "arguments",
                |m: &JobDescription| { &m.arguments },
                |m: &mut JobDescription| { &mut m.arguments },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "working_directory",
                |m: &JobDescription| { &m.working_directory },
                |m: &mut JobDescription| { &mut m.working_directory },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "environment",
                |m: &JobDescription| { &m.environment },
                |m: &mut JobDescription| { &mut m.environment },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "queue_name",
                |m: &JobDescription| { &m.queue_name },
                |m: &mut JobDescription| { &mut m.queue_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "max_runtime",
                |m: &JobDescription| { &m.max_runtime },
                |m: &mut JobDescription| { &mut m.max_runtime },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "stderr",
                |m: &JobDescription| { &m.stderr },
                |m: &mut JobDescription| { &mut m.stderr },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "stdin",
                |m: &JobDescription| { &m.stdin },
                |m: &mut JobDescription| { &mut m.stdin },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "stdout",
                |m: &JobDescription| { &m.stdout },
                |m: &mut JobDescription| { &mut m.stdout },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &JobDescription| { &m.name },
                |m: &mut JobDescription| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "max_memory",
                |m: &JobDescription| { &m.max_memory },
                |m: &mut JobDescription| { &mut m.max_memory },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "scheduler_arguments",
                |m: &JobDescription| { &m.scheduler_arguments },
                |m: &mut JobDescription| { &mut m.scheduler_arguments },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "tasks",
                |m: &JobDescription| { &m.tasks },
                |m: &mut JobDescription| { &mut m.tasks },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "cores_per_task",
                |m: &JobDescription| { &m.cores_per_task },
                |m: &mut JobDescription| { &mut m.cores_per_task },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "tasks_per_node",
                |m: &JobDescription| { &m.tasks_per_node },
                |m: &mut JobDescription| { &mut m.tasks_per_node },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "start_per_task",
                |m: &JobDescription| { &m.start_per_task },
                |m: &mut JobDescription| { &mut m.start_per_task },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "start_time",
                |m: &JobDescription| { &m.start_time },
                |m: &mut JobDescription| { &mut m.start_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "temp_space",
                |m: &JobDescription| { &m.temp_space },
                |m: &mut JobDescription| { &mut m.temp_space },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<JobDescription>(
                "JobDescription",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static JobDescription {
        static instance: ::protobuf::rt::LazyV2<JobDescription> = ::protobuf::rt::LazyV2::INIT;
        instance.get(JobDescription::new)
    }
}

impl ::protobuf::Clear for JobDescription {
    fn clear(&mut self) {
        self.executable.clear();
        self.arguments.clear();
        self.working_directory.clear();
        self.environment.clear();
        self.queue_name.clear();
        self.max_runtime = 0;
        self.stderr.clear();
        self.stdin.clear();
        self.stdout.clear();
        self.name.clear();
        self.max_memory = 0;
        self.scheduler_arguments.clear();
        self.tasks = 0;
        self.cores_per_task = 0;
        self.tasks_per_node = 0;
        self.start_per_task = false;
        self.start_time.clear();
        self.temp_space = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for JobDescription {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for JobDescription {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SubmitBatchJobRequest {
    // message fields
    pub scheduler: ::protobuf::SingularPtrField<Scheduler>,
    pub description: ::protobuf::SingularPtrField<JobDescription>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubmitBatchJobRequest {
    fn default() -> &'a SubmitBatchJobRequest {
        <SubmitBatchJobRequest as ::protobuf::Message>::default_instance()
    }
}

impl SubmitBatchJobRequest {
    pub fn new() -> SubmitBatchJobRequest {
        ::std::default::Default::default()
    }

    // .xenon.Scheduler scheduler = 1;


    pub fn get_scheduler(&self) -> &Scheduler {
        self.scheduler.as_ref().unwrap_or_else(|| <Scheduler as ::protobuf::Message>::default_instance())
    }
    pub fn clear_scheduler(&mut self) {
        self.scheduler.clear();
    }

    pub fn has_scheduler(&self) -> bool {
        self.scheduler.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scheduler(&mut self, v: Scheduler) {
        self.scheduler = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scheduler(&mut self) -> &mut Scheduler {
        if self.scheduler.is_none() {
            self.scheduler.set_default();
        }
        self.scheduler.as_mut().unwrap()
    }

    // Take field
    pub fn take_scheduler(&mut self) -> Scheduler {
        self.scheduler.take().unwrap_or_else(|| Scheduler::new())
    }

    // .xenon.JobDescription description = 2;


    pub fn get_description(&self) -> &JobDescription {
        self.description.as_ref().unwrap_or_else(|| <JobDescription as ::protobuf::Message>::default_instance())
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: JobDescription) {
        self.description = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut JobDescription {
        if self.description.is_none() {
            self.description.set_default();
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> JobDescription {
        self.description.take().unwrap_or_else(|| JobDescription::new())
    }
}

impl ::protobuf::Message for SubmitBatchJobRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.scheduler {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.description {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.scheduler)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.description)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.scheduler.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.description.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.scheduler.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.description.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubmitBatchJobRequest {
        SubmitBatchJobRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Scheduler>>(
                "scheduler",
                |m: &SubmitBatchJobRequest| { &m.scheduler },
                |m: &mut SubmitBatchJobRequest| { &mut m.scheduler },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<JobDescription>>(
                "description",
                |m: &SubmitBatchJobRequest| { &m.description },
                |m: &mut SubmitBatchJobRequest| { &mut m.description },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SubmitBatchJobRequest>(
                "SubmitBatchJobRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SubmitBatchJobRequest {
        static instance: ::protobuf::rt::LazyV2<SubmitBatchJobRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SubmitBatchJobRequest::new)
    }
}

impl ::protobuf::Clear for SubmitBatchJobRequest {
    fn clear(&mut self) {
        self.scheduler.clear();
        self.description.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SubmitBatchJobRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubmitBatchJobRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SubmitInteractiveJobRequest {
    // message fields
    pub scheduler: ::protobuf::SingularPtrField<Scheduler>,
    pub description: ::protobuf::SingularPtrField<JobDescription>,
    pub stdin: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubmitInteractiveJobRequest {
    fn default() -> &'a SubmitInteractiveJobRequest {
        <SubmitInteractiveJobRequest as ::protobuf::Message>::default_instance()
    }
}

impl SubmitInteractiveJobRequest {
    pub fn new() -> SubmitInteractiveJobRequest {
        ::std::default::Default::default()
    }

    // .xenon.Scheduler scheduler = 1;


    pub fn get_scheduler(&self) -> &Scheduler {
        self.scheduler.as_ref().unwrap_or_else(|| <Scheduler as ::protobuf::Message>::default_instance())
    }
    pub fn clear_scheduler(&mut self) {
        self.scheduler.clear();
    }

    pub fn has_scheduler(&self) -> bool {
        self.scheduler.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scheduler(&mut self, v: Scheduler) {
        self.scheduler = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scheduler(&mut self) -> &mut Scheduler {
        if self.scheduler.is_none() {
            self.scheduler.set_default();
        }
        self.scheduler.as_mut().unwrap()
    }

    // Take field
    pub fn take_scheduler(&mut self) -> Scheduler {
        self.scheduler.take().unwrap_or_else(|| Scheduler::new())
    }

    // .xenon.JobDescription description = 2;


    pub fn get_description(&self) -> &JobDescription {
        self.description.as_ref().unwrap_or_else(|| <JobDescription as ::protobuf::Message>::default_instance())
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: JobDescription) {
        self.description = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut JobDescription {
        if self.description.is_none() {
            self.description.set_default();
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> JobDescription {
        self.description.take().unwrap_or_else(|| JobDescription::new())
    }

    // bytes stdin = 3;


    pub fn get_stdin(&self) -> &[u8] {
        &self.stdin
    }
    pub fn clear_stdin(&mut self) {
        self.stdin.clear();
    }

    // Param is passed by value, moved
    pub fn set_stdin(&mut self, v: ::std::vec::Vec<u8>) {
        self.stdin = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stdin(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.stdin
    }

    // Take field
    pub fn take_stdin(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.stdin, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for SubmitInteractiveJobRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.scheduler {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.description {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.scheduler)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.description)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.stdin)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.scheduler.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.description.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.stdin.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.stdin);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.scheduler.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.description.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.stdin.is_empty() {
            os.write_bytes(3, &self.stdin)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubmitInteractiveJobRequest {
        SubmitInteractiveJobRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Scheduler>>(
                "scheduler",
                |m: &SubmitInteractiveJobRequest| { &m.scheduler },
                |m: &mut SubmitInteractiveJobRequest| { &mut m.scheduler },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<JobDescription>>(
                "description",
                |m: &SubmitInteractiveJobRequest| { &m.description },
                |m: &mut SubmitInteractiveJobRequest| { &mut m.description },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "stdin",
                |m: &SubmitInteractiveJobRequest| { &m.stdin },
                |m: &mut SubmitInteractiveJobRequest| { &mut m.stdin },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SubmitInteractiveJobRequest>(
                "SubmitInteractiveJobRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SubmitInteractiveJobRequest {
        static instance: ::protobuf::rt::LazyV2<SubmitInteractiveJobRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SubmitInteractiveJobRequest::new)
    }
}

impl ::protobuf::Clear for SubmitInteractiveJobRequest {
    fn clear(&mut self) {
        self.scheduler.clear();
        self.description.clear();
        self.stdin.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SubmitInteractiveJobRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubmitInteractiveJobRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Job {
    // message fields
    pub id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Job {
    fn default() -> &'a Job {
        <Job as ::protobuf::Message>::default_instance()
    }
}

impl Job {
    pub fn new() -> Job {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Job {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Job {
        Job::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &Job| { &m.id },
                |m: &mut Job| { &mut m.id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Job>(
                "Job",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Job {
        static instance: ::protobuf::rt::LazyV2<Job> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Job::new)
    }
}

impl ::protobuf::Clear for Job {
    fn clear(&mut self) {
        self.id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Job {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Job {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct JobRequest {
    // message fields
    pub scheduler: ::protobuf::SingularPtrField<Scheduler>,
    pub job: ::protobuf::SingularPtrField<Job>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a JobRequest {
    fn default() -> &'a JobRequest {
        <JobRequest as ::protobuf::Message>::default_instance()
    }
}

impl JobRequest {
    pub fn new() -> JobRequest {
        ::std::default::Default::default()
    }

    // .xenon.Scheduler scheduler = 1;


    pub fn get_scheduler(&self) -> &Scheduler {
        self.scheduler.as_ref().unwrap_or_else(|| <Scheduler as ::protobuf::Message>::default_instance())
    }
    pub fn clear_scheduler(&mut self) {
        self.scheduler.clear();
    }

    pub fn has_scheduler(&self) -> bool {
        self.scheduler.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scheduler(&mut self, v: Scheduler) {
        self.scheduler = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scheduler(&mut self) -> &mut Scheduler {
        if self.scheduler.is_none() {
            self.scheduler.set_default();
        }
        self.scheduler.as_mut().unwrap()
    }

    // Take field
    pub fn take_scheduler(&mut self) -> Scheduler {
        self.scheduler.take().unwrap_or_else(|| Scheduler::new())
    }

    // .xenon.Job job = 2;


    pub fn get_job(&self) -> &Job {
        self.job.as_ref().unwrap_or_else(|| <Job as ::protobuf::Message>::default_instance())
    }
    pub fn clear_job(&mut self) {
        self.job.clear();
    }

    pub fn has_job(&self) -> bool {
        self.job.is_some()
    }

    // Param is passed by value, moved
    pub fn set_job(&mut self, v: Job) {
        self.job = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_job(&mut self) -> &mut Job {
        if self.job.is_none() {
            self.job.set_default();
        }
        self.job.as_mut().unwrap()
    }

    // Take field
    pub fn take_job(&mut self) -> Job {
        self.job.take().unwrap_or_else(|| Job::new())
    }
}

impl ::protobuf::Message for JobRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.scheduler {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.job {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.scheduler)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.job)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.scheduler.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.job.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.scheduler.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.job.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> JobRequest {
        JobRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Scheduler>>(
                "scheduler",
                |m: &JobRequest| { &m.scheduler },
                |m: &mut JobRequest| { &mut m.scheduler },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Job>>(
                "job",
                |m: &JobRequest| { &m.job },
                |m: &mut JobRequest| { &mut m.job },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<JobRequest>(
                "JobRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static JobRequest {
        static instance: ::protobuf::rt::LazyV2<JobRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(JobRequest::new)
    }
}

impl ::protobuf::Clear for JobRequest {
    fn clear(&mut self) {
        self.scheduler.clear();
        self.job.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for JobRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for JobRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Jobs {
    // message fields
    pub jobs: ::protobuf::RepeatedField<Job>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Jobs {
    fn default() -> &'a Jobs {
        <Jobs as ::protobuf::Message>::default_instance()
    }
}

impl Jobs {
    pub fn new() -> Jobs {
        ::std::default::Default::default()
    }

    // repeated .xenon.Job jobs = 2;


    pub fn get_jobs(&self) -> &[Job] {
        &self.jobs
    }
    pub fn clear_jobs(&mut self) {
        self.jobs.clear();
    }

    // Param is passed by value, moved
    pub fn set_jobs(&mut self, v: ::protobuf::RepeatedField<Job>) {
        self.jobs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_jobs(&mut self) -> &mut ::protobuf::RepeatedField<Job> {
        &mut self.jobs
    }

    // Take field
    pub fn take_jobs(&mut self) -> ::protobuf::RepeatedField<Job> {
        ::std::mem::replace(&mut self.jobs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Jobs {
    fn is_initialized(&self) -> bool {
        for v in &self.jobs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.jobs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.jobs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.jobs {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Jobs {
        Jobs::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Job>>(
                "jobs",
                |m: &Jobs| { &m.jobs },
                |m: &mut Jobs| { &mut m.jobs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Jobs>(
                "Jobs",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Jobs {
        static instance: ::protobuf::rt::LazyV2<Jobs> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Jobs::new)
    }
}

impl ::protobuf::Clear for Jobs {
    fn clear(&mut self) {
        self.jobs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Jobs {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Jobs {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetJobStatusesRequest {
    // message fields
    pub scheduler: ::protobuf::SingularPtrField<Scheduler>,
    pub jobs: ::protobuf::RepeatedField<Job>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetJobStatusesRequest {
    fn default() -> &'a GetJobStatusesRequest {
        <GetJobStatusesRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetJobStatusesRequest {
    pub fn new() -> GetJobStatusesRequest {
        ::std::default::Default::default()
    }

    // .xenon.Scheduler scheduler = 1;


    pub fn get_scheduler(&self) -> &Scheduler {
        self.scheduler.as_ref().unwrap_or_else(|| <Scheduler as ::protobuf::Message>::default_instance())
    }
    pub fn clear_scheduler(&mut self) {
        self.scheduler.clear();
    }

    pub fn has_scheduler(&self) -> bool {
        self.scheduler.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scheduler(&mut self, v: Scheduler) {
        self.scheduler = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scheduler(&mut self) -> &mut Scheduler {
        if self.scheduler.is_none() {
            self.scheduler.set_default();
        }
        self.scheduler.as_mut().unwrap()
    }

    // Take field
    pub fn take_scheduler(&mut self) -> Scheduler {
        self.scheduler.take().unwrap_or_else(|| Scheduler::new())
    }

    // repeated .xenon.Job jobs = 2;


    pub fn get_jobs(&self) -> &[Job] {
        &self.jobs
    }
    pub fn clear_jobs(&mut self) {
        self.jobs.clear();
    }

    // Param is passed by value, moved
    pub fn set_jobs(&mut self, v: ::protobuf::RepeatedField<Job>) {
        self.jobs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_jobs(&mut self) -> &mut ::protobuf::RepeatedField<Job> {
        &mut self.jobs
    }

    // Take field
    pub fn take_jobs(&mut self) -> ::protobuf::RepeatedField<Job> {
        ::std::mem::replace(&mut self.jobs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GetJobStatusesRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.scheduler {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.jobs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.scheduler)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.jobs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.scheduler.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.jobs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.scheduler.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.jobs {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetJobStatusesRequest {
        GetJobStatusesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Scheduler>>(
                "scheduler",
                |m: &GetJobStatusesRequest| { &m.scheduler },
                |m: &mut GetJobStatusesRequest| { &mut m.scheduler },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Job>>(
                "jobs",
                |m: &GetJobStatusesRequest| { &m.jobs },
                |m: &mut GetJobStatusesRequest| { &mut m.jobs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetJobStatusesRequest>(
                "GetJobStatusesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetJobStatusesRequest {
        static instance: ::protobuf::rt::LazyV2<GetJobStatusesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetJobStatusesRequest::new)
    }
}

impl ::protobuf::Clear for GetJobStatusesRequest {
    fn clear(&mut self) {
        self.scheduler.clear();
        self.jobs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetJobStatusesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetJobStatusesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WaitRequest {
    // message fields
    pub scheduler: ::protobuf::SingularPtrField<Scheduler>,
    pub job: ::protobuf::SingularPtrField<Job>,
    pub timeout: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WaitRequest {
    fn default() -> &'a WaitRequest {
        <WaitRequest as ::protobuf::Message>::default_instance()
    }
}

impl WaitRequest {
    pub fn new() -> WaitRequest {
        ::std::default::Default::default()
    }

    // .xenon.Scheduler scheduler = 1;


    pub fn get_scheduler(&self) -> &Scheduler {
        self.scheduler.as_ref().unwrap_or_else(|| <Scheduler as ::protobuf::Message>::default_instance())
    }
    pub fn clear_scheduler(&mut self) {
        self.scheduler.clear();
    }

    pub fn has_scheduler(&self) -> bool {
        self.scheduler.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scheduler(&mut self, v: Scheduler) {
        self.scheduler = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scheduler(&mut self) -> &mut Scheduler {
        if self.scheduler.is_none() {
            self.scheduler.set_default();
        }
        self.scheduler.as_mut().unwrap()
    }

    // Take field
    pub fn take_scheduler(&mut self) -> Scheduler {
        self.scheduler.take().unwrap_or_else(|| Scheduler::new())
    }

    // .xenon.Job job = 2;


    pub fn get_job(&self) -> &Job {
        self.job.as_ref().unwrap_or_else(|| <Job as ::protobuf::Message>::default_instance())
    }
    pub fn clear_job(&mut self) {
        self.job.clear();
    }

    pub fn has_job(&self) -> bool {
        self.job.is_some()
    }

    // Param is passed by value, moved
    pub fn set_job(&mut self, v: Job) {
        self.job = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_job(&mut self) -> &mut Job {
        if self.job.is_none() {
            self.job.set_default();
        }
        self.job.as_mut().unwrap()
    }

    // Take field
    pub fn take_job(&mut self) -> Job {
        self.job.take().unwrap_or_else(|| Job::new())
    }

    // uint64 timeout = 3;


    pub fn get_timeout(&self) -> u64 {
        self.timeout
    }
    pub fn clear_timeout(&mut self) {
        self.timeout = 0;
    }

    // Param is passed by value, moved
    pub fn set_timeout(&mut self, v: u64) {
        self.timeout = v;
    }
}

impl ::protobuf::Message for WaitRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.scheduler {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.job {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.scheduler)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.job)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.timeout = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.scheduler.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.job.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.timeout != 0 {
            my_size += ::protobuf::rt::value_size(3, self.timeout, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.scheduler.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.job.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.timeout != 0 {
            os.write_uint64(3, self.timeout)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WaitRequest {
        WaitRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Scheduler>>(
                "scheduler",
                |m: &WaitRequest| { &m.scheduler },
                |m: &mut WaitRequest| { &mut m.scheduler },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Job>>(
                "job",
                |m: &WaitRequest| { &m.job },
                |m: &mut WaitRequest| { &mut m.job },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "timeout",
                |m: &WaitRequest| { &m.timeout },
                |m: &mut WaitRequest| { &mut m.timeout },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WaitRequest>(
                "WaitRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static WaitRequest {
        static instance: ::protobuf::rt::LazyV2<WaitRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WaitRequest::new)
    }
}

impl ::protobuf::Clear for WaitRequest {
    fn clear(&mut self) {
        self.scheduler.clear();
        self.job.clear();
        self.timeout = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WaitRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WaitRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Queue {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Queue {
    fn default() -> &'a Queue {
        <Queue as ::protobuf::Message>::default_instance()
    }
}

impl Queue {
    pub fn new() -> Queue {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Queue {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Queue {
        Queue::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Queue| { &m.name },
                |m: &mut Queue| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Queue>(
                "Queue",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Queue {
        static instance: ::protobuf::rt::LazyV2<Queue> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Queue::new)
    }
}

impl ::protobuf::Clear for Queue {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Queue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Queue {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Queues {
    // message fields
    pub name: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Queues {
    fn default() -> &'a Queues {
        <Queues as ::protobuf::Message>::default_instance()
    }
}

impl Queues {
    pub fn new() -> Queues {
        ::std::default::Default::default()
    }

    // repeated string name = 1;


    pub fn get_name(&self) -> &[::std::string::String] {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.name = v;
    }

    // Mutable pointer to the field.
    pub fn mut_name(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.name, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Queues {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.name {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.name {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Queues {
        Queues::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Queues| { &m.name },
                |m: &mut Queues| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Queues>(
                "Queues",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Queues {
        static instance: ::protobuf::rt::LazyV2<Queues> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Queues::new)
    }
}

impl ::protobuf::Clear for Queues {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Queues {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Queues {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SchedulerAndQueues {
    // message fields
    pub scheduler: ::protobuf::SingularPtrField<Scheduler>,
    pub queues: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SchedulerAndQueues {
    fn default() -> &'a SchedulerAndQueues {
        <SchedulerAndQueues as ::protobuf::Message>::default_instance()
    }
}

impl SchedulerAndQueues {
    pub fn new() -> SchedulerAndQueues {
        ::std::default::Default::default()
    }

    // .xenon.Scheduler scheduler = 1;


    pub fn get_scheduler(&self) -> &Scheduler {
        self.scheduler.as_ref().unwrap_or_else(|| <Scheduler as ::protobuf::Message>::default_instance())
    }
    pub fn clear_scheduler(&mut self) {
        self.scheduler.clear();
    }

    pub fn has_scheduler(&self) -> bool {
        self.scheduler.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scheduler(&mut self, v: Scheduler) {
        self.scheduler = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scheduler(&mut self) -> &mut Scheduler {
        if self.scheduler.is_none() {
            self.scheduler.set_default();
        }
        self.scheduler.as_mut().unwrap()
    }

    // Take field
    pub fn take_scheduler(&mut self) -> Scheduler {
        self.scheduler.take().unwrap_or_else(|| Scheduler::new())
    }

    // repeated string queues = 2;


    pub fn get_queues(&self) -> &[::std::string::String] {
        &self.queues
    }
    pub fn clear_queues(&mut self) {
        self.queues.clear();
    }

    // Param is passed by value, moved
    pub fn set_queues(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.queues = v;
    }

    // Mutable pointer to the field.
    pub fn mut_queues(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.queues
    }

    // Take field
    pub fn take_queues(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.queues, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for SchedulerAndQueues {
    fn is_initialized(&self) -> bool {
        for v in &self.scheduler {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.scheduler)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.queues)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.scheduler.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.queues {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.scheduler.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.queues {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SchedulerAndQueues {
        SchedulerAndQueues::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Scheduler>>(
                "scheduler",
                |m: &SchedulerAndQueues| { &m.scheduler },
                |m: &mut SchedulerAndQueues| { &mut m.scheduler },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "queues",
                |m: &SchedulerAndQueues| { &m.queues },
                |m: &mut SchedulerAndQueues| { &mut m.queues },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SchedulerAndQueues>(
                "SchedulerAndQueues",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SchedulerAndQueues {
        static instance: ::protobuf::rt::LazyV2<SchedulerAndQueues> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SchedulerAndQueues::new)
    }
}

impl ::protobuf::Clear for SchedulerAndQueues {
    fn clear(&mut self) {
        self.scheduler.clear();
        self.queues.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SchedulerAndQueues {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SchedulerAndQueues {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetQueueStatusRequest {
    // message fields
    pub scheduler: ::protobuf::SingularPtrField<Scheduler>,
    pub queue: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetQueueStatusRequest {
    fn default() -> &'a GetQueueStatusRequest {
        <GetQueueStatusRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetQueueStatusRequest {
    pub fn new() -> GetQueueStatusRequest {
        ::std::default::Default::default()
    }

    // .xenon.Scheduler scheduler = 1;


    pub fn get_scheduler(&self) -> &Scheduler {
        self.scheduler.as_ref().unwrap_or_else(|| <Scheduler as ::protobuf::Message>::default_instance())
    }
    pub fn clear_scheduler(&mut self) {
        self.scheduler.clear();
    }

    pub fn has_scheduler(&self) -> bool {
        self.scheduler.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scheduler(&mut self, v: Scheduler) {
        self.scheduler = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scheduler(&mut self) -> &mut Scheduler {
        if self.scheduler.is_none() {
            self.scheduler.set_default();
        }
        self.scheduler.as_mut().unwrap()
    }

    // Take field
    pub fn take_scheduler(&mut self) -> Scheduler {
        self.scheduler.take().unwrap_or_else(|| Scheduler::new())
    }

    // string queue = 2;


    pub fn get_queue(&self) -> &str {
        &self.queue
    }
    pub fn clear_queue(&mut self) {
        self.queue.clear();
    }

    // Param is passed by value, moved
    pub fn set_queue(&mut self, v: ::std::string::String) {
        self.queue = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_queue(&mut self) -> &mut ::std::string::String {
        &mut self.queue
    }

    // Take field
    pub fn take_queue(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.queue, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetQueueStatusRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.scheduler {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.scheduler)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.queue)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.scheduler.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.queue.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.queue);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.scheduler.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.queue.is_empty() {
            os.write_string(2, &self.queue)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetQueueStatusRequest {
        GetQueueStatusRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Scheduler>>(
                "scheduler",
                |m: &GetQueueStatusRequest| { &m.scheduler },
                |m: &mut GetQueueStatusRequest| { &mut m.scheduler },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "queue",
                |m: &GetQueueStatusRequest| { &m.queue },
                |m: &mut GetQueueStatusRequest| { &mut m.queue },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetQueueStatusRequest>(
                "GetQueueStatusRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetQueueStatusRequest {
        static instance: ::protobuf::rt::LazyV2<GetQueueStatusRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetQueueStatusRequest::new)
    }
}

impl ::protobuf::Clear for GetQueueStatusRequest {
    fn clear(&mut self) {
        self.scheduler.clear();
        self.queue.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetQueueStatusRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetQueueStatusRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct JobStatus {
    // message fields
    pub job: ::protobuf::SingularPtrField<Job>,
    pub state: ::std::string::String,
    pub running: bool,
    pub done: bool,
    pub scheduler_specific_information: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub exit_code: i32,
    pub error_message: ::std::string::String,
    pub error_type: JobStatus_ErrorType,
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a JobStatus {
    fn default() -> &'a JobStatus {
        <JobStatus as ::protobuf::Message>::default_instance()
    }
}

impl JobStatus {
    pub fn new() -> JobStatus {
        ::std::default::Default::default()
    }

    // .xenon.Job job = 1;


    pub fn get_job(&self) -> &Job {
        self.job.as_ref().unwrap_or_else(|| <Job as ::protobuf::Message>::default_instance())
    }
    pub fn clear_job(&mut self) {
        self.job.clear();
    }

    pub fn has_job(&self) -> bool {
        self.job.is_some()
    }

    // Param is passed by value, moved
    pub fn set_job(&mut self, v: Job) {
        self.job = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_job(&mut self) -> &mut Job {
        if self.job.is_none() {
            self.job.set_default();
        }
        self.job.as_mut().unwrap()
    }

    // Take field
    pub fn take_job(&mut self) -> Job {
        self.job.take().unwrap_or_else(|| Job::new())
    }

    // string state = 2;


    pub fn get_state(&self) -> &str {
        &self.state
    }
    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: ::std::string::String) {
        self.state = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut ::std::string::String {
        &mut self.state
    }

    // Take field
    pub fn take_state(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.state, ::std::string::String::new())
    }

    // bool running = 3;


    pub fn get_running(&self) -> bool {
        self.running
    }
    pub fn clear_running(&mut self) {
        self.running = false;
    }

    // Param is passed by value, moved
    pub fn set_running(&mut self, v: bool) {
        self.running = v;
    }

    // bool done = 4;


    pub fn get_done(&self) -> bool {
        self.done
    }
    pub fn clear_done(&mut self) {
        self.done = false;
    }

    // Param is passed by value, moved
    pub fn set_done(&mut self, v: bool) {
        self.done = v;
    }

    // repeated .xenon.JobStatus.SchedulerSpecificInformationEntry scheduler_specific_information = 5;


    pub fn get_scheduler_specific_information(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.scheduler_specific_information
    }
    pub fn clear_scheduler_specific_information(&mut self) {
        self.scheduler_specific_information.clear();
    }

    // Param is passed by value, moved
    pub fn set_scheduler_specific_information(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.scheduler_specific_information = v;
    }

    // Mutable pointer to the field.
    pub fn mut_scheduler_specific_information(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.scheduler_specific_information
    }

    // Take field
    pub fn take_scheduler_specific_information(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.scheduler_specific_information, ::std::collections::HashMap::new())
    }

    // int32 exit_code = 6;


    pub fn get_exit_code(&self) -> i32 {
        self.exit_code
    }
    pub fn clear_exit_code(&mut self) {
        self.exit_code = 0;
    }

    // Param is passed by value, moved
    pub fn set_exit_code(&mut self, v: i32) {
        self.exit_code = v;
    }

    // string error_message = 7;


    pub fn get_error_message(&self) -> &str {
        &self.error_message
    }
    pub fn clear_error_message(&mut self) {
        self.error_message.clear();
    }

    // Param is passed by value, moved
    pub fn set_error_message(&mut self, v: ::std::string::String) {
        self.error_message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_message(&mut self) -> &mut ::std::string::String {
        &mut self.error_message
    }

    // Take field
    pub fn take_error_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.error_message, ::std::string::String::new())
    }

    // .xenon.JobStatus.ErrorType error_type = 8;


    pub fn get_error_type(&self) -> JobStatus_ErrorType {
        self.error_type
    }
    pub fn clear_error_type(&mut self) {
        self.error_type = JobStatus_ErrorType::NONE;
    }

    // Param is passed by value, moved
    pub fn set_error_type(&mut self, v: JobStatus_ErrorType) {
        self.error_type = v;
    }

    // string name = 9;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for JobStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.job {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.job)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.state)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.running = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.done = tmp;
                },
                5 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.scheduler_specific_information)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.exit_code = tmp;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.error_message)?;
                },
                8 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.error_type, 8, &mut self.unknown_fields)?
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.job.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.state.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.state);
        }
        if self.running != false {
            my_size += 2;
        }
        if self.done != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(5, &self.scheduler_specific_information);
        if self.exit_code != 0 {
            my_size += ::protobuf::rt::value_size(6, self.exit_code, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.error_message.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.error_message);
        }
        if self.error_type != JobStatus_ErrorType::NONE {
            my_size += ::protobuf::rt::enum_size(8, self.error_type);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.job.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.state.is_empty() {
            os.write_string(2, &self.state)?;
        }
        if self.running != false {
            os.write_bool(3, self.running)?;
        }
        if self.done != false {
            os.write_bool(4, self.done)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(5, &self.scheduler_specific_information, os)?;
        if self.exit_code != 0 {
            os.write_int32(6, self.exit_code)?;
        }
        if !self.error_message.is_empty() {
            os.write_string(7, &self.error_message)?;
        }
        if self.error_type != JobStatus_ErrorType::NONE {
            os.write_enum(8, ::protobuf::ProtobufEnum::value(&self.error_type))?;
        }
        if !self.name.is_empty() {
            os.write_string(9, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> JobStatus {
        JobStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Job>>(
                "job",
                |m: &JobStatus| { &m.job },
                |m: &mut JobStatus| { &mut m.job },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "state",
                |m: &JobStatus| { &m.state },
                |m: &mut JobStatus| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "running",
                |m: &JobStatus| { &m.running },
                |m: &mut JobStatus| { &mut m.running },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "done",
                |m: &JobStatus| { &m.done },
                |m: &mut JobStatus| { &mut m.done },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "scheduler_specific_information",
                |m: &JobStatus| { &m.scheduler_specific_information },
                |m: &mut JobStatus| { &mut m.scheduler_specific_information },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "exit_code",
                |m: &JobStatus| { &m.exit_code },
                |m: &mut JobStatus| { &mut m.exit_code },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "error_message",
                |m: &JobStatus| { &m.error_message },
                |m: &mut JobStatus| { &mut m.error_message },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<JobStatus_ErrorType>>(
                "error_type",
                |m: &JobStatus| { &m.error_type },
                |m: &mut JobStatus| { &mut m.error_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &JobStatus| { &m.name },
                |m: &mut JobStatus| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<JobStatus>(
                "JobStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static JobStatus {
        static instance: ::protobuf::rt::LazyV2<JobStatus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(JobStatus::new)
    }
}

impl ::protobuf::Clear for JobStatus {
    fn clear(&mut self) {
        self.job.clear();
        self.state.clear();
        self.running = false;
        self.done = false;
        self.scheduler_specific_information.clear();
        self.exit_code = 0;
        self.error_message.clear();
        self.error_type = JobStatus_ErrorType::NONE;
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for JobStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for JobStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum JobStatus_ErrorType {
    NONE = 0,
    NOT_FOUND = 1,
    CANCELLED = 2,
    NOT_CONNECTED = 3,
    XENON = 4,
    IO = 5,
    OTHER = 6,
}

impl ::protobuf::ProtobufEnum for JobStatus_ErrorType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<JobStatus_ErrorType> {
        match value {
            0 => ::std::option::Option::Some(JobStatus_ErrorType::NONE),
            1 => ::std::option::Option::Some(JobStatus_ErrorType::NOT_FOUND),
            2 => ::std::option::Option::Some(JobStatus_ErrorType::CANCELLED),
            3 => ::std::option::Option::Some(JobStatus_ErrorType::NOT_CONNECTED),
            4 => ::std::option::Option::Some(JobStatus_ErrorType::XENON),
            5 => ::std::option::Option::Some(JobStatus_ErrorType::IO),
            6 => ::std::option::Option::Some(JobStatus_ErrorType::OTHER),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [JobStatus_ErrorType] = &[
            JobStatus_ErrorType::NONE,
            JobStatus_ErrorType::NOT_FOUND,
            JobStatus_ErrorType::CANCELLED,
            JobStatus_ErrorType::NOT_CONNECTED,
            JobStatus_ErrorType::XENON,
            JobStatus_ErrorType::IO,
            JobStatus_ErrorType::OTHER,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<JobStatus_ErrorType>("JobStatus.ErrorType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for JobStatus_ErrorType {
}

impl ::std::default::Default for JobStatus_ErrorType {
    fn default() -> Self {
        JobStatus_ErrorType::NONE
    }
}

impl ::protobuf::reflect::ProtobufValue for JobStatus_ErrorType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetJobStatusesResponse {
    // message fields
    pub statuses: ::protobuf::RepeatedField<JobStatus>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetJobStatusesResponse {
    fn default() -> &'a GetJobStatusesResponse {
        <GetJobStatusesResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetJobStatusesResponse {
    pub fn new() -> GetJobStatusesResponse {
        ::std::default::Default::default()
    }

    // repeated .xenon.JobStatus statuses = 1;


    pub fn get_statuses(&self) -> &[JobStatus] {
        &self.statuses
    }
    pub fn clear_statuses(&mut self) {
        self.statuses.clear();
    }

    // Param is passed by value, moved
    pub fn set_statuses(&mut self, v: ::protobuf::RepeatedField<JobStatus>) {
        self.statuses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_statuses(&mut self) -> &mut ::protobuf::RepeatedField<JobStatus> {
        &mut self.statuses
    }

    // Take field
    pub fn take_statuses(&mut self) -> ::protobuf::RepeatedField<JobStatus> {
        ::std::mem::replace(&mut self.statuses, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GetJobStatusesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.statuses {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.statuses)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.statuses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.statuses {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetJobStatusesResponse {
        GetJobStatusesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<JobStatus>>(
                "statuses",
                |m: &GetJobStatusesResponse| { &m.statuses },
                |m: &mut GetJobStatusesResponse| { &mut m.statuses },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetJobStatusesResponse>(
                "GetJobStatusesResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetJobStatusesResponse {
        static instance: ::protobuf::rt::LazyV2<GetJobStatusesResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetJobStatusesResponse::new)
    }
}

impl ::protobuf::Clear for GetJobStatusesResponse {
    fn clear(&mut self) {
        self.statuses.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetJobStatusesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetJobStatusesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueueStatus {
    // message fields
    pub name: ::std::string::String,
    pub scheduler_specific_information: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub error_message: ::std::string::String,
    pub error_type: QueueStatus_ErrorType,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueueStatus {
    fn default() -> &'a QueueStatus {
        <QueueStatus as ::protobuf::Message>::default_instance()
    }
}

impl QueueStatus {
    pub fn new() -> QueueStatus {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // repeated .xenon.QueueStatus.SchedulerSpecificInformationEntry scheduler_specific_information = 2;


    pub fn get_scheduler_specific_information(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.scheduler_specific_information
    }
    pub fn clear_scheduler_specific_information(&mut self) {
        self.scheduler_specific_information.clear();
    }

    // Param is passed by value, moved
    pub fn set_scheduler_specific_information(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.scheduler_specific_information = v;
    }

    // Mutable pointer to the field.
    pub fn mut_scheduler_specific_information(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.scheduler_specific_information
    }

    // Take field
    pub fn take_scheduler_specific_information(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.scheduler_specific_information, ::std::collections::HashMap::new())
    }

    // string error_message = 3;


    pub fn get_error_message(&self) -> &str {
        &self.error_message
    }
    pub fn clear_error_message(&mut self) {
        self.error_message.clear();
    }

    // Param is passed by value, moved
    pub fn set_error_message(&mut self, v: ::std::string::String) {
        self.error_message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_message(&mut self) -> &mut ::std::string::String {
        &mut self.error_message
    }

    // Take field
    pub fn take_error_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.error_message, ::std::string::String::new())
    }

    // .xenon.QueueStatus.ErrorType error_type = 4;


    pub fn get_error_type(&self) -> QueueStatus_ErrorType {
        self.error_type
    }
    pub fn clear_error_type(&mut self) {
        self.error_type = QueueStatus_ErrorType::NONE;
    }

    // Param is passed by value, moved
    pub fn set_error_type(&mut self, v: QueueStatus_ErrorType) {
        self.error_type = v;
    }
}

impl ::protobuf::Message for QueueStatus {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.scheduler_specific_information)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.error_message)?;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.error_type, 4, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(2, &self.scheduler_specific_information);
        if !self.error_message.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.error_message);
        }
        if self.error_type != QueueStatus_ErrorType::NONE {
            my_size += ::protobuf::rt::enum_size(4, self.error_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(2, &self.scheduler_specific_information, os)?;
        if !self.error_message.is_empty() {
            os.write_string(3, &self.error_message)?;
        }
        if self.error_type != QueueStatus_ErrorType::NONE {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&self.error_type))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueueStatus {
        QueueStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &QueueStatus| { &m.name },
                |m: &mut QueueStatus| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "scheduler_specific_information",
                |m: &QueueStatus| { &m.scheduler_specific_information },
                |m: &mut QueueStatus| { &mut m.scheduler_specific_information },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "error_message",
                |m: &QueueStatus| { &m.error_message },
                |m: &mut QueueStatus| { &mut m.error_message },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<QueueStatus_ErrorType>>(
                "error_type",
                |m: &QueueStatus| { &m.error_type },
                |m: &mut QueueStatus| { &mut m.error_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueueStatus>(
                "QueueStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueueStatus {
        static instance: ::protobuf::rt::LazyV2<QueueStatus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueueStatus::new)
    }
}

impl ::protobuf::Clear for QueueStatus {
    fn clear(&mut self) {
        self.name.clear();
        self.scheduler_specific_information.clear();
        self.error_message.clear();
        self.error_type = QueueStatus_ErrorType::NONE;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueueStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueueStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum QueueStatus_ErrorType {
    NONE = 0,
    NOT_FOUND = 1,
    NOT_CONNECTED = 2,
    XENON = 3,
    IO = 4,
    OTHER = 5,
}

impl ::protobuf::ProtobufEnum for QueueStatus_ErrorType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<QueueStatus_ErrorType> {
        match value {
            0 => ::std::option::Option::Some(QueueStatus_ErrorType::NONE),
            1 => ::std::option::Option::Some(QueueStatus_ErrorType::NOT_FOUND),
            2 => ::std::option::Option::Some(QueueStatus_ErrorType::NOT_CONNECTED),
            3 => ::std::option::Option::Some(QueueStatus_ErrorType::XENON),
            4 => ::std::option::Option::Some(QueueStatus_ErrorType::IO),
            5 => ::std::option::Option::Some(QueueStatus_ErrorType::OTHER),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [QueueStatus_ErrorType] = &[
            QueueStatus_ErrorType::NONE,
            QueueStatus_ErrorType::NOT_FOUND,
            QueueStatus_ErrorType::NOT_CONNECTED,
            QueueStatus_ErrorType::XENON,
            QueueStatus_ErrorType::IO,
            QueueStatus_ErrorType::OTHER,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<QueueStatus_ErrorType>("QueueStatus.ErrorType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for QueueStatus_ErrorType {
}

impl ::std::default::Default for QueueStatus_ErrorType {
    fn default() -> Self {
        QueueStatus_ErrorType::NONE
    }
}

impl ::protobuf::reflect::ProtobufValue for QueueStatus_ErrorType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueueStatuses {
    // message fields
    pub statuses: ::protobuf::RepeatedField<QueueStatus>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueueStatuses {
    fn default() -> &'a QueueStatuses {
        <QueueStatuses as ::protobuf::Message>::default_instance()
    }
}

impl QueueStatuses {
    pub fn new() -> QueueStatuses {
        ::std::default::Default::default()
    }

    // repeated .xenon.QueueStatus statuses = 1;


    pub fn get_statuses(&self) -> &[QueueStatus] {
        &self.statuses
    }
    pub fn clear_statuses(&mut self) {
        self.statuses.clear();
    }

    // Param is passed by value, moved
    pub fn set_statuses(&mut self, v: ::protobuf::RepeatedField<QueueStatus>) {
        self.statuses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_statuses(&mut self) -> &mut ::protobuf::RepeatedField<QueueStatus> {
        &mut self.statuses
    }

    // Take field
    pub fn take_statuses(&mut self) -> ::protobuf::RepeatedField<QueueStatus> {
        ::std::mem::replace(&mut self.statuses, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for QueueStatuses {
    fn is_initialized(&self) -> bool {
        for v in &self.statuses {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.statuses)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.statuses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.statuses {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueueStatuses {
        QueueStatuses::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<QueueStatus>>(
                "statuses",
                |m: &QueueStatuses| { &m.statuses },
                |m: &mut QueueStatuses| { &mut m.statuses },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueueStatuses>(
                "QueueStatuses",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueueStatuses {
        static instance: ::protobuf::rt::LazyV2<QueueStatuses> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueueStatuses::new)
    }
}

impl ::protobuf::Clear for QueueStatuses {
    fn clear(&mut self) {
        self.statuses.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueueStatuses {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueueStatuses {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SubmitInteractiveJobResponse {
    // message fields
    pub job: ::protobuf::SingularPtrField<Job>,
    pub stdout: ::std::vec::Vec<u8>,
    pub stderr: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubmitInteractiveJobResponse {
    fn default() -> &'a SubmitInteractiveJobResponse {
        <SubmitInteractiveJobResponse as ::protobuf::Message>::default_instance()
    }
}

impl SubmitInteractiveJobResponse {
    pub fn new() -> SubmitInteractiveJobResponse {
        ::std::default::Default::default()
    }

    // .xenon.Job job = 1;


    pub fn get_job(&self) -> &Job {
        self.job.as_ref().unwrap_or_else(|| <Job as ::protobuf::Message>::default_instance())
    }
    pub fn clear_job(&mut self) {
        self.job.clear();
    }

    pub fn has_job(&self) -> bool {
        self.job.is_some()
    }

    // Param is passed by value, moved
    pub fn set_job(&mut self, v: Job) {
        self.job = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_job(&mut self) -> &mut Job {
        if self.job.is_none() {
            self.job.set_default();
        }
        self.job.as_mut().unwrap()
    }

    // Take field
    pub fn take_job(&mut self) -> Job {
        self.job.take().unwrap_or_else(|| Job::new())
    }

    // bytes stdout = 2;


    pub fn get_stdout(&self) -> &[u8] {
        &self.stdout
    }
    pub fn clear_stdout(&mut self) {
        self.stdout.clear();
    }

    // Param is passed by value, moved
    pub fn set_stdout(&mut self, v: ::std::vec::Vec<u8>) {
        self.stdout = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stdout(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.stdout
    }

    // Take field
    pub fn take_stdout(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.stdout, ::std::vec::Vec::new())
    }

    // bytes stderr = 3;


    pub fn get_stderr(&self) -> &[u8] {
        &self.stderr
    }
    pub fn clear_stderr(&mut self) {
        self.stderr.clear();
    }

    // Param is passed by value, moved
    pub fn set_stderr(&mut self, v: ::std::vec::Vec<u8>) {
        self.stderr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stderr(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.stderr
    }

    // Take field
    pub fn take_stderr(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.stderr, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for SubmitInteractiveJobResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.job {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.job)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.stdout)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.stderr)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.job.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.stdout.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.stdout);
        }
        if !self.stderr.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.stderr);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.job.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.stdout.is_empty() {
            os.write_bytes(2, &self.stdout)?;
        }
        if !self.stderr.is_empty() {
            os.write_bytes(3, &self.stderr)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubmitInteractiveJobResponse {
        SubmitInteractiveJobResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Job>>(
                "job",
                |m: &SubmitInteractiveJobResponse| { &m.job },
                |m: &mut SubmitInteractiveJobResponse| { &mut m.job },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "stdout",
                |m: &SubmitInteractiveJobResponse| { &m.stdout },
                |m: &mut SubmitInteractiveJobResponse| { &mut m.stdout },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "stderr",
                |m: &SubmitInteractiveJobResponse| { &m.stderr },
                |m: &mut SubmitInteractiveJobResponse| { &mut m.stderr },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SubmitInteractiveJobResponse>(
                "SubmitInteractiveJobResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SubmitInteractiveJobResponse {
        static instance: ::protobuf::rt::LazyV2<SubmitInteractiveJobResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SubmitInteractiveJobResponse::new)
    }
}

impl ::protobuf::Clear for SubmitInteractiveJobResponse {
    fn clear(&mut self) {
        self.job.clear();
        self.stdout.clear();
        self.stderr.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SubmitInteractiveJobResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubmitInteractiveJobResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Is {
    // message fields
    pub value: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Is {
    fn default() -> &'a Is {
        <Is as ::protobuf::Message>::default_instance()
    }
}

impl Is {
    pub fn new() -> Is {
        ::std::default::Default::default()
    }

    // bool value = 1;


    pub fn get_value(&self) -> bool {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = false;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: bool) {
        self.value = v;
    }
}

impl ::protobuf::Message for Is {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.value = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.value != false {
            os.write_bool(1, self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Is {
        Is::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "value",
                |m: &Is| { &m.value },
                |m: &mut Is| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Is>(
                "Is",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Is {
        static instance: ::protobuf::rt::LazyV2<Is> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Is::new)
    }
}

impl ::protobuf::Clear for Is {
    fn clear(&mut self) {
        self.value = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Is {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Is {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetDefaultRuntimeResponse {
    // message fields
    pub value: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetDefaultRuntimeResponse {
    fn default() -> &'a GetDefaultRuntimeResponse {
        <GetDefaultRuntimeResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetDefaultRuntimeResponse {
    pub fn new() -> GetDefaultRuntimeResponse {
        ::std::default::Default::default()
    }

    // uint32 value = 1;


    pub fn get_value(&self) -> u32 {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = 0;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: u32) {
        self.value = v;
    }
}

impl ::protobuf::Message for GetDefaultRuntimeResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.value = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != 0 {
            my_size += ::protobuf::rt::value_size(1, self.value, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.value != 0 {
            os.write_uint32(1, self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetDefaultRuntimeResponse {
        GetDefaultRuntimeResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "value",
                |m: &GetDefaultRuntimeResponse| { &m.value },
                |m: &mut GetDefaultRuntimeResponse| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetDefaultRuntimeResponse>(
                "GetDefaultRuntimeResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetDefaultRuntimeResponse {
        static instance: ::protobuf::rt::LazyV2<GetDefaultRuntimeResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetDefaultRuntimeResponse::new)
    }
}

impl ::protobuf::Clear for GetDefaultRuntimeResponse {
    fn clear(&mut self) {
        self.value = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDefaultRuntimeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDefaultRuntimeResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PosixFilePermission {
    NONE = 0,
    OWNER_READ = 1,
    OWNER_WRITE = 2,
    OWNER_EXECUTE = 3,
    GROUP_READ = 4,
    GROUP_WRITE = 5,
    GROUP_EXECUTE = 6,
    OTHERS_READ = 7,
    OTHERS_WRITE = 8,
    OTHERS_EXECUTE = 9,
}

impl ::protobuf::ProtobufEnum for PosixFilePermission {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PosixFilePermission> {
        match value {
            0 => ::std::option::Option::Some(PosixFilePermission::NONE),
            1 => ::std::option::Option::Some(PosixFilePermission::OWNER_READ),
            2 => ::std::option::Option::Some(PosixFilePermission::OWNER_WRITE),
            3 => ::std::option::Option::Some(PosixFilePermission::OWNER_EXECUTE),
            4 => ::std::option::Option::Some(PosixFilePermission::GROUP_READ),
            5 => ::std::option::Option::Some(PosixFilePermission::GROUP_WRITE),
            6 => ::std::option::Option::Some(PosixFilePermission::GROUP_EXECUTE),
            7 => ::std::option::Option::Some(PosixFilePermission::OTHERS_READ),
            8 => ::std::option::Option::Some(PosixFilePermission::OTHERS_WRITE),
            9 => ::std::option::Option::Some(PosixFilePermission::OTHERS_EXECUTE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PosixFilePermission] = &[
            PosixFilePermission::NONE,
            PosixFilePermission::OWNER_READ,
            PosixFilePermission::OWNER_WRITE,
            PosixFilePermission::OWNER_EXECUTE,
            PosixFilePermission::GROUP_READ,
            PosixFilePermission::GROUP_WRITE,
            PosixFilePermission::GROUP_EXECUTE,
            PosixFilePermission::OTHERS_READ,
            PosixFilePermission::OTHERS_WRITE,
            PosixFilePermission::OTHERS_EXECUTE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<PosixFilePermission>("PosixFilePermission", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for PosixFilePermission {
}

impl ::std::default::Default for PosixFilePermission {
    fn default() -> Self {
        PosixFilePermission::NONE
    }
}

impl ::protobuf::reflect::ProtobufValue for PosixFilePermission {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0bxenon.proto\x12\x05xenon\"\x07\n\x05Empty\"\x8e\x01\n\nProperties\
    \x12A\n\nproperties\x18\x01\x20\x03(\x0b2!.xenon.Properties.PropertiesEn\
    tryR\nproperties\x1a=\n\x0fPropertiesEntry\x12\x10\n\x03key\x18\x01\x20\
    \x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\
    \x01\"\x80\x02\n\x13PropertyDescription\x12\x12\n\x04name\x18\x01\x20\
    \x01(\tR\x04name\x12\x20\n\x0bdescription\x18\x02\x20\x01(\tR\x0bdescrip\
    tion\x12#\n\rdefault_value\x18\x03\x20\x01(\tR\x0cdefaultValue\x123\n\
    \x04type\x18\x04\x20\x01(\x0e2\x1f.xenon.PropertyDescription.TypeR\x04ty\
    pe\"Y\n\x04Type\x12\n\n\x06STRING\x10\0\x12\x0b\n\x07BOOLEAN\x10\x01\x12\
    \x0b\n\x07INTEGER\x10\x02\x12\n\n\x06DOUBLE\x10\x03\x12\x08\n\x04LONG\
    \x10\x04\x12\x08\n\x04SIZE\x10\x05\x12\x0b\n\x07NATURAL\x10\x06\"R\n\x14\
    PropertyDescriptions\x12:\n\nproperties\x18\x01\x20\x03(\x0b2\x1a.xenon.\
    PropertyDescriptionR\nproperties\"\xad\x03\n\x1bSchedulerAdaptorDescript\
    ion\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x20\n\x0bdescripti\
    on\x18\x02\x20\x01(\tR\x0bdescription\x12/\n\x13supported_locations\x18\
    \x03\x20\x03(\tR\x12supportedLocations\x12M\n\x14supported_properties\
    \x18\x04\x20\x03(\x0b2\x1a.xenon.PropertyDescriptionR\x13supportedProper\
    ties\x12\x1f\n\x0bis_embedded\x18\x05\x20\x01(\x08R\nisEmbedded\x121\n\
    \x14supports_interactive\x18\x06\x20\x01(\x08R\x13supportsInteractive\
    \x12%\n\x0esupports_batch\x18\x07\x20\x01(\x08R\rsupportsBatch\x12(\n\
    \x10uses_file_system\x18\x08\x20\x01(\x08R\x0eusesFileSystem\x123\n\x15s\
    upported_credentials\x18\t\x20\x03(\tR\x14supportedCredentials\"f\n\x1cS\
    chedulerAdaptorDescriptions\x12F\n\x0cdescriptions\x18\x01\x20\x03(\x0b2\
    \".xenon.SchedulerAdaptorDescriptionR\x0cdescriptions\"\xf7\x05\n\x1cFil\
    eSystemAdaptorDescription\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\
    \x12\x20\n\x0bdescription\x18\x02\x20\x01(\tR\x0bdescription\x12/\n\x13s\
    upported_locations\x18\x03\x20\x03(\tR\x12supportedLocations\x12M\n\x14s\
    upported_properties\x18\x04\x20\x03(\x0b2\x1a.xenon.PropertyDescriptionR\
    \x13supportedProperties\x129\n\x19supports_third_party_copy\x18\x05\x20\
    \x01(\x08R\x16supportsThirdPartyCopy\x128\n\x18can_create_symboliclinks\
    \x18\x06\x20\x01(\x08R\x16canCreateSymboliclinks\x124\n\x16can_read_symb\
    oliclinks\x18\x07\x20\x01(\x08R\x14canReadSymboliclinks\x12+\n\x11is_con\
    nectionless\x18\x08\x20\x01(\x08R\x10isConnectionless\x123\n\x15supporte\
    d_credentials\x18\t\x20\x03(\tR\x14supportedCredentials\x12K\n\"supports\
    _reading_posix_permissions\x18\n\x20\x01(\x08R\x1fsupportsReadingPosixPe\
    rmissions\x12K\n\"supports_setting_posix_permissions\x18\x0b\x20\x01(\
    \x08R\x1fsupportsSettingPosixPermissions\x12'\n\x0fsupports_rename\x18\
    \x0c\x20\x01(\x08R\x0esupportsRename\x12\x1d\n\ncan_append\x18\r\x20\x01\
    (\x08R\tcanAppend\x122\n\x15needs_size_beforehand\x18\x0e\x20\x01(\x08R\
    \x13needsSizeBeforehand\"h\n\x1dFileSystemAdaptorDescriptions\x12G\n\x0c\
    descriptions\x18\x01\x20\x03(\x0b2#.xenon.FileSystemAdaptorDescriptionR\
    \x0cdescriptions\"!\n\x0bAdaptorName\x12\x12\n\x04name\x18\x01\x20\x01(\
    \tR\x04name\"\"\n\x0cAdaptorNames\x12\x12\n\x04name\x18\x01\x20\x03(\tR\
    \x04name\"o\n\x15CertificateCredential\x12\x1a\n\x08certfile\x18\x01\x20\
    \x01(\tR\x08certfile\x12\x1e\n\npassphrase\x18\x02\x20\x01(\tR\npassphra\
    se\x12\x1a\n\x08username\x18\x03\x20\x01(\tR\x08username\"L\n\x12Passwor\
    dCredential\x12\x1a\n\x08username\x18\x01\x20\x01(\tR\x08username\x12\
    \x1a\n\x08password\x18\x02\x20\x01(\tR\x08password\"/\n\x11DefaultCreden\
    tial\x12\x1a\n\x08username\x18\x01\x20\x01(\tR\x08username\"N\n\x10Keyta\
    bCredential\x12\x1a\n\x08username\x18\x01\x20\x01(\tR\x08username\x12\
    \x1e\n\nkeytabfile\x18\x02\x20\x01(\tR\nkeytabfile\"\xd1\x02\n\x0eUserCr\
    edential\x12U\n\x16certificate_credential\x18\x01\x20\x01(\x0b2\x1c.xeno\
    n.CertificateCredentialH\0R\x15certificateCredential\x12L\n\x13password_\
    credential\x18\x02\x20\x01(\x0b2\x19.xenon.PasswordCredentialH\0R\x12pas\
    swordCredential\x12I\n\x12default_credential\x18\x03\x20\x01(\x0b2\x18.x\
    enon.DefaultCredentialH\0R\x11defaultCredential\x12F\n\x11keytab_credent\
    ial\x18\x04\x20\x01(\x0b2\x17.xenon.KeytabCredentialH\0R\x10keytabCreden\
    tialB\x07\n\x05entry\"\xe3\x03\n\rCredentialMap\x12;\n\x07entries\x18\
    \x01\x20\x03(\x0b2!.xenon.CredentialMap.EntriesEntryR\x07entries\x12U\n\
    \x16certificate_credential\x18\x02\x20\x01(\x0b2\x1c.xenon.CertificateCr\
    edentialH\0R\x15certificateCredential\x12L\n\x13password_credential\x18\
    \x03\x20\x01(\x0b2\x19.xenon.PasswordCredentialH\0R\x12passwordCredentia\
    l\x12I\n\x12default_credential\x18\x04\x20\x01(\x0b2\x18.xenon.DefaultCr\
    edentialH\0R\x11defaultCredential\x12F\n\x11keytab_credential\x18\x05\
    \x20\x01(\x0b2\x17.xenon.KeytabCredentialH\0R\x10keytabCredential\x1aQ\n\
    \x0cEntriesEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12+\n\x05v\
    alue\x18\x02\x20\x01(\x0b2\x15.xenon.UserCredentialR\x05value:\x028\x01B\
    \n\n\x08fallback\"&\n\x08Location\x12\x1a\n\x08location\x18\x01\x20\x01(\
    \tR\x08location\"\x9c\x03\n\x15GetCredentialResponse\x12U\n\x16certifica\
    te_credential\x18\x04\x20\x01(\x0b2\x1c.xenon.CertificateCredentialH\0R\
    \x15certificateCredential\x12L\n\x13password_credential\x18\x05\x20\x01(\
    \x0b2\x19.xenon.PasswordCredentialH\0R\x12passwordCredential\x12I\n\x12d\
    efault_credential\x18\x06\x20\x01(\x0b2\x18.xenon.DefaultCredentialH\0R\
    \x11defaultCredential\x12=\n\x0ecredential_map\x18\x07\x20\x01(\x0b2\x14\
    .xenon.CredentialMapH\0R\rcredentialMap\x12F\n\x11keytab_credential\x18\
    \x08\x20\x01(\x0b2\x17.xenon.KeytabCredentialH\0R\x10keytabCredentialB\
    \x0c\n\ncredential\"\xe3\x04\n\x17CreateFileSystemRequest\x12\x18\n\x07a\
    daptor\x18\x01\x20\x01(\tR\x07adaptor\x12\x1a\n\x08location\x18\x02\x20\
    \x01(\tR\x08location\x12N\n\nproperties\x18\x03\x20\x03(\x0b2..xenon.Cre\
    ateFileSystemRequest.PropertiesEntryR\nproperties\x12U\n\x16certificate_\
    credential\x18\x04\x20\x01(\x0b2\x1c.xenon.CertificateCredentialH\0R\x15\
    certificateCredential\x12L\n\x13password_credential\x18\x05\x20\x01(\x0b\
    2\x19.xenon.PasswordCredentialH\0R\x12passwordCredential\x12I\n\x12defau\
    lt_credential\x18\x06\x20\x01(\x0b2\x18.xenon.DefaultCredentialH\0R\x11d\
    efaultCredential\x12=\n\x0ecredential_map\x18\x07\x20\x01(\x0b2\x14.xeno\
    n.CredentialMapH\0R\rcredentialMap\x12F\n\x11keytab_credential\x18\x08\
    \x20\x01(\x0b2\x17.xenon.KeytabCredentialH\0R\x10keytabCredential\x1a=\n\
    \x0fPropertiesEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\
    \n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01B\x0c\n\ncredential\"\
    \x1c\n\nFileSystem\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\"B\n\x0bFil\
    eSystems\x123\n\x0bfilesystems\x18\x01\x20\x03(\x0b2\x11.xenon.FileSyste\
    mR\x0bfilesystems\"8\n\x04Path\x12\x12\n\x04path\x18\x01\x20\x01(\tR\x04\
    path\x12\x1c\n\tseparator\x18\x02\x20\x01(\tR\tseparator\"a\n\x0bPathReq\
    uest\x121\n\nfilesystem\x18\x01\x20\x01(\x0b2\x11.xenon.FileSystemR\nfil\
    esystem\x12\x1f\n\x04path\x18\x02\x20\x01(\x0b2\x0b.xenon.PathR\x04path\
    \"\x81\x01\n\rDeleteRequest\x121\n\nfilesystem\x18\x01\x20\x01(\x0b2\x11\
    .xenon.FileSystemR\nfilesystem\x12\x1f\n\x04path\x18\x02\x20\x01(\x0b2\
    \x0b.xenon.PathR\x04path\x12\x1c\n\trecursive\x18\x03\x20\x01(\x08R\trec\
    ursive\"\xde\x02\n\x0bCopyRequest\x121\n\nfilesystem\x18\x01\x20\x01(\
    \x0b2\x11.xenon.FileSystemR\nfilesystem\x12#\n\x06source\x18\x02\x20\x01\
    (\x0b2\x0b.xenon.PathR\x06source\x12H\n\x16destination_filesystem\x18\
    \x03\x20\x01(\x0b2\x11.xenon.FileSystemR\x15destinationFilesystem\x12-\n\
    \x0bdestination\x18\x04\x20\x01(\x0b2\x0b.xenon.PathR\x0bdestination\x12\
    /\n\x04mode\x18\x05\x20\x01(\x0e2\x1b.xenon.CopyRequest.CopyModeR\x04mod\
    e\x12\x1c\n\trecursive\x18\x06\x20\x01(\x08R\trecursive\"/\n\x08CopyMode\
    \x12\n\n\x06CREATE\x10\0\x12\x0b\n\x07REPLACE\x10\x01\x12\n\n\x06IGNORE\
    \x10\x02\"\x8c\x01\n\rRenameRequest\x121\n\nfilesystem\x18\x01\x20\x01(\
    \x0b2\x11.xenon.FileSystemR\nfilesystem\x12#\n\x06source\x18\x02\x20\x01\
    (\x0b2\x0b.xenon.PathR\x06source\x12#\n\x06target\x18\x03\x20\x01(\x0b2\
    \x0b.xenon.PathR\x06target\"\x94\x01\n\x19CreateSymbolicLinkRequest\x121\
    \n\nfilesystem\x18\x01\x20\x01(\x0b2\x11.xenon.FileSystemR\nfilesystem\
    \x12\x1f\n\x04link\x18\x02\x20\x01(\x0b2\x0b.xenon.PathR\x04link\x12#\n\
    \x06target\x18\x03\x20\x01(\x0b2\x0b.xenon.PathR\x06target\"\x1f\n\rCopy\
    Operation\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\"\x86\x01\n\x14CopyO\
    perationRequest\x121\n\nfilesystem\x18\x01\x20\x01(\x0b2\x11.xenon.FileS\
    ystemR\nfilesystem\x12;\n\x0ecopy_operation\x18\x02\x20\x01(\x0b2\x14.xe\
    non.CopyOperationR\rcopyOperation\"\xa0\x01\n\x14WaitUntilDoneRequest\
    \x121\n\nfilesystem\x18\x01\x20\x01(\x0b2\x11.xenon.FileSystemR\nfilesys\
    tem\x12;\n\x0ecopy_operation\x18\x02\x20\x01(\x0b2\x14.xenon.CopyOperati\
    onR\rcopyOperation\x12\x18\n\x07timeout\x18\x03\x20\x01(\x04R\x07timeout\
    \"\x9c\x03\n\nCopyStatus\x12;\n\x0ecopy_operation\x18\x01\x20\x01(\x0b2\
    \x14.xenon.CopyOperationR\rcopyOperation\x12!\n\x0cbytes_copied\x18\x02\
    \x20\x01(\x04R\x0bbytesCopied\x12\"\n\rbytes_to_copy\x18\x03\x20\x01(\
    \x04R\x0bbytesToCopy\x12\x12\n\x04done\x18\x04\x20\x01(\x08R\x04done\x12\
    \x18\n\x07running\x18\x05\x20\x01(\x08R\x07running\x12\x14\n\x05state\
    \x18\x06\x20\x01(\tR\x05state\x12#\n\rerror_message\x18\x07\x20\x01(\tR\
    \x0cerrorMessage\x12:\n\nerror_type\x18\x08\x20\x01(\x0e2\x1b.xenon.Copy\
    Status.ErrorTypeR\terrorType\"e\n\tErrorType\x12\x08\n\x04NONE\x10\0\x12\
    \r\n\tNOT_FOUND\x10\x01\x12\r\n\tCANCELLED\x10\x02\x12\x12\n\x0eALREADY_\
    EXISTS\x10\x03\x12\x11\n\rNOT_CONNECTED\x10\x04\x12\t\n\x05XENON\x10\x05\
    \"\xb7\x04\n\x0ePathAttributes\x12\x1f\n\x04path\x18\x01\x20\x01(\x0b2\
    \x0b.xenon.PathR\x04path\x12#\n\rcreation_time\x18\x02\x20\x01(\x04R\x0c\
    creationTime\x12\x14\n\x05group\x18\x03\x20\x01(\tR\x05group\x12!\n\x0ci\
    s_directory\x18\x04\x20\x01(\x08R\x0bisDirectory\x12#\n\ris_executable\
    \x18\x05\x20\x01(\x08R\x0cisExecutable\x12\x1b\n\tis_hidden\x18\x06\x20\
    \x01(\x08R\x08isHidden\x12\x19\n\x08is_other\x18\x07\x20\x01(\x08R\x07is\
    Other\x12\x1f\n\x0bis_readable\x18\x08\x20\x01(\x08R\nisReadable\x12\x1d\
    \n\nis_regular\x18\t\x20\x01(\x08R\tisRegular\x12(\n\x10is_symbolic_link\
    \x18\n\x20\x01(\x08R\x0eisSymbolicLink\x12\x1f\n\x0bis_writable\x18\x0b\
    \x20\x01(\x08R\nisWritable\x12(\n\x10last_access_time\x18\x0c\x20\x01(\
    \x04R\x0elastAccessTime\x12,\n\x12last_modified_time\x18\r\x20\x01(\x04R\
    \x10lastModifiedTime\x12\x14\n\x05owner\x18\x0e\x20\x01(\tR\x05owner\x12\
    <\n\x0bpermissions\x18\x0f\x20\x03(\x0e2\x1a.xenon.PosixFilePermissionR\
    \x0bpermissions\x12\x12\n\x04size\x18\x10\x20\x01(\x04R\x04size\"\xb2\
    \x01\n\x1eSetPosixFilePermissionsRequest\x121\n\nfilesystem\x18\x01\x20\
    \x01(\x0b2\x11.xenon.FileSystemR\nfilesystem\x12\x1f\n\x04path\x18\x02\
    \x20\x01(\x0b2\x0b.xenon.PathR\x04path\x12<\n\x0bpermissions\x18\x03\x20\
    \x03(\x0e2\x1a.xenon.PosixFilePermissionR\x0bpermissions\".\n\x14ReadFro\
    mFileResponse\x12\x16\n\x06buffer\x18\x01\x20\x01(\x0cR\x06buffer\"\x94\
    \x01\n\x12WriteToFileRequest\x121\n\nfilesystem\x18\x01\x20\x01(\x0b2\
    \x11.xenon.FileSystemR\nfilesystem\x12\x1f\n\x04path\x18\x02\x20\x01(\
    \x0b2\x0b.xenon.PathR\x04path\x12\x16\n\x06buffer\x18\x03\x20\x01(\x0cR\
    \x06buffer\x12\x12\n\x04size\x18\x04\x20\x01(\x04R\x04size\"\x81\x01\n\
    \x13AppendToFileRequest\x121\n\nfilesystem\x18\x01\x20\x01(\x0b2\x11.xen\
    on.FileSystemR\nfilesystem\x12\x1f\n\x04path\x18\x02\x20\x01(\x0b2\x0b.x\
    enon.PathR\x04path\x12\x16\n\x06buffer\x18\x03\x20\x01(\x0cR\x06buffer\"\
    }\n\x0bListRequest\x121\n\nfilesystem\x18\x01\x20\x01(\x0b2\x11.xenon.Fi\
    leSystemR\nfilesystem\x12\x1d\n\x03dir\x18\x02\x20\x01(\x0b2\x0b.xenon.P\
    athR\x03dir\x12\x1c\n\trecursive\x18\x03\x20\x01(\x08R\trecursive\"8\n\
    \x18GetPathSeparatorResponse\x12\x1c\n\tseparator\x18\x01\x20\x01(\tR\ts\
    eparator\"\xe1\x04\n\x16CreateSchedulerRequest\x12\x18\n\x07adaptor\x18\
    \x01\x20\x01(\tR\x07adaptor\x12\x1a\n\x08location\x18\x02\x20\x01(\tR\
    \x08location\x12M\n\nproperties\x18\x03\x20\x03(\x0b2-.xenon.CreateSched\
    ulerRequest.PropertiesEntryR\nproperties\x12U\n\x16certificate_credentia\
    l\x18\x04\x20\x01(\x0b2\x1c.xenon.CertificateCredentialH\0R\x15certifica\
    teCredential\x12L\n\x13password_credential\x18\x05\x20\x01(\x0b2\x19.xen\
    on.PasswordCredentialH\0R\x12passwordCredential\x12I\n\x12default_creden\
    tial\x18\x06\x20\x01(\x0b2\x18.xenon.DefaultCredentialH\0R\x11defaultCre\
    dential\x12=\n\x0ecredential_map\x18\x07\x20\x01(\x0b2\x14.xenon.Credent\
    ialMapH\0R\rcredentialMap\x12F\n\x11keytab_credential\x18\x08\x20\x01(\
    \x0b2\x17.xenon.KeytabCredentialH\0R\x10keytabCredential\x1a=\n\x0fPrope\
    rtiesEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05valu\
    e\x18\x02\x20\x01(\tR\x05value:\x028\x01B\x0c\n\ncredential\"\x1b\n\tSch\
    eduler\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\">\n\nSchedulers\x120\n\
    \nschedulers\x18\x01\x20\x03(\x0b2\x10.xenon.SchedulerR\nschedulers\"\
    \xb5\x05\n\x0eJobDescription\x12\x1e\n\nexecutable\x18\x01\x20\x01(\tR\n\
    executable\x12\x1c\n\targuments\x18\x02\x20\x03(\tR\targuments\x12+\n\
    \x11working_directory\x18\x03\x20\x01(\tR\x10workingDirectory\x12H\n\x0b\
    environment\x18\x04\x20\x03(\x0b2&.xenon.JobDescription.EnvironmentEntry\
    R\x0benvironment\x12\x1d\n\nqueue_name\x18\x05\x20\x01(\tR\tqueueName\
    \x12\x1f\n\x0bmax_runtime\x18\x06\x20\x01(\rR\nmaxRuntime\x12\x16\n\x06s\
    tderr\x18\n\x20\x01(\tR\x06stderr\x12\x14\n\x05stdin\x18\x0b\x20\x01(\tR\
    \x05stdin\x12\x16\n\x06stdout\x18\x0c\x20\x01(\tR\x06stdout\x12\x12\n\
    \x04name\x18\x0e\x20\x01(\tR\x04name\x12\x1d\n\nmax_memory\x18\x0f\x20\
    \x01(\rR\tmaxMemory\x12/\n\x13scheduler_arguments\x18\x10\x20\x03(\tR\
    \x12schedulerArguments\x12\x14\n\x05tasks\x18\x11\x20\x01(\rR\x05tasks\
    \x12$\n\x0ecores_per_task\x18\x12\x20\x01(\rR\x0ccoresPerTask\x12$\n\x0e\
    tasks_per_node\x18\x13\x20\x01(\rR\x0ctasksPerNode\x12$\n\x0estart_per_t\
    ask\x18\x14\x20\x01(\x08R\x0cstartPerTask\x12\x1d\n\nstart_time\x18\x15\
    \x20\x01(\tR\tstartTime\x12\x1d\n\ntemp_space\x18\x16\x20\x01(\rR\ttempS\
    pace\x1a>\n\x10EnvironmentEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03\
    key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\"\x80\x01\
    \n\x15SubmitBatchJobRequest\x12.\n\tscheduler\x18\x01\x20\x01(\x0b2\x10.\
    xenon.SchedulerR\tscheduler\x127\n\x0bdescription\x18\x02\x20\x01(\x0b2\
    \x15.xenon.JobDescriptionR\x0bdescription\"\x9c\x01\n\x1bSubmitInteracti\
    veJobRequest\x12.\n\tscheduler\x18\x01\x20\x01(\x0b2\x10.xenon.Scheduler\
    R\tscheduler\x127\n\x0bdescription\x18\x02\x20\x01(\x0b2\x15.xenon.JobDe\
    scriptionR\x0bdescription\x12\x14\n\x05stdin\x18\x03\x20\x01(\x0cR\x05st\
    din\"\x15\n\x03Job\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\"Z\n\nJobRe\
    quest\x12.\n\tscheduler\x18\x01\x20\x01(\x0b2\x10.xenon.SchedulerR\tsche\
    duler\x12\x1c\n\x03job\x18\x02\x20\x01(\x0b2\n.xenon.JobR\x03job\"&\n\
    \x04Jobs\x12\x1e\n\x04jobs\x18\x02\x20\x03(\x0b2\n.xenon.JobR\x04jobs\"g\
    \n\x15GetJobStatusesRequest\x12.\n\tscheduler\x18\x01\x20\x01(\x0b2\x10.\
    xenon.SchedulerR\tscheduler\x12\x1e\n\x04jobs\x18\x02\x20\x03(\x0b2\n.xe\
    non.JobR\x04jobs\"u\n\x0bWaitRequest\x12.\n\tscheduler\x18\x01\x20\x01(\
    \x0b2\x10.xenon.SchedulerR\tscheduler\x12\x1c\n\x03job\x18\x02\x20\x01(\
    \x0b2\n.xenon.JobR\x03job\x12\x18\n\x07timeout\x18\x03\x20\x01(\x04R\x07\
    timeout\"\x1b\n\x05Queue\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\"\
    \x1c\n\x06Queues\x12\x12\n\x04name\x18\x01\x20\x03(\tR\x04name\"\\\n\x12\
    SchedulerAndQueues\x12.\n\tscheduler\x18\x01\x20\x01(\x0b2\x10.xenon.Sch\
    edulerR\tscheduler\x12\x16\n\x06queues\x18\x02\x20\x03(\tR\x06queues\"]\
    \n\x15GetQueueStatusRequest\x12.\n\tscheduler\x18\x01\x20\x01(\x0b2\x10.\
    xenon.SchedulerR\tscheduler\x12\x14\n\x05queue\x18\x02\x20\x01(\tR\x05qu\
    eue\"\xaf\x04\n\tJobStatus\x12\x1c\n\x03job\x18\x01\x20\x01(\x0b2\n.xeno\
    n.JobR\x03job\x12\x14\n\x05state\x18\x02\x20\x01(\tR\x05state\x12\x18\n\
    \x07running\x18\x03\x20\x01(\x08R\x07running\x12\x12\n\x04done\x18\x04\
    \x20\x01(\x08R\x04done\x12x\n\x1escheduler_specific_information\x18\x05\
    \x20\x03(\x0b22.xenon.JobStatus.SchedulerSpecificInformationEntryR\x1csc\
    hedulerSpecificInformation\x12\x1b\n\texit_code\x18\x06\x20\x01(\x05R\
    \x08exitCode\x12#\n\rerror_message\x18\x07\x20\x01(\tR\x0cerrorMessage\
    \x129\n\nerror_type\x18\x08\x20\x01(\x0e2\x1a.xenon.JobStatus.ErrorTypeR\
    \terrorType\x12\x12\n\x04name\x18\t\x20\x01(\tR\x04name\x1aO\n!Scheduler\
    SpecificInformationEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\
    \x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\"d\n\tErrorType\
    \x12\x08\n\x04NONE\x10\0\x12\r\n\tNOT_FOUND\x10\x01\x12\r\n\tCANCELLED\
    \x10\x02\x12\x11\n\rNOT_CONNECTED\x10\x03\x12\t\n\x05XENON\x10\x04\x12\
    \x06\n\x02IO\x10\x05\x12\t\n\x05OTHER\x10\x06\"F\n\x16GetJobStatusesResp\
    onse\x12,\n\x08statuses\x18\x01\x20\x03(\x0b2\x10.xenon.JobStatusR\x08st\
    atuses\"\xa7\x03\n\x0bQueueStatus\x12\x12\n\x04name\x18\x01\x20\x01(\tR\
    \x04name\x12z\n\x1escheduler_specific_information\x18\x02\x20\x03(\x0b24\
    .xenon.QueueStatus.SchedulerSpecificInformationEntryR\x1cschedulerSpecif\
    icInformation\x12#\n\rerror_message\x18\x03\x20\x01(\tR\x0cerrorMessage\
    \x12;\n\nerror_type\x18\x04\x20\x01(\x0e2\x1c.xenon.QueueStatus.ErrorTyp\
    eR\terrorType\x1aO\n!SchedulerSpecificInformationEntry\x12\x10\n\x03key\
    \x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05va\
    lue:\x028\x01\"U\n\tErrorType\x12\x08\n\x04NONE\x10\0\x12\r\n\tNOT_FOUND\
    \x10\x01\x12\x11\n\rNOT_CONNECTED\x10\x02\x12\t\n\x05XENON\x10\x03\x12\
    \x06\n\x02IO\x10\x04\x12\t\n\x05OTHER\x10\x05\"?\n\rQueueStatuses\x12.\n\
    \x08statuses\x18\x01\x20\x03(\x0b2\x12.xenon.QueueStatusR\x08statuses\"l\
    \n\x1cSubmitInteractiveJobResponse\x12\x1c\n\x03job\x18\x01\x20\x01(\x0b\
    2\n.xenon.JobR\x03job\x12\x16\n\x06stdout\x18\x02\x20\x01(\x0cR\x06stdou\
    t\x12\x16\n\x06stderr\x18\x03\x20\x01(\x0cR\x06stderr\"\x1a\n\x02Is\x12\
    \x14\n\x05value\x18\x01\x20\x01(\x08R\x05value\"1\n\x19GetDefaultRuntime\
    Response\x12\x14\n\x05value\x18\x01\x20\x01(\rR\x05value*\xbe\x01\n\x13P\
    osixFilePermission\x12\x08\n\x04NONE\x10\0\x12\x0e\n\nOWNER_READ\x10\x01\
    \x12\x0f\n\x0bOWNER_WRITE\x10\x02\x12\x11\n\rOWNER_EXECUTE\x10\x03\x12\
    \x0e\n\nGROUP_READ\x10\x04\x12\x0f\n\x0bGROUP_WRITE\x10\x05\x12\x11\n\rG\
    ROUP_EXECUTE\x10\x06\x12\x0f\n\x0bOTHERS_READ\x10\x07\x12\x10\n\x0cOTHER\
    S_WRITE\x10\x08\x12\x12\n\x0eOTHERS_EXECUTE\x10\t2\xc2\x0f\n\x11FileSyst\
    emService\x12N\n\x16getAdaptorDescriptions\x12\x0c.xenon.Empty\x1a$.xeno\
    n.FileSystemAdaptorDescriptions\"\0\x126\n\x0fgetAdaptorNames\x12\x0c.xe\
    non.Empty\x1a\x13.xenon.AdaptorNames\"\0\x12R\n\x15getAdaptorDescription\
    \x12\x12.xenon.AdaptorName\x1a#.xenon.FileSystemAdaptorDescription\"\0\
    \x12=\n\x06create\x12\x1e.xenon.CreateFileSystemRequest\x1a\x11.xenon.Fi\
    leSystem\"\0\x129\n\x0egetAdaptorName\x12\x11.xenon.FileSystem\x1a\x12.x\
    enon.AdaptorName\"\0\x123\n\x0bgetLocation\x12\x11.xenon.FileSystem\x1a\
    \x0f.xenon.Location\"\0\x12B\n\rgetCredential\x12\x11.xenon.FileSystem\
    \x1a\x1c.xenon.GetCredentialResponse\"\0\x127\n\rgetProperties\x12\x11.x\
    enon.FileSystem\x1a\x11.xenon.Properties\"\0\x127\n\x11createDirectories\
    \x12\x12.xenon.PathRequest\x1a\x0c.xenon.Empty\"\0\x125\n\x0fcreateDirec\
    tory\x12\x12.xenon.PathRequest\x1a\x0c.xenon.Empty\"\0\x120\n\ncreateFil\
    e\x12\x12.xenon.PathRequest\x1a\x0c.xenon.Empty\"\0\x12F\n\x12createSymb\
    olicLink\x12\x20.xenon.CreateSymbolicLinkRequest\x1a\x0c.xenon.Empty\"\0\
    \x122\n\x04copy\x12\x12.xenon.CopyRequest\x1a\x14.xenon.CopyOperation\"\
    \0\x12:\n\x06cancel\x12\x1b.xenon.CopyOperationRequest\x1a\x11.xenon.Cop\
    yStatus\"\0\x12=\n\tgetStatus\x12\x1b.xenon.CopyOperationRequest\x1a\x11\
    .xenon.CopyStatus\"\0\x12.\n\x06rename\x12\x14.xenon.RenameRequest\x1a\
    \x0c.xenon.Empty\"\0\x12.\n\x06delete\x12\x14.xenon.DeleteRequest\x1a\
    \x0c.xenon.Empty\"\0\x12)\n\x06exists\x12\x12.xenon.PathRequest\x1a\t.xe\
    non.Is\"\0\x12C\n\x0creadFromFile\x12\x12.xenon.PathRequest\x1a\x1b.xeno\
    n.ReadFromFileResponse\"\00\x01\x12:\n\x0bwriteToFile\x12\x19.xenon.Writ\
    eToFileRequest\x1a\x0c.xenon.Empty\"\0(\x01\x12<\n\x0cappendToFile\x12\
    \x1a.xenon.AppendToFileRequest\x1a\x0c.xenon.Empty\"\0(\x01\x125\n\x04li\
    st\x12\x12.xenon.ListRequest\x1a\x15.xenon.PathAttributes\"\00\x01\x12<\
    \n\rgetAttributes\x12\x12.xenon.PathRequest\x1a\x15.xenon.PathAttributes\
    \"\0\x127\n\x13getWorkingDirectory\x12\x11.xenon.FileSystem\x1a\x0b.xeno\
    n.Path\"\0\x129\n\x13setWorkingDirectory\x12\x12.xenon.PathRequest\x1a\
    \x0c.xenon.Empty\"\0\x12P\n\x17setPosixFilePermissions\x12%.xenon.SetPos\
    ixFilePermissionsRequest\x1a\x0c.xenon.Empty\"\0\x125\n\x10readSymbolicL\
    ink\x12\x12.xenon.PathRequest\x1a\x0b.xenon.Path\"\0\x12H\n\x10getPathSe\
    parator\x12\x11.xenon.FileSystem\x1a\x1f.xenon.GetPathSeparatorResponse\
    \"\0\x12(\n\x06isOpen\x12\x11.xenon.FileSystem\x1a\t.xenon.Is\"\0\x12*\n\
    \x05close\x12\x11.xenon.FileSystem\x1a\x0c.xenon.Empty\"\0\x12A\n\rwaitU\
    ntilDone\x12\x1b.xenon.WaitUntilDoneRequest\x1a\x11.xenon.CopyStatus\"\0\
    \x126\n\x10localFileSystems\x12\x0c.xenon.Empty\x1a\x12.xenon.FileSystem\
    s\"\0\x125\n\x0flistFileSystems\x12\x0c.xenon.Empty\x1a\x12.xenon.FileSy\
    stems\"\02\xd7\x0c\n\x10SchedulerService\x12M\n\x16getAdaptorDescription\
    s\x12\x0c.xenon.Empty\x1a#.xenon.SchedulerAdaptorDescriptions\"\0\x126\n\
    \x0fgetAdaptorNames\x12\x0c.xenon.Empty\x1a\x13.xenon.AdaptorNames\"\0\
    \x12Q\n\x15getAdaptorDescription\x12\x12.xenon.AdaptorName\x1a\".xenon.S\
    chedulerAdaptorDescription\"\0\x12;\n\x06create\x12\x1d.xenon.CreateSche\
    dulerRequest\x1a\x10.xenon.Scheduler\"\0\x128\n\x0egetAdaptorName\x12\
    \x10.xenon.Scheduler\x1a\x12.xenon.AdaptorName\"\0\x122\n\x0bgetLocation\
    \x12\x10.xenon.Scheduler\x1a\x0f.xenon.Location\"\0\x12A\n\rgetCredentia\
    l\x12\x10.xenon.Scheduler\x1a\x1c.xenon.GetCredentialResponse\"\0\x126\n\
    \rgetProperties\x12\x10.xenon.Scheduler\x1a\x11.xenon.Properties\"\0\x12\
    <\n\x0esubmitBatchJob\x12\x1c.xenon.SubmitBatchJobRequest\x1a\n.xenon.Jo\
    b\"\0\x12e\n\x14submitInteractiveJob\x12\".xenon.SubmitInteractiveJobReq\
    uest\x1a#.xenon.SubmitInteractiveJobResponse\"\0(\x010\x01\x122\n\rgetQu\
    eueNames\x12\x10.xenon.Scheduler\x1a\r.xenon.Queues\"\0\x127\n\x13getDef\
    aultQueueName\x12\x10.xenon.Scheduler\x1a\x0c.xenon.Queue\"\0\x123\n\x07\
    getJobs\x12\x19.xenon.SchedulerAndQueues\x1a\x0b.xenon.Jobs\"\0\x125\n\
    \x0cgetJobStatus\x12\x11.xenon.JobRequest\x1a\x10.xenon.JobStatus\"\0\
    \x12O\n\x0egetJobStatuses\x12\x1c.xenon.GetJobStatusesRequest\x1a\x1d.xe\
    non.GetJobStatusesResponse\"\0\x12D\n\x0egetQueueStatus\x12\x1c.xenon.Ge\
    tQueueStatusRequest\x1a\x12.xenon.QueueStatus\"\0\x12E\n\x10getQueueStat\
    uses\x12\x19.xenon.SchedulerAndQueues\x1a\x14.xenon.QueueStatuses\"\0\
    \x127\n\rwaitUntilDone\x12\x12.xenon.WaitRequest\x1a\x10.xenon.JobStatus\
    \"\0\x12:\n\x10waitUntilRunning\x12\x12.xenon.WaitRequest\x1a\x10.xenon.\
    JobStatus\"\0\x12'\n\x06isOpen\x12\x10.xenon.Scheduler\x1a\t.xenon.Is\"\
    \0\x122\n\tcancelJob\x12\x11.xenon.JobRequest\x1a\x10.xenon.JobStatus\"\
    \0\x12I\n\x11getDefaultRuntime\x12\x10.xenon.Scheduler\x1a\x20.xenon.Get\
    DefaultRuntimeResponse\"\0\x126\n\rgetFileSystem\x12\x10.xenon.Scheduler\
    \x1a\x11.xenon.FileSystem\"\0\x12)\n\x05close\x12\x10.xenon.Scheduler\
    \x1a\x0c.xenon.Empty\"\0\x122\n\x0elocalScheduler\x12\x0c.xenon.Empty\
    \x1a\x10.xenon.Scheduler\"\0\x123\n\x0elistSchedulers\x12\x0c.xenon.Empt\
    y\x1a\x11.xenon.Schedulers\"\0B*\n\x1cnl.esciencecenter.xenon.grpcB\nXen\
    onProtoJ\x85\xd9\x01\n\x07\x12\x05\x0e\0\xf4\x04\x01\n\xd5\x04\n\x01\x0c\
    \x12\x03\x0e\0\x122\xca\x04\x20Copyright\x202015-present\x20Netherlands\
    \x20eScience\x20Center\n\n\x20Licensed\x20under\x20the\x20Apache\x20Lice\
    nse,\x20Version\x202.0\x20(the\x20\"License\");\n\x20you\x20may\x20not\
    \x20use\x20this\x20file\x20except\x20in\x20compliance\x20with\x20the\x20\
    License.\n\x20You\x20may\x20obtain\x20a\x20copy\x20of\x20the\x20License\
    \x20at\n\n\x20\x20\x20\x20\x20http://www.apache.org/licenses/LICENSE-2.0\
    \n\n\x20Unless\x20required\x20by\x20applicable\x20law\x20or\x20agreed\
    \x20to\x20in\x20writing,\x20software\n\x20distributed\x20under\x20the\
    \x20License\x20is\x20distributed\x20on\x20an\x20\"AS\x20IS\"\x20BASIS,\n\
    \x20WITHOUT\x20WARRANTIES\x20OR\x20CONDITIONS\x20OF\x20ANY\x20KIND,\x20e\
    ither\x20express\x20or\x20implied.\n\x20See\x20the\x20License\x20for\x20\
    the\x20specific\x20language\x20governing\x20permissions\x20and\n\x20limi\
    tations\x20under\x20the\x20License.\n\n\x08\n\x01\x08\x12\x03\x10\05\n\t\
    \n\x02\x08\x01\x12\x03\x10\05\n\x08\n\x01\x08\x12\x03\x11\0+\n\t\n\x02\
    \x08\x08\x12\x03\x11\0+\n\x08\n\x01\x02\x12\x03\x13\0\x0e\n\n\n\x02\x04\
    \0\x12\x04\x15\0\x17\x01\n\n\n\x03\x04\0\x01\x12\x03\x15\x08\r\n\n\n\x02\
    \x04\x01\x12\x04\x19\0\x1b\x01\n\n\n\x03\x04\x01\x01\x12\x03\x19\x08\x12\
    \n\x0b\n\x04\x04\x01\x02\0\x12\x03\x1a\x04'\n\r\n\x05\x04\x01\x02\0\x04\
    \x12\x04\x1a\x04\x19\x14\n\x0c\n\x05\x04\x01\x02\0\x06\x12\x03\x1a\x04\
    \x17\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03\x1a\x18\"\n\x0c\n\x05\x04\x01\
    \x02\0\x03\x12\x03\x1a%&\n\n\n\x02\x04\x02\x12\x04\x1d\0+\x01\n\n\n\x03\
    \x04\x02\x01\x12\x03\x1d\x08\x1b\n\x0b\n\x04\x04\x02\x02\0\x12\x03\x1e\
    \x04\x14\n\r\n\x05\x04\x02\x02\0\x04\x12\x04\x1e\x04\x1d\x1d\n\x0c\n\x05\
    \x04\x02\x02\0\x05\x12\x03\x1e\x04\n\n\x0c\n\x05\x04\x02\x02\0\x01\x12\
    \x03\x1e\x0b\x0f\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03\x1e\x12\x13\n\x0b\
    \n\x04\x04\x02\x02\x01\x12\x03\x1f\x04\x1b\n\r\n\x05\x04\x02\x02\x01\x04\
    \x12\x04\x1f\x04\x1e\x14\n\x0c\n\x05\x04\x02\x02\x01\x05\x12\x03\x1f\x04\
    \n\n\x0c\n\x05\x04\x02\x02\x01\x01\x12\x03\x1f\x0b\x16\n\x0c\n\x05\x04\
    \x02\x02\x01\x03\x12\x03\x1f\x19\x1a\n\x0b\n\x04\x04\x02\x02\x02\x12\x03\
    \x20\x04\x1d\n\r\n\x05\x04\x02\x02\x02\x04\x12\x04\x20\x04\x1f\x1b\n\x0c\
    \n\x05\x04\x02\x02\x02\x05\x12\x03\x20\x04\n\n\x0c\n\x05\x04\x02\x02\x02\
    \x01\x12\x03\x20\x0b\x18\n\x0c\n\x05\x04\x02\x02\x02\x03\x12\x03\x20\x1b\
    \x1c\n\x0c\n\x04\x04\x02\x04\0\x12\x04!\x04)\x05\n\x0c\n\x05\x04\x02\x04\
    \0\x01\x12\x03!\t\r\n\r\n\x06\x04\x02\x04\0\x02\0\x12\x03\"\x08\x13\n\
    \x0e\n\x07\x04\x02\x04\0\x02\0\x01\x12\x03\"\x08\x0e\n\x0e\n\x07\x04\x02\
    \x04\0\x02\0\x02\x12\x03\"\x11\x12\n\r\n\x06\x04\x02\x04\0\x02\x01\x12\
    \x03#\x08\x14\n\x0e\n\x07\x04\x02\x04\0\x02\x01\x01\x12\x03#\x08\x0f\n\
    \x0e\n\x07\x04\x02\x04\0\x02\x01\x02\x12\x03#\x12\x13\n\r\n\x06\x04\x02\
    \x04\0\x02\x02\x12\x03$\x08\x14\n\x0e\n\x07\x04\x02\x04\0\x02\x02\x01\
    \x12\x03$\x08\x0f\n\x0e\n\x07\x04\x02\x04\0\x02\x02\x02\x12\x03$\x12\x13\
    \n\r\n\x06\x04\x02\x04\0\x02\x03\x12\x03%\x08\x13\n\x0e\n\x07\x04\x02\
    \x04\0\x02\x03\x01\x12\x03%\x08\x0e\n\x0e\n\x07\x04\x02\x04\0\x02\x03\
    \x02\x12\x03%\x11\x12\n\r\n\x06\x04\x02\x04\0\x02\x04\x12\x03&\x08\x11\n\
    \x0e\n\x07\x04\x02\x04\0\x02\x04\x01\x12\x03&\x08\x0c\n\x0e\n\x07\x04\
    \x02\x04\0\x02\x04\x02\x12\x03&\x0f\x10\n\r\n\x06\x04\x02\x04\0\x02\x05\
    \x12\x03'\x08\x11\n\x0e\n\x07\x04\x02\x04\0\x02\x05\x01\x12\x03'\x08\x0c\
    \n\x0e\n\x07\x04\x02\x04\0\x02\x05\x02\x12\x03'\x0f\x10\n\r\n\x06\x04\
    \x02\x04\0\x02\x06\x12\x03(\x08\x14\n\x0e\n\x07\x04\x02\x04\0\x02\x06\
    \x01\x12\x03(\x08\x0f\n\x0e\n\x07\x04\x02\x04\0\x02\x06\x02\x12\x03(\x12\
    \x13\n\x0b\n\x04\x04\x02\x02\x03\x12\x03*\x04\x12\n\r\n\x05\x04\x02\x02\
    \x03\x04\x12\x04*\x04)\x05\n\x0c\n\x05\x04\x02\x02\x03\x06\x12\x03*\x04\
    \x08\n\x0c\n\x05\x04\x02\x02\x03\x01\x12\x03*\t\r\n\x0c\n\x05\x04\x02\
    \x02\x03\x03\x12\x03*\x10\x11\n\n\n\x02\x04\x03\x12\x04-\0/\x01\n\n\n\
    \x03\x04\x03\x01\x12\x03-\x08\x1c\n\x0b\n\x04\x04\x03\x02\0\x12\x03.\x04\
    0\n\x0c\n\x05\x04\x03\x02\0\x04\x12\x03.\x04\x0c\n\x0c\n\x05\x04\x03\x02\
    \0\x06\x12\x03.\r\x20\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x03.!+\n\x0c\n\
    \x05\x04\x03\x02\0\x03\x12\x03../\n\n\n\x02\x04\x04\x12\x041\0;\x01\n\n\
    \n\x03\x04\x04\x01\x12\x031\x08#\n\x0b\n\x04\x04\x04\x02\0\x12\x032\x04\
    \x14\n\r\n\x05\x04\x04\x02\0\x04\x12\x042\x041%\n\x0c\n\x05\x04\x04\x02\
    \0\x05\x12\x032\x04\n\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x032\x0b\x0f\n\
    \x0c\n\x05\x04\x04\x02\0\x03\x12\x032\x12\x13\n\x0b\n\x04\x04\x04\x02\
    \x01\x12\x033\x04\x1b\n\r\n\x05\x04\x04\x02\x01\x04\x12\x043\x042\x14\n\
    \x0c\n\x05\x04\x04\x02\x01\x05\x12\x033\x04\n\n\x0c\n\x05\x04\x04\x02\
    \x01\x01\x12\x033\x0b\x16\n\x0c\n\x05\x04\x04\x02\x01\x03\x12\x033\x19\
    \x1a\n\x0b\n\x04\x04\x04\x02\x02\x12\x034\x04,\n\x0c\n\x05\x04\x04\x02\
    \x02\x04\x12\x034\x04\x0c\n\x0c\n\x05\x04\x04\x02\x02\x05\x12\x034\r\x13\
    \n\x0c\n\x05\x04\x04\x02\x02\x01\x12\x034\x14'\n\x0c\n\x05\x04\x04\x02\
    \x02\x03\x12\x034*+\n\x0b\n\x04\x04\x04\x02\x03\x12\x035\x04:\n\x0c\n\
    \x05\x04\x04\x02\x03\x04\x12\x035\x04\x0c\n\x0c\n\x05\x04\x04\x02\x03\
    \x06\x12\x035\r\x20\n\x0c\n\x05\x04\x04\x02\x03\x01\x12\x035!5\n\x0c\n\
    \x05\x04\x04\x02\x03\x03\x12\x03589\n\x0b\n\x04\x04\x04\x02\x04\x12\x036\
    \x04\x19\n\r\n\x05\x04\x04\x02\x04\x04\x12\x046\x045:\n\x0c\n\x05\x04\
    \x04\x02\x04\x05\x12\x036\x04\x08\n\x0c\n\x05\x04\x04\x02\x04\x01\x12\
    \x036\t\x14\n\x0c\n\x05\x04\x04\x02\x04\x03\x12\x036\x17\x18\n\x0b\n\x04\
    \x04\x04\x02\x05\x12\x037\x04\"\n\r\n\x05\x04\x04\x02\x05\x04\x12\x047\
    \x046\x19\n\x0c\n\x05\x04\x04\x02\x05\x05\x12\x037\x04\x08\n\x0c\n\x05\
    \x04\x04\x02\x05\x01\x12\x037\t\x1d\n\x0c\n\x05\x04\x04\x02\x05\x03\x12\
    \x037\x20!\n\x0b\n\x04\x04\x04\x02\x06\x12\x038\x04\x1c\n\r\n\x05\x04\
    \x04\x02\x06\x04\x12\x048\x047\"\n\x0c\n\x05\x04\x04\x02\x06\x05\x12\x03\
    8\x04\x08\n\x0c\n\x05\x04\x04\x02\x06\x01\x12\x038\t\x17\n\x0c\n\x05\x04\
    \x04\x02\x06\x03\x12\x038\x1a\x1b\n\x0b\n\x04\x04\x04\x02\x07\x12\x039\
    \x04\x1e\n\r\n\x05\x04\x04\x02\x07\x04\x12\x049\x048\x1c\n\x0c\n\x05\x04\
    \x04\x02\x07\x05\x12\x039\x04\x08\n\x0c\n\x05\x04\x04\x02\x07\x01\x12\
    \x039\t\x19\n\x0c\n\x05\x04\x04\x02\x07\x03\x12\x039\x1c\x1d\n\x0b\n\x04\
    \x04\x04\x02\x08\x12\x03:\x04.\n\x0c\n\x05\x04\x04\x02\x08\x04\x12\x03:\
    \x04\x0c\n\x0c\n\x05\x04\x04\x02\x08\x05\x12\x03:\r\x13\n\x0c\n\x05\x04\
    \x04\x02\x08\x01\x12\x03:\x14)\n\x0c\n\x05\x04\x04\x02\x08\x03\x12\x03:,\
    -\n\n\n\x02\x04\x05\x12\x04=\0?\x01\n\n\n\x03\x04\x05\x01\x12\x03=\x08$\
    \n\x0b\n\x04\x04\x05\x02\0\x12\x03>\x04:\n\x0c\n\x05\x04\x05\x02\0\x04\
    \x12\x03>\x04\x0c\n\x0c\n\x05\x04\x05\x02\0\x06\x12\x03>\r(\n\x0c\n\x05\
    \x04\x05\x02\0\x01\x12\x03>)5\n\x0c\n\x05\x04\x05\x02\0\x03\x12\x03>89\n\
    \n\n\x02\x04\x06\x12\x04A\0Q\x01\n\n\n\x03\x04\x06\x01\x12\x03A\x08$\n\
    \x0b\n\x04\x04\x06\x02\0\x12\x03B\x04\x14\n\r\n\x05\x04\x06\x02\0\x04\
    \x12\x04B\x04A&\n\x0c\n\x05\x04\x06\x02\0\x05\x12\x03B\x04\n\n\x0c\n\x05\
    \x04\x06\x02\0\x01\x12\x03B\x0b\x0f\n\x0c\n\x05\x04\x06\x02\0\x03\x12\
    \x03B\x12\x13\n\x0b\n\x04\x04\x06\x02\x01\x12\x03C\x04\x1b\n\r\n\x05\x04\
    \x06\x02\x01\x04\x12\x04C\x04B\x14\n\x0c\n\x05\x04\x06\x02\x01\x05\x12\
    \x03C\x04\n\n\x0c\n\x05\x04\x06\x02\x01\x01\x12\x03C\x0b\x16\n\x0c\n\x05\
    \x04\x06\x02\x01\x03\x12\x03C\x19\x1a\n\x0b\n\x04\x04\x06\x02\x02\x12\
    \x03D\x04,\n\x0c\n\x05\x04\x06\x02\x02\x04\x12\x03D\x04\x0c\n\x0c\n\x05\
    \x04\x06\x02\x02\x05\x12\x03D\r\x13\n\x0c\n\x05\x04\x06\x02\x02\x01\x12\
    \x03D\x14'\n\x0c\n\x05\x04\x06\x02\x02\x03\x12\x03D*+\n\x0b\n\x04\x04\
    \x06\x02\x03\x12\x03E\x04:\n\x0c\n\x05\x04\x06\x02\x03\x04\x12\x03E\x04\
    \x0c\n\x0c\n\x05\x04\x06\x02\x03\x06\x12\x03E\r\x20\n\x0c\n\x05\x04\x06\
    \x02\x03\x01\x12\x03E!5\n\x0c\n\x05\x04\x06\x02\x03\x03\x12\x03E89\nd\n\
    \x04\x04\x06\x02\x04\x12\x03G\x04'\x1aW\x20copy\x20between\x20remote\x20\
    filesystems\x20directly,\x20without\x20passing\x20bytes\x20through\x20lo\
    cal\x20process\n\n\r\n\x05\x04\x06\x02\x04\x04\x12\x04G\x04E:\n\x0c\n\
    \x05\x04\x06\x02\x04\x05\x12\x03G\x04\x08\n\x0c\n\x05\x04\x06\x02\x04\
    \x01\x12\x03G\t\"\n\x0c\n\x05\x04\x06\x02\x04\x03\x12\x03G%&\n\x0b\n\x04\
    \x04\x06\x02\x05\x12\x03H\x04&\n\r\n\x05\x04\x06\x02\x05\x04\x12\x04H\
    \x04G'\n\x0c\n\x05\x04\x06\x02\x05\x05\x12\x03H\x04\x08\n\x0c\n\x05\x04\
    \x06\x02\x05\x01\x12\x03H\t!\n\x0c\n\x05\x04\x06\x02\x05\x03\x12\x03H$%\
    \n\x0b\n\x04\x04\x06\x02\x06\x12\x03I\x04$\n\r\n\x05\x04\x06\x02\x06\x04\
    \x12\x04I\x04H&\n\x0c\n\x05\x04\x06\x02\x06\x05\x12\x03I\x04\x08\n\x0c\n\
    \x05\x04\x06\x02\x06\x01\x12\x03I\t\x1f\n\x0c\n\x05\x04\x06\x02\x06\x03\
    \x12\x03I\"#\n\x0b\n\x04\x04\x06\x02\x07\x12\x03J\x04\x1f\n\r\n\x05\x04\
    \x06\x02\x07\x04\x12\x04J\x04I$\n\x0c\n\x05\x04\x06\x02\x07\x05\x12\x03J\
    \x04\x08\n\x0c\n\x05\x04\x06\x02\x07\x01\x12\x03J\t\x1a\n\x0c\n\x05\x04\
    \x06\x02\x07\x03\x12\x03J\x1d\x1e\n\x0b\n\x04\x04\x06\x02\x08\x12\x03K\
    \x04.\n\x0c\n\x05\x04\x06\x02\x08\x04\x12\x03K\x04\x0c\n\x0c\n\x05\x04\
    \x06\x02\x08\x05\x12\x03K\r\x13\n\x0c\n\x05\x04\x06\x02\x08\x01\x12\x03K\
    \x14)\n\x0c\n\x05\x04\x06\x02\x08\x03\x12\x03K,-\n\x0b\n\x04\x04\x06\x02\
    \t\x12\x03L\x041\n\r\n\x05\x04\x06\x02\t\x04\x12\x04L\x04K.\n\x0c\n\x05\
    \x04\x06\x02\t\x05\x12\x03L\x04\x08\n\x0c\n\x05\x04\x06\x02\t\x01\x12\
    \x03L\t+\n\x0c\n\x05\x04\x06\x02\t\x03\x12\x03L.0\n\x0b\n\x04\x04\x06\
    \x02\n\x12\x03M\x041\n\r\n\x05\x04\x06\x02\n\x04\x12\x04M\x04L1\n\x0c\n\
    \x05\x04\x06\x02\n\x05\x12\x03M\x04\x08\n\x0c\n\x05\x04\x06\x02\n\x01\
    \x12\x03M\t+\n\x0c\n\x05\x04\x06\x02\n\x03\x12\x03M.0\n\x0b\n\x04\x04\
    \x06\x02\x0b\x12\x03N\x04\x1e\n\r\n\x05\x04\x06\x02\x0b\x04\x12\x04N\x04\
    M1\n\x0c\n\x05\x04\x06\x02\x0b\x05\x12\x03N\x04\x08\n\x0c\n\x05\x04\x06\
    \x02\x0b\x01\x12\x03N\t\x18\n\x0c\n\x05\x04\x06\x02\x0b\x03\x12\x03N\x1b\
    \x1d\n\x0b\n\x04\x04\x06\x02\x0c\x12\x03O\x04\x19\n\r\n\x05\x04\x06\x02\
    \x0c\x04\x12\x04O\x04N\x1e\n\x0c\n\x05\x04\x06\x02\x0c\x05\x12\x03O\x04\
    \x08\n\x0c\n\x05\x04\x06\x02\x0c\x01\x12\x03O\t\x13\n\x0c\n\x05\x04\x06\
    \x02\x0c\x03\x12\x03O\x16\x18\n\x0b\n\x04\x04\x06\x02\r\x12\x03P\x04$\n\
    \r\n\x05\x04\x06\x02\r\x04\x12\x04P\x04O\x19\n\x0c\n\x05\x04\x06\x02\r\
    \x05\x12\x03P\x04\x08\n\x0c\n\x05\x04\x06\x02\r\x01\x12\x03P\t\x1e\n\x0c\
    \n\x05\x04\x06\x02\r\x03\x12\x03P!#\n\n\n\x02\x04\x07\x12\x04S\0U\x01\n\
    \n\n\x03\x04\x07\x01\x12\x03S\x08%\n\x0b\n\x04\x04\x07\x02\0\x12\x03T\
    \x04;\n\x0c\n\x05\x04\x07\x02\0\x04\x12\x03T\x04\x0c\n\x0c\n\x05\x04\x07\
    \x02\0\x06\x12\x03T\r)\n\x0c\n\x05\x04\x07\x02\0\x01\x12\x03T*6\n\x0c\n\
    \x05\x04\x07\x02\0\x03\x12\x03T9:\n\n\n\x02\x04\x08\x12\x04W\0Y\x01\n\n\
    \n\x03\x04\x08\x01\x12\x03W\x08\x13\n\x0b\n\x04\x04\x08\x02\0\x12\x03X\
    \x04\x14\n\r\n\x05\x04\x08\x02\0\x04\x12\x04X\x04W\x15\n\x0c\n\x05\x04\
    \x08\x02\0\x05\x12\x03X\x04\n\n\x0c\n\x05\x04\x08\x02\0\x01\x12\x03X\x0b\
    \x0f\n\x0c\n\x05\x04\x08\x02\0\x03\x12\x03X\x12\x13\n\n\n\x02\x04\t\x12\
    \x04[\0]\x01\n\n\n\x03\x04\t\x01\x12\x03[\x08\x14\n\x0b\n\x04\x04\t\x02\
    \0\x12\x03\\\x04\x1d\n\x0c\n\x05\x04\t\x02\0\x04\x12\x03\\\x04\x0c\n\x0c\
    \n\x05\x04\t\x02\0\x05\x12\x03\\\r\x13\n\x0c\n\x05\x04\t\x02\0\x01\x12\
    \x03\\\x14\x18\n\x0c\n\x05\x04\t\x02\0\x03\x12\x03\\\x1b\x1c\n\n\n\x02\
    \x04\n\x12\x04_\0d\x01\n\n\n\x03\x04\n\x01\x12\x03_\x08\x1d\n'\n\x04\x04\
    \n\x02\0\x12\x03a\x04\x18\x1a\x1a\x20Path\x20to\x20certificate\x20file\n\
    \n\r\n\x05\x04\n\x02\0\x04\x12\x04a\x04_\x1f\n\x0c\n\x05\x04\n\x02\0\x05\
    \x12\x03a\x04\n\n\x0c\n\x05\x04\n\x02\0\x01\x12\x03a\x0b\x13\n\x0c\n\x05\
    \x04\n\x02\0\x03\x12\x03a\x16\x17\n\x0b\n\x04\x04\n\x02\x01\x12\x03b\x04\
    \x1a\n\r\n\x05\x04\n\x02\x01\x04\x12\x04b\x04a\x18\n\x0c\n\x05\x04\n\x02\
    \x01\x05\x12\x03b\x04\n\n\x0c\n\x05\x04\n\x02\x01\x01\x12\x03b\x0b\x15\n\
    \x0c\n\x05\x04\n\x02\x01\x03\x12\x03b\x18\x19\n\x0b\n\x04\x04\n\x02\x02\
    \x12\x03c\x04\x18\n\r\n\x05\x04\n\x02\x02\x04\x12\x04c\x04b\x1a\n\x0c\n\
    \x05\x04\n\x02\x02\x05\x12\x03c\x04\n\n\x0c\n\x05\x04\n\x02\x02\x01\x12\
    \x03c\x0b\x13\n\x0c\n\x05\x04\n\x02\x02\x03\x12\x03c\x16\x17\n\n\n\x02\
    \x04\x0b\x12\x04f\0i\x01\n\n\n\x03\x04\x0b\x01\x12\x03f\x08\x1a\n\x0b\n\
    \x04\x04\x0b\x02\0\x12\x03g\x04\x18\n\r\n\x05\x04\x0b\x02\0\x04\x12\x04g\
    \x04f\x1c\n\x0c\n\x05\x04\x0b\x02\0\x05\x12\x03g\x04\n\n\x0c\n\x05\x04\
    \x0b\x02\0\x01\x12\x03g\x0b\x13\n\x0c\n\x05\x04\x0b\x02\0\x03\x12\x03g\
    \x16\x17\n\x0b\n\x04\x04\x0b\x02\x01\x12\x03h\x04\x18\n\r\n\x05\x04\x0b\
    \x02\x01\x04\x12\x04h\x04g\x18\n\x0c\n\x05\x04\x0b\x02\x01\x05\x12\x03h\
    \x04\n\n\x0c\n\x05\x04\x0b\x02\x01\x01\x12\x03h\x0b\x13\n\x0c\n\x05\x04\
    \x0b\x02\x01\x03\x12\x03h\x16\x17\n\n\n\x02\x04\x0c\x12\x04k\0m\x01\n\n\
    \n\x03\x04\x0c\x01\x12\x03k\x08\x19\n\x0b\n\x04\x04\x0c\x02\0\x12\x03l\
    \x04\x18\n\r\n\x05\x04\x0c\x02\0\x04\x12\x04l\x04k\x1b\n\x0c\n\x05\x04\
    \x0c\x02\0\x05\x12\x03l\x04\n\n\x0c\n\x05\x04\x0c\x02\0\x01\x12\x03l\x0b\
    \x13\n\x0c\n\x05\x04\x0c\x02\0\x03\x12\x03l\x16\x17\n\n\n\x02\x04\r\x12\
    \x04o\0r\x01\n\n\n\x03\x04\r\x01\x12\x03o\x08\x18\n\x0b\n\x04\x04\r\x02\
    \0\x12\x03p\x04\x18\n\r\n\x05\x04\r\x02\0\x04\x12\x04p\x04o\x1a\n\x0c\n\
    \x05\x04\r\x02\0\x05\x12\x03p\x04\n\n\x0c\n\x05\x04\r\x02\0\x01\x12\x03p\
    \x0b\x13\n\x0c\n\x05\x04\r\x02\0\x03\x12\x03p\x16\x17\n\x0b\n\x04\x04\r\
    \x02\x01\x12\x03q\x04\x1a\n\r\n\x05\x04\r\x02\x01\x04\x12\x04q\x04p\x18\
    \n\x0c\n\x05\x04\r\x02\x01\x05\x12\x03q\x04\n\n\x0c\n\x05\x04\r\x02\x01\
    \x01\x12\x03q\x0b\x15\n\x0c\n\x05\x04\r\x02\x01\x03\x12\x03q\x18\x19\n\n\
    \n\x02\x04\x0e\x12\x04t\0|\x01\n\n\n\x03\x04\x0e\x01\x12\x03t\x08\x16\n/\
    \n\x04\x04\x0e\x08\0\x12\x04v\x04{\x05\x1a!\x20Values\x20of\x20Credentia\
    lMap\x20entries\n\n\x0c\n\x05\x04\x0e\x08\0\x01\x12\x03v\n\x0f\n\x0b\n\
    \x04\x04\x0e\x02\0\x12\x03w\x089\n\x0c\n\x05\x04\x0e\x02\0\x06\x12\x03w\
    \x08\x1d\n\x0c\n\x05\x04\x0e\x02\0\x01\x12\x03w\x1e4\n\x0c\n\x05\x04\x0e\
    \x02\0\x03\x12\x03w78\n\x0b\n\x04\x04\x0e\x02\x01\x12\x03x\x083\n\x0c\n\
    \x05\x04\x0e\x02\x01\x06\x12\x03x\x08\x1a\n\x0c\n\x05\x04\x0e\x02\x01\
    \x01\x12\x03x\x1b.\n\x0c\n\x05\x04\x0e\x02\x01\x03\x12\x03x12\n\x0b\n\
    \x04\x04\x0e\x02\x02\x12\x03y\x081\n\x0c\n\x05\x04\x0e\x02\x02\x06\x12\
    \x03y\x08\x19\n\x0c\n\x05\x04\x0e\x02\x02\x01\x12\x03y\x1a,\n\x0c\n\x05\
    \x04\x0e\x02\x02\x03\x12\x03y/0\n\x0b\n\x04\x04\x0e\x02\x03\x12\x03z\x08\
    /\n\x0c\n\x05\x04\x0e\x02\x03\x06\x12\x03z\x08\x18\n\x0c\n\x05\x04\x0e\
    \x02\x03\x01\x12\x03z\x19*\n\x0c\n\x05\x04\x0e\x02\x03\x03\x12\x03z-.\n\
    \x0b\n\x02\x04\x0f\x12\x05~\0\x88\x01\x01\n\n\n\x03\x04\x0f\x01\x12\x03~\
    \x08\x15\n_\n\x04\x04\x0f\x02\0\x12\x04\x80\x01\x04,\x1aQ\x20In\x20Xenon\
    \x20accessible\x20by\x20get(),\x20put()\x20and\x20containsCredential()\
    \x20on\x20object\x20directly\n\n\x0e\n\x05\x04\x0f\x02\0\x04\x12\x05\x80\
    \x01\x04~\x17\n\r\n\x05\x04\x0f\x02\0\x06\x12\x04\x80\x01\x04\x1f\n\r\n\
    \x05\x04\x0f\x02\0\x01\x12\x04\x80\x01\x20'\n\r\n\x05\x04\x0f\x02\0\x03\
    \x12\x04\x80\x01*+\nD\n\x04\x04\x0f\x08\0\x12\x06\x82\x01\x04\x87\x01\
    \x05\x1a4\x20In\x20Xenon\x20it\x20is\x20called\x20default\x20instead\x20\
    of\x20fallback.\n\n\r\n\x05\x04\x0f\x08\0\x01\x12\x04\x82\x01\n\x12\n\
    \x0c\n\x04\x04\x0f\x02\x01\x12\x04\x83\x01\x089\n\r\n\x05\x04\x0f\x02\
    \x01\x06\x12\x04\x83\x01\x08\x1d\n\r\n\x05\x04\x0f\x02\x01\x01\x12\x04\
    \x83\x01\x1e4\n\r\n\x05\x04\x0f\x02\x01\x03\x12\x04\x83\x0178\n\x0c\n\
    \x04\x04\x0f\x02\x02\x12\x04\x84\x01\x083\n\r\n\x05\x04\x0f\x02\x02\x06\
    \x12\x04\x84\x01\x08\x1a\n\r\n\x05\x04\x0f\x02\x02\x01\x12\x04\x84\x01\
    \x1b.\n\r\n\x05\x04\x0f\x02\x02\x03\x12\x04\x84\x0112\n\x0c\n\x04\x04\
    \x0f\x02\x03\x12\x04\x85\x01\x081\n\r\n\x05\x04\x0f\x02\x03\x06\x12\x04\
    \x85\x01\x08\x19\n\r\n\x05\x04\x0f\x02\x03\x01\x12\x04\x85\x01\x1a,\n\r\
    \n\x05\x04\x0f\x02\x03\x03\x12\x04\x85\x01/0\n\x0c\n\x04\x04\x0f\x02\x04\
    \x12\x04\x86\x01\x08/\n\r\n\x05\x04\x0f\x02\x04\x06\x12\x04\x86\x01\x08\
    \x18\n\r\n\x05\x04\x0f\x02\x04\x01\x12\x04\x86\x01\x19*\n\r\n\x05\x04\
    \x0f\x02\x04\x03\x12\x04\x86\x01-.\n\x0c\n\x02\x04\x10\x12\x06\x8a\x01\0\
    \x8c\x01\x01\n\x0b\n\x03\x04\x10\x01\x12\x04\x8a\x01\x08\x10\n\x0c\n\x04\
    \x04\x10\x02\0\x12\x04\x8b\x01\x04\x18\n\x0f\n\x05\x04\x10\x02\0\x04\x12\
    \x06\x8b\x01\x04\x8a\x01\x12\n\r\n\x05\x04\x10\x02\0\x05\x12\x04\x8b\x01\
    \x04\n\n\r\n\x05\x04\x10\x02\0\x01\x12\x04\x8b\x01\x0b\x13\n\r\n\x05\x04\
    \x10\x02\0\x03\x12\x04\x8b\x01\x16\x17\n\x0c\n\x02\x04\x11\x12\x06\x8e\
    \x01\0\x96\x01\x01\n\x0b\n\x03\x04\x11\x01\x12\x04\x8e\x01\x08\x1d\n\x0e\
    \n\x04\x04\x11\x08\0\x12\x06\x8f\x01\x04\x95\x01\x05\n\r\n\x05\x04\x11\
    \x08\0\x01\x12\x04\x8f\x01\n\x14\n\x0c\n\x04\x04\x11\x02\0\x12\x04\x90\
    \x01\x089\n\r\n\x05\x04\x11\x02\0\x06\x12\x04\x90\x01\x08\x1d\n\r\n\x05\
    \x04\x11\x02\0\x01\x12\x04\x90\x01\x1e4\n\r\n\x05\x04\x11\x02\0\x03\x12\
    \x04\x90\x0178\n\x0c\n\x04\x04\x11\x02\x01\x12\x04\x91\x01\x083\n\r\n\
    \x05\x04\x11\x02\x01\x06\x12\x04\x91\x01\x08\x1a\n\r\n\x05\x04\x11\x02\
    \x01\x01\x12\x04\x91\x01\x1b.\n\r\n\x05\x04\x11\x02\x01\x03\x12\x04\x91\
    \x0112\n\x0c\n\x04\x04\x11\x02\x02\x12\x04\x92\x01\x081\n\r\n\x05\x04\
    \x11\x02\x02\x06\x12\x04\x92\x01\x08\x19\n\r\n\x05\x04\x11\x02\x02\x01\
    \x12\x04\x92\x01\x1a,\n\r\n\x05\x04\x11\x02\x02\x03\x12\x04\x92\x01/0\n\
    \x0c\n\x04\x04\x11\x02\x03\x12\x04\x93\x01\x08)\n\r\n\x05\x04\x11\x02\
    \x03\x06\x12\x04\x93\x01\x08\x15\n\r\n\x05\x04\x11\x02\x03\x01\x12\x04\
    \x93\x01\x16$\n\r\n\x05\x04\x11\x02\x03\x03\x12\x04\x93\x01'(\n\x0c\n\
    \x04\x04\x11\x02\x04\x12\x04\x94\x01\x08/\n\r\n\x05\x04\x11\x02\x04\x06\
    \x12\x04\x94\x01\x08\x18\n\r\n\x05\x04\x11\x02\x04\x01\x12\x04\x94\x01\
    \x19*\n\r\n\x05\x04\x11\x02\x04\x03\x12\x04\x94\x01-.\n\x0c\n\x02\x04\
    \x12\x12\x06\x98\x01\0\xa3\x01\x01\n\x0b\n\x03\x04\x12\x01\x12\x04\x98\
    \x01\x08\x1f\n\x0c\n\x04\x04\x12\x02\0\x12\x04\x99\x01\x04\x17\n\x0f\n\
    \x05\x04\x12\x02\0\x04\x12\x06\x99\x01\x04\x98\x01!\n\r\n\x05\x04\x12\
    \x02\0\x05\x12\x04\x99\x01\x04\n\n\r\n\x05\x04\x12\x02\0\x01\x12\x04\x99\
    \x01\x0b\x12\n\r\n\x05\x04\x12\x02\0\x03\x12\x04\x99\x01\x15\x16\n\x0c\n\
    \x04\x04\x12\x02\x01\x12\x04\x9a\x01\x04\x18\n\x0f\n\x05\x04\x12\x02\x01\
    \x04\x12\x06\x9a\x01\x04\x99\x01\x17\n\r\n\x05\x04\x12\x02\x01\x05\x12\
    \x04\x9a\x01\x04\n\n\r\n\x05\x04\x12\x02\x01\x01\x12\x04\x9a\x01\x0b\x13\
    \n\r\n\x05\x04\x12\x02\x01\x03\x12\x04\x9a\x01\x16\x17\n\x0c\n\x04\x04\
    \x12\x02\x02\x12\x04\x9b\x01\x04'\n\x0f\n\x05\x04\x12\x02\x02\x04\x12\
    \x06\x9b\x01\x04\x9a\x01\x18\n\r\n\x05\x04\x12\x02\x02\x06\x12\x04\x9b\
    \x01\x04\x17\n\r\n\x05\x04\x12\x02\x02\x01\x12\x04\x9b\x01\x18\"\n\r\n\
    \x05\x04\x12\x02\x02\x03\x12\x04\x9b\x01%&\n\x0e\n\x04\x04\x12\x08\0\x12\
    \x06\x9c\x01\x04\xa2\x01\x05\n\r\n\x05\x04\x12\x08\0\x01\x12\x04\x9c\x01\
    \n\x14\n\x0c\n\x04\x04\x12\x02\x03\x12\x04\x9d\x01\x089\n\r\n\x05\x04\
    \x12\x02\x03\x06\x12\x04\x9d\x01\x08\x1d\n\r\n\x05\x04\x12\x02\x03\x01\
    \x12\x04\x9d\x01\x1e4\n\r\n\x05\x04\x12\x02\x03\x03\x12\x04\x9d\x0178\n\
    \x0c\n\x04\x04\x12\x02\x04\x12\x04\x9e\x01\x083\n\r\n\x05\x04\x12\x02\
    \x04\x06\x12\x04\x9e\x01\x08\x1a\n\r\n\x05\x04\x12\x02\x04\x01\x12\x04\
    \x9e\x01\x1b.\n\r\n\x05\x04\x12\x02\x04\x03\x12\x04\x9e\x0112\n\x0c\n\
    \x04\x04\x12\x02\x05\x12\x04\x9f\x01\x081\n\r\n\x05\x04\x12\x02\x05\x06\
    \x12\x04\x9f\x01\x08\x19\n\r\n\x05\x04\x12\x02\x05\x01\x12\x04\x9f\x01\
    \x1a,\n\r\n\x05\x04\x12\x02\x05\x03\x12\x04\x9f\x01/0\n\x0c\n\x04\x04\
    \x12\x02\x06\x12\x04\xa0\x01\x08)\n\r\n\x05\x04\x12\x02\x06\x06\x12\x04\
    \xa0\x01\x08\x15\n\r\n\x05\x04\x12\x02\x06\x01\x12\x04\xa0\x01\x16$\n\r\
    \n\x05\x04\x12\x02\x06\x03\x12\x04\xa0\x01'(\n\x0c\n\x04\x04\x12\x02\x07\
    \x12\x04\xa1\x01\x08/\n\r\n\x05\x04\x12\x02\x07\x06\x12\x04\xa1\x01\x08\
    \x18\n\r\n\x05\x04\x12\x02\x07\x01\x12\x04\xa1\x01\x19*\n\r\n\x05\x04\
    \x12\x02\x07\x03\x12\x04\xa1\x01-.\n2\n\x02\x04\x13\x12\x06\xa6\x01\0\
    \xa8\x01\x01\x1a$\x20Handle\x20for\x20Xenon\x20FileSystem\x20object\n\n\
    \x0b\n\x03\x04\x13\x01\x12\x04\xa6\x01\x08\x12\n\x0c\n\x04\x04\x13\x02\0\
    \x12\x04\xa7\x01\x04\x12\n\x0f\n\x05\x04\x13\x02\0\x04\x12\x06\xa7\x01\
    \x04\xa6\x01\x14\n\r\n\x05\x04\x13\x02\0\x05\x12\x04\xa7\x01\x04\n\n\r\n\
    \x05\x04\x13\x02\0\x01\x12\x04\xa7\x01\x0b\r\n\r\n\x05\x04\x13\x02\0\x03\
    \x12\x04\xa7\x01\x10\x11\n\x0c\n\x02\x04\x14\x12\x06\xaa\x01\0\xac\x01\
    \x01\n\x0b\n\x03\x04\x14\x01\x12\x04\xaa\x01\x08\x13\n\x0c\n\x04\x04\x14\
    \x02\0\x12\x04\xab\x01\x04(\n\r\n\x05\x04\x14\x02\0\x04\x12\x04\xab\x01\
    \x04\x0c\n\r\n\x05\x04\x14\x02\0\x06\x12\x04\xab\x01\r\x17\n\r\n\x05\x04\
    \x14\x02\0\x01\x12\x04\xab\x01\x18#\n\r\n\x05\x04\x14\x02\0\x03\x12\x04\
    \xab\x01&'\n\x0c\n\x02\x04\x15\x12\x06\xae\x01\0\xb2\x01\x01\n\x0b\n\x03\
    \x04\x15\x01\x12\x04\xae\x01\x08\x0c\n\x0c\n\x04\x04\x15\x02\0\x12\x04\
    \xaf\x01\x04\x14\n\x0f\n\x05\x04\x15\x02\0\x04\x12\x06\xaf\x01\x04\xae\
    \x01\x0e\n\r\n\x05\x04\x15\x02\0\x05\x12\x04\xaf\x01\x04\n\n\r\n\x05\x04\
    \x15\x02\0\x01\x12\x04\xaf\x01\x0b\x0f\n\r\n\x05\x04\x15\x02\0\x03\x12\
    \x04\xaf\x01\x12\x13\n7\n\x04\x04\x15\x02\x01\x12\x04\xb1\x01\x04\x19\
    \x1a)\x20Separator\x20used\x20in\x20path.\x20Defaults\x20to\x20`/`\n\n\
    \x0f\n\x05\x04\x15\x02\x01\x04\x12\x06\xb1\x01\x04\xaf\x01\x14\n\r\n\x05\
    \x04\x15\x02\x01\x05\x12\x04\xb1\x01\x04\n\n\r\n\x05\x04\x15\x02\x01\x01\
    \x12\x04\xb1\x01\x0b\x14\n\r\n\x05\x04\x15\x02\x01\x03\x12\x04\xb1\x01\
    \x17\x18\n\x0c\n\x02\x04\x16\x12\x06\xb4\x01\0\xb7\x01\x01\n\x0b\n\x03\
    \x04\x16\x01\x12\x04\xb4\x01\x08\x13\n\x0c\n\x04\x04\x16\x02\0\x12\x04\
    \xb5\x01\x04\x1e\n\x0f\n\x05\x04\x16\x02\0\x04\x12\x06\xb5\x01\x04\xb4\
    \x01\x15\n\r\n\x05\x04\x16\x02\0\x06\x12\x04\xb5\x01\x04\x0e\n\r\n\x05\
    \x04\x16\x02\0\x01\x12\x04\xb5\x01\x0f\x19\n\r\n\x05\x04\x16\x02\0\x03\
    \x12\x04\xb5\x01\x1c\x1d\n\x0c\n\x04\x04\x16\x02\x01\x12\x04\xb6\x01\x04\
    \x12\n\x0f\n\x05\x04\x16\x02\x01\x04\x12\x06\xb6\x01\x04\xb5\x01\x1e\n\r\
    \n\x05\x04\x16\x02\x01\x06\x12\x04\xb6\x01\x04\x08\n\r\n\x05\x04\x16\x02\
    \x01\x01\x12\x04\xb6\x01\t\r\n\r\n\x05\x04\x16\x02\x01\x03\x12\x04\xb6\
    \x01\x10\x11\n\x0c\n\x02\x04\x17\x12\x06\xb9\x01\0\xbd\x01\x01\n\x0b\n\
    \x03\x04\x17\x01\x12\x04\xb9\x01\x08\x15\n\x0c\n\x04\x04\x17\x02\0\x12\
    \x04\xba\x01\x04\x1e\n\x0f\n\x05\x04\x17\x02\0\x04\x12\x06\xba\x01\x04\
    \xb9\x01\x17\n\r\n\x05\x04\x17\x02\0\x06\x12\x04\xba\x01\x04\x0e\n\r\n\
    \x05\x04\x17\x02\0\x01\x12\x04\xba\x01\x0f\x19\n\r\n\x05\x04\x17\x02\0\
    \x03\x12\x04\xba\x01\x1c\x1d\n\x0c\n\x04\x04\x17\x02\x01\x12\x04\xbb\x01\
    \x04\x12\n\x0f\n\x05\x04\x17\x02\x01\x04\x12\x06\xbb\x01\x04\xba\x01\x1e\
    \n\r\n\x05\x04\x17\x02\x01\x06\x12\x04\xbb\x01\x04\x08\n\r\n\x05\x04\x17\
    \x02\x01\x01\x12\x04\xbb\x01\t\r\n\r\n\x05\x04\x17\x02\x01\x03\x12\x04\
    \xbb\x01\x10\x11\n\x0c\n\x04\x04\x17\x02\x02\x12\x04\xbc\x01\x04\x17\n\
    \x0f\n\x05\x04\x17\x02\x02\x04\x12\x06\xbc\x01\x04\xbb\x01\x12\n\r\n\x05\
    \x04\x17\x02\x02\x05\x12\x04\xbc\x01\x04\x08\n\r\n\x05\x04\x17\x02\x02\
    \x01\x12\x04\xbc\x01\t\x12\n\r\n\x05\x04\x17\x02\x02\x03\x12\x04\xbc\x01\
    \x15\x16\n\x0c\n\x02\x04\x18\x12\x06\xbf\x01\0\xcb\x01\x01\n\x0b\n\x03\
    \x04\x18\x01\x12\x04\xbf\x01\x08\x13\n\x0c\n\x04\x04\x18\x02\0\x12\x04\
    \xc0\x01\x04\x1e\n\x0f\n\x05\x04\x18\x02\0\x04\x12\x06\xc0\x01\x04\xbf\
    \x01\x15\n\r\n\x05\x04\x18\x02\0\x06\x12\x04\xc0\x01\x04\x0e\n\r\n\x05\
    \x04\x18\x02\0\x01\x12\x04\xc0\x01\x0f\x19\n\r\n\x05\x04\x18\x02\0\x03\
    \x12\x04\xc0\x01\x1c\x1d\n\x0c\n\x04\x04\x18\x02\x01\x12\x04\xc1\x01\x04\
    \x14\n\x0f\n\x05\x04\x18\x02\x01\x04\x12\x06\xc1\x01\x04\xc0\x01\x1e\n\r\
    \n\x05\x04\x18\x02\x01\x06\x12\x04\xc1\x01\x04\x08\n\r\n\x05\x04\x18\x02\
    \x01\x01\x12\x04\xc1\x01\t\x0f\n\r\n\x05\x04\x18\x02\x01\x03\x12\x04\xc1\
    \x01\x12\x13\n\x0c\n\x04\x04\x18\x02\x02\x12\x04\xc2\x01\x04*\n\x0f\n\
    \x05\x04\x18\x02\x02\x04\x12\x06\xc2\x01\x04\xc1\x01\x14\n\r\n\x05\x04\
    \x18\x02\x02\x06\x12\x04\xc2\x01\x04\x0e\n\r\n\x05\x04\x18\x02\x02\x01\
    \x12\x04\xc2\x01\x0f%\n\r\n\x05\x04\x18\x02\x02\x03\x12\x04\xc2\x01()\n\
    \x0c\n\x04\x04\x18\x02\x03\x12\x04\xc3\x01\x04\x19\n\x0f\n\x05\x04\x18\
    \x02\x03\x04\x12\x06\xc3\x01\x04\xc2\x01*\n\r\n\x05\x04\x18\x02\x03\x06\
    \x12\x04\xc3\x01\x04\x08\n\r\n\x05\x04\x18\x02\x03\x01\x12\x04\xc3\x01\t\
    \x14\n\r\n\x05\x04\x18\x02\x03\x03\x12\x04\xc3\x01\x17\x18\n\x0e\n\x04\
    \x04\x18\x04\0\x12\x06\xc4\x01\x04\xc8\x01\x05\n\r\n\x05\x04\x18\x04\0\
    \x01\x12\x04\xc4\x01\t\x11\n\x0e\n\x06\x04\x18\x04\0\x02\0\x12\x04\xc5\
    \x01\x08\x13\n\x0f\n\x07\x04\x18\x04\0\x02\0\x01\x12\x04\xc5\x01\x08\x0e\
    \n\x0f\n\x07\x04\x18\x04\0\x02\0\x02\x12\x04\xc5\x01\x11\x12\n\x0e\n\x06\
    \x04\x18\x04\0\x02\x01\x12\x04\xc6\x01\x08\x14\n\x0f\n\x07\x04\x18\x04\0\
    \x02\x01\x01\x12\x04\xc6\x01\x08\x0f\n\x0f\n\x07\x04\x18\x04\0\x02\x01\
    \x02\x12\x04\xc6\x01\x12\x13\n\x0e\n\x06\x04\x18\x04\0\x02\x02\x12\x04\
    \xc7\x01\x08\x13\n\x0f\n\x07\x04\x18\x04\0\x02\x02\x01\x12\x04\xc7\x01\
    \x08\x0e\n\x0f\n\x07\x04\x18\x04\0\x02\x02\x02\x12\x04\xc7\x01\x11\x12\n\
    \x0c\n\x04\x04\x18\x02\x04\x12\x04\xc9\x01\x04\x16\n\x0f\n\x05\x04\x18\
    \x02\x04\x04\x12\x06\xc9\x01\x04\xc8\x01\x05\n\r\n\x05\x04\x18\x02\x04\
    \x06\x12\x04\xc9\x01\x04\x0c\n\r\n\x05\x04\x18\x02\x04\x01\x12\x04\xc9\
    \x01\r\x11\n\r\n\x05\x04\x18\x02\x04\x03\x12\x04\xc9\x01\x14\x15\n\x0c\n\
    \x04\x04\x18\x02\x05\x12\x04\xca\x01\x04\x17\n\x0f\n\x05\x04\x18\x02\x05\
    \x04\x12\x06\xca\x01\x04\xc9\x01\x16\n\r\n\x05\x04\x18\x02\x05\x05\x12\
    \x04\xca\x01\x04\x08\n\r\n\x05\x04\x18\x02\x05\x01\x12\x04\xca\x01\t\x12\
    \n\r\n\x05\x04\x18\x02\x05\x03\x12\x04\xca\x01\x15\x16\n\x0c\n\x02\x04\
    \x19\x12\x06\xcd\x01\0\xd1\x01\x01\n\x0b\n\x03\x04\x19\x01\x12\x04\xcd\
    \x01\x08\x15\n\x0c\n\x04\x04\x19\x02\0\x12\x04\xce\x01\x04\x1e\n\x0f\n\
    \x05\x04\x19\x02\0\x04\x12\x06\xce\x01\x04\xcd\x01\x17\n\r\n\x05\x04\x19\
    \x02\0\x06\x12\x04\xce\x01\x04\x0e\n\r\n\x05\x04\x19\x02\0\x01\x12\x04\
    \xce\x01\x0f\x19\n\r\n\x05\x04\x19\x02\0\x03\x12\x04\xce\x01\x1c\x1d\n\
    \x0c\n\x04\x04\x19\x02\x01\x12\x04\xcf\x01\x04\x14\n\x0f\n\x05\x04\x19\
    \x02\x01\x04\x12\x06\xcf\x01\x04\xce\x01\x1e\n\r\n\x05\x04\x19\x02\x01\
    \x06\x12\x04\xcf\x01\x04\x08\n\r\n\x05\x04\x19\x02\x01\x01\x12\x04\xcf\
    \x01\t\x0f\n\r\n\x05\x04\x19\x02\x01\x03\x12\x04\xcf\x01\x12\x13\n\x0c\n\
    \x04\x04\x19\x02\x02\x12\x04\xd0\x01\x04\x14\n\x0f\n\x05\x04\x19\x02\x02\
    \x04\x12\x06\xd0\x01\x04\xcf\x01\x14\n\r\n\x05\x04\x19\x02\x02\x06\x12\
    \x04\xd0\x01\x04\x08\n\r\n\x05\x04\x19\x02\x02\x01\x12\x04\xd0\x01\t\x0f\
    \n\r\n\x05\x04\x19\x02\x02\x03\x12\x04\xd0\x01\x12\x13\n\x0c\n\x02\x04\
    \x1a\x12\x06\xd3\x01\0\xd7\x01\x01\n\x0b\n\x03\x04\x1a\x01\x12\x04\xd3\
    \x01\x08!\n\x0c\n\x04\x04\x1a\x02\0\x12\x04\xd4\x01\x04\x1e\n\x0f\n\x05\
    \x04\x1a\x02\0\x04\x12\x06\xd4\x01\x04\xd3\x01#\n\r\n\x05\x04\x1a\x02\0\
    \x06\x12\x04\xd4\x01\x04\x0e\n\r\n\x05\x04\x1a\x02\0\x01\x12\x04\xd4\x01\
    \x0f\x19\n\r\n\x05\x04\x1a\x02\0\x03\x12\x04\xd4\x01\x1c\x1d\n\x0c\n\x04\
    \x04\x1a\x02\x01\x12\x04\xd5\x01\x04\x12\n\x0f\n\x05\x04\x1a\x02\x01\x04\
    \x12\x06\xd5\x01\x04\xd4\x01\x1e\n\r\n\x05\x04\x1a\x02\x01\x06\x12\x04\
    \xd5\x01\x04\x08\n\r\n\x05\x04\x1a\x02\x01\x01\x12\x04\xd5\x01\t\r\n\r\n\
    \x05\x04\x1a\x02\x01\x03\x12\x04\xd5\x01\x10\x11\n\x0c\n\x04\x04\x1a\x02\
    \x02\x12\x04\xd6\x01\x04\x14\n\x0f\n\x05\x04\x1a\x02\x02\x04\x12\x06\xd6\
    \x01\x04\xd5\x01\x12\n\r\n\x05\x04\x1a\x02\x02\x06\x12\x04\xd6\x01\x04\
    \x08\n\r\n\x05\x04\x1a\x02\x02\x01\x12\x04\xd6\x01\t\x0f\n\r\n\x05\x04\
    \x1a\x02\x02\x03\x12\x04\xd6\x01\x12\x13\n\x0c\n\x02\x04\x1b\x12\x06\xd9\
    \x01\0\xdb\x01\x01\n\x0b\n\x03\x04\x1b\x01\x12\x04\xd9\x01\x08\x15\n\x0c\
    \n\x04\x04\x1b\x02\0\x12\x04\xda\x01\x04\x12\n\x0f\n\x05\x04\x1b\x02\0\
    \x04\x12\x06\xda\x01\x04\xd9\x01\x17\n\r\n\x05\x04\x1b\x02\0\x05\x12\x04\
    \xda\x01\x04\n\n\r\n\x05\x04\x1b\x02\0\x01\x12\x04\xda\x01\x0b\r\n\r\n\
    \x05\x04\x1b\x02\0\x03\x12\x04\xda\x01\x10\x11\n\x0c\n\x02\x04\x1c\x12\
    \x06\xdd\x01\0\xe0\x01\x01\n\x0b\n\x03\x04\x1c\x01\x12\x04\xdd\x01\x08\
    \x1c\n\x0c\n\x04\x04\x1c\x02\0\x12\x04\xde\x01\x04\x1e\n\x0f\n\x05\x04\
    \x1c\x02\0\x04\x12\x06\xde\x01\x04\xdd\x01\x1e\n\r\n\x05\x04\x1c\x02\0\
    \x06\x12\x04\xde\x01\x04\x0e\n\r\n\x05\x04\x1c\x02\0\x01\x12\x04\xde\x01\
    \x0f\x19\n\r\n\x05\x04\x1c\x02\0\x03\x12\x04\xde\x01\x1c\x1d\n\x0c\n\x04\
    \x04\x1c\x02\x01\x12\x04\xdf\x01\x04%\n\x0f\n\x05\x04\x1c\x02\x01\x04\
    \x12\x06\xdf\x01\x04\xde\x01\x1e\n\r\n\x05\x04\x1c\x02\x01\x06\x12\x04\
    \xdf\x01\x04\x11\n\r\n\x05\x04\x1c\x02\x01\x01\x12\x04\xdf\x01\x12\x20\n\
    \r\n\x05\x04\x1c\x02\x01\x03\x12\x04\xdf\x01#$\n\x0c\n\x02\x04\x1d\x12\
    \x06\xe2\x01\0\xe6\x01\x01\n\x0b\n\x03\x04\x1d\x01\x12\x04\xe2\x01\x08\
    \x1c\n\x0c\n\x04\x04\x1d\x02\0\x12\x04\xe3\x01\x04\x1e\n\x0f\n\x05\x04\
    \x1d\x02\0\x04\x12\x06\xe3\x01\x04\xe2\x01\x1e\n\r\n\x05\x04\x1d\x02\0\
    \x06\x12\x04\xe3\x01\x04\x0e\n\r\n\x05\x04\x1d\x02\0\x01\x12\x04\xe3\x01\
    \x0f\x19\n\r\n\x05\x04\x1d\x02\0\x03\x12\x04\xe3\x01\x1c\x1d\n\x0c\n\x04\
    \x04\x1d\x02\x01\x12\x04\xe4\x01\x04%\n\x0f\n\x05\x04\x1d\x02\x01\x04\
    \x12\x06\xe4\x01\x04\xe3\x01\x1e\n\r\n\x05\x04\x1d\x02\x01\x06\x12\x04\
    \xe4\x01\x04\x11\n\r\n\x05\x04\x1d\x02\x01\x01\x12\x04\xe4\x01\x12\x20\n\
    \r\n\x05\x04\x1d\x02\x01\x03\x12\x04\xe4\x01#$\n\x0c\n\x04\x04\x1d\x02\
    \x02\x12\x04\xe5\x01\x04\x17\n\x0f\n\x05\x04\x1d\x02\x02\x04\x12\x06\xe5\
    \x01\x04\xe4\x01%\n\r\n\x05\x04\x1d\x02\x02\x05\x12\x04\xe5\x01\x04\n\n\
    \r\n\x05\x04\x1d\x02\x02\x01\x12\x04\xe5\x01\x0b\x12\n\r\n\x05\x04\x1d\
    \x02\x02\x03\x12\x04\xe5\x01\x15\x16\n\x0c\n\x02\x04\x1e\x12\x06\xe8\x01\
    \0\xff\x01\x01\n\x0b\n\x03\x04\x1e\x01\x12\x04\xe8\x01\x08\x12\n\x0c\n\
    \x04\x04\x1e\x02\0\x12\x04\xe9\x01\x04%\n\x0f\n\x05\x04\x1e\x02\0\x04\
    \x12\x06\xe9\x01\x04\xe8\x01\x14\n\r\n\x05\x04\x1e\x02\0\x06\x12\x04\xe9\
    \x01\x04\x11\n\r\n\x05\x04\x1e\x02\0\x01\x12\x04\xe9\x01\x12\x20\n\r\n\
    \x05\x04\x1e\x02\0\x03\x12\x04\xe9\x01#$\n\x0c\n\x04\x04\x1e\x02\x01\x12\
    \x04\xea\x01\x04\x1c\n\x0f\n\x05\x04\x1e\x02\x01\x04\x12\x06\xea\x01\x04\
    \xe9\x01%\n\r\n\x05\x04\x1e\x02\x01\x05\x12\x04\xea\x01\x04\n\n\r\n\x05\
    \x04\x1e\x02\x01\x01\x12\x04\xea\x01\x0b\x17\n\r\n\x05\x04\x1e\x02\x01\
    \x03\x12\x04\xea\x01\x1a\x1b\n\x0c\n\x04\x04\x1e\x02\x02\x12\x04\xeb\x01\
    \x04\x1d\n\x0f\n\x05\x04\x1e\x02\x02\x04\x12\x06\xeb\x01\x04\xea\x01\x1c\
    \n\r\n\x05\x04\x1e\x02\x02\x05\x12\x04\xeb\x01\x04\n\n\r\n\x05\x04\x1e\
    \x02\x02\x01\x12\x04\xeb\x01\x0b\x18\n\r\n\x05\x04\x1e\x02\x02\x03\x12\
    \x04\xeb\x01\x1b\x1c\n\x0c\n\x04\x04\x1e\x02\x03\x12\x04\xec\x01\x04\x12\
    \n\x0f\n\x05\x04\x1e\x02\x03\x04\x12\x06\xec\x01\x04\xeb\x01\x1d\n\r\n\
    \x05\x04\x1e\x02\x03\x05\x12\x04\xec\x01\x04\x08\n\r\n\x05\x04\x1e\x02\
    \x03\x01\x12\x04\xec\x01\t\r\n\r\n\x05\x04\x1e\x02\x03\x03\x12\x04\xec\
    \x01\x10\x11\n\x0c\n\x04\x04\x1e\x02\x04\x12\x04\xed\x01\x04\x15\n\x0f\n\
    \x05\x04\x1e\x02\x04\x04\x12\x06\xed\x01\x04\xec\x01\x12\n\r\n\x05\x04\
    \x1e\x02\x04\x05\x12\x04\xed\x01\x04\x08\n\r\n\x05\x04\x1e\x02\x04\x01\
    \x12\x04\xed\x01\t\x10\n\r\n\x05\x04\x1e\x02\x04\x03\x12\x04\xed\x01\x13\
    \x14\n\x0c\n\x04\x04\x1e\x02\x05\x12\x04\xee\x01\x04\x15\n\x0f\n\x05\x04\
    \x1e\x02\x05\x04\x12\x06\xee\x01\x04\xed\x01\x15\n\r\n\x05\x04\x1e\x02\
    \x05\x05\x12\x04\xee\x01\x04\n\n\r\n\x05\x04\x1e\x02\x05\x01\x12\x04\xee\
    \x01\x0b\x10\n\r\n\x05\x04\x1e\x02\x05\x03\x12\x04\xee\x01\x13\x14\n\x0c\
    \n\x04\x04\x1e\x02\x06\x12\x04\xef\x01\x04\x1d\n\x0f\n\x05\x04\x1e\x02\
    \x06\x04\x12\x06\xef\x01\x04\xee\x01\x15\n\r\n\x05\x04\x1e\x02\x06\x05\
    \x12\x04\xef\x01\x04\n\n\r\n\x05\x04\x1e\x02\x06\x01\x12\x04\xef\x01\x0b\
    \x18\n\r\n\x05\x04\x1e\x02\x06\x03\x12\x04\xef\x01\x1b\x1c\n\x0e\n\x04\
    \x04\x1e\x04\0\x12\x06\xf0\x01\x04\xfd\x01\x05\n\r\n\x05\x04\x1e\x04\0\
    \x01\x12\x04\xf0\x01\t\x12\n\x1a\n\x06\x04\x1e\x04\0\x02\0\x12\x04\xf2\
    \x01\x08\x11\x1a\n\x20No\x20error\n\n\x0f\n\x07\x04\x1e\x04\0\x02\0\x01\
    \x12\x04\xf2\x01\x08\x0c\n\x0f\n\x07\x04\x1e\x04\0\x02\0\x02\x12\x04\xf2\
    \x01\x0f\x10\n%\n\x06\x04\x1e\x04\0\x02\x01\x12\x04\xf4\x01\x08\x16\x1a\
    \x15\x20NoSuchPathException\n\n\x0f\n\x07\x04\x1e\x04\0\x02\x01\x01\x12\
    \x04\xf4\x01\x08\x11\n\x0f\n\x07\x04\x1e\x04\0\x02\x01\x02\x12\x04\xf4\
    \x01\x14\x15\n(\n\x06\x04\x1e\x04\0\x02\x02\x12\x04\xf6\x01\x08\x16\x1a\
    \x18\x20CopyCancelledException\n\n\x0f\n\x07\x04\x1e\x04\0\x02\x02\x01\
    \x12\x04\xf6\x01\x08\x11\n\x0f\n\x07\x04\x1e\x04\0\x02\x02\x02\x12\x04\
    \xf6\x01\x14\x15\n,\n\x06\x04\x1e\x04\0\x02\x03\x12\x04\xf8\x01\x08\x1b\
    \x1a\x1c\x20PathAlreadyExistsException\n\n\x0f\n\x07\x04\x1e\x04\0\x02\
    \x03\x01\x12\x04\xf8\x01\x08\x16\n\x0f\n\x07\x04\x1e\x04\0\x02\x03\x02\
    \x12\x04\xf8\x01\x19\x1a\n'\n\x06\x04\x1e\x04\0\x02\x04\x12\x04\xfa\x01\
    \x08\x1a\x1a\x17\x20NotConnectedException\n\n\x0f\n\x07\x04\x1e\x04\0\
    \x02\x04\x01\x12\x04\xfa\x01\x08\x15\n\x0f\n\x07\x04\x1e\x04\0\x02\x04\
    \x02\x12\x04\xfa\x01\x18\x19\n\x20\n\x06\x04\x1e\x04\0\x02\x05\x12\x04\
    \xfc\x01\x08\x12\x1a\x10\x20XenonException\n\n\x0f\n\x07\x04\x1e\x04\0\
    \x02\x05\x01\x12\x04\xfc\x01\x08\r\n\x0f\n\x07\x04\x1e\x04\0\x02\x05\x02\
    \x12\x04\xfc\x01\x10\x11\n\x0c\n\x04\x04\x1e\x02\x07\x12\x04\xfe\x01\x04\
    \x1d\n\x0f\n\x05\x04\x1e\x02\x07\x04\x12\x06\xfe\x01\x04\xfd\x01\x05\n\r\
    \n\x05\x04\x1e\x02\x07\x06\x12\x04\xfe\x01\x04\r\n\r\n\x05\x04\x1e\x02\
    \x07\x01\x12\x04\xfe\x01\x0e\x18\n\r\n\x05\x04\x1e\x02\x07\x03\x12\x04\
    \xfe\x01\x1b\x1c\n\x0c\n\x02\x05\0\x12\x06\x81\x02\0\x8c\x02\x01\n\x0b\n\
    \x03\x05\0\x01\x12\x04\x81\x02\x05\x18\n\x0c\n\x04\x05\0\x02\0\x12\x04\
    \x82\x02\x04\r\n\r\n\x05\x05\0\x02\0\x01\x12\x04\x82\x02\x04\x08\n\r\n\
    \x05\x05\0\x02\0\x02\x12\x04\x82\x02\x0b\x0c\n\x0c\n\x04\x05\0\x02\x01\
    \x12\x04\x83\x02\x04\x13\n\r\n\x05\x05\0\x02\x01\x01\x12\x04\x83\x02\x04\
    \x0e\n\r\n\x05\x05\0\x02\x01\x02\x12\x04\x83\x02\x11\x12\n\x0c\n\x04\x05\
    \0\x02\x02\x12\x04\x84\x02\x04\x14\n\r\n\x05\x05\0\x02\x02\x01\x12\x04\
    \x84\x02\x04\x0f\n\r\n\x05\x05\0\x02\x02\x02\x12\x04\x84\x02\x12\x13\n\
    \x0c\n\x04\x05\0\x02\x03\x12\x04\x85\x02\x04\x16\n\r\n\x05\x05\0\x02\x03\
    \x01\x12\x04\x85\x02\x04\x11\n\r\n\x05\x05\0\x02\x03\x02\x12\x04\x85\x02\
    \x14\x15\n\x0c\n\x04\x05\0\x02\x04\x12\x04\x86\x02\x04\x13\n\r\n\x05\x05\
    \0\x02\x04\x01\x12\x04\x86\x02\x04\x0e\n\r\n\x05\x05\0\x02\x04\x02\x12\
    \x04\x86\x02\x11\x12\n\x0c\n\x04\x05\0\x02\x05\x12\x04\x87\x02\x04\x14\n\
    \r\n\x05\x05\0\x02\x05\x01\x12\x04\x87\x02\x04\x0f\n\r\n\x05\x05\0\x02\
    \x05\x02\x12\x04\x87\x02\x12\x13\n\x0c\n\x04\x05\0\x02\x06\x12\x04\x88\
    \x02\x04\x16\n\r\n\x05\x05\0\x02\x06\x01\x12\x04\x88\x02\x04\x11\n\r\n\
    \x05\x05\0\x02\x06\x02\x12\x04\x88\x02\x14\x15\n\x0c\n\x04\x05\0\x02\x07\
    \x12\x04\x89\x02\x04\x14\n\r\n\x05\x05\0\x02\x07\x01\x12\x04\x89\x02\x04\
    \x0f\n\r\n\x05\x05\0\x02\x07\x02\x12\x04\x89\x02\x12\x13\n\x0c\n\x04\x05\
    \0\x02\x08\x12\x04\x8a\x02\x04\x15\n\r\n\x05\x05\0\x02\x08\x01\x12\x04\
    \x8a\x02\x04\x10\n\r\n\x05\x05\0\x02\x08\x02\x12\x04\x8a\x02\x13\x14\n\
    \x0c\n\x04\x05\0\x02\t\x12\x04\x8b\x02\x04\x17\n\r\n\x05\x05\0\x02\t\x01\
    \x12\x04\x8b\x02\x04\x12\n\r\n\x05\x05\0\x02\t\x02\x12\x04\x8b\x02\x15\
    \x16\n\x0c\n\x02\x04\x1f\x12\x06\x8e\x02\0\x9f\x02\x01\n\x0b\n\x03\x04\
    \x1f\x01\x12\x04\x8e\x02\x08\x16\n\x0c\n\x04\x04\x1f\x02\0\x12\x04\x8f\
    \x02\x04\x12\n\x0f\n\x05\x04\x1f\x02\0\x04\x12\x06\x8f\x02\x04\x8e\x02\
    \x18\n\r\n\x05\x04\x1f\x02\0\x06\x12\x04\x8f\x02\x04\x08\n\r\n\x05\x04\
    \x1f\x02\0\x01\x12\x04\x8f\x02\t\r\n\r\n\x05\x04\x1f\x02\0\x03\x12\x04\
    \x8f\x02\x10\x11\n\x0c\n\x04\x04\x1f\x02\x01\x12\x04\x90\x02\x04\x1d\n\
    \x0f\n\x05\x04\x1f\x02\x01\x04\x12\x06\x90\x02\x04\x8f\x02\x12\n\r\n\x05\
    \x04\x1f\x02\x01\x05\x12\x04\x90\x02\x04\n\n\r\n\x05\x04\x1f\x02\x01\x01\
    \x12\x04\x90\x02\x0b\x18\n\r\n\x05\x04\x1f\x02\x01\x03\x12\x04\x90\x02\
    \x1b\x1c\n\x0c\n\x04\x04\x1f\x02\x02\x12\x04\x91\x02\x04\x15\n\x0f\n\x05\
    \x04\x1f\x02\x02\x04\x12\x06\x91\x02\x04\x90\x02\x1d\n\r\n\x05\x04\x1f\
    \x02\x02\x05\x12\x04\x91\x02\x04\n\n\r\n\x05\x04\x1f\x02\x02\x01\x12\x04\
    \x91\x02\x0b\x10\n\r\n\x05\x04\x1f\x02\x02\x03\x12\x04\x91\x02\x13\x14\n\
    \x0c\n\x04\x04\x1f\x02\x03\x12\x04\x92\x02\x04\x1a\n\x0f\n\x05\x04\x1f\
    \x02\x03\x04\x12\x06\x92\x02\x04\x91\x02\x15\n\r\n\x05\x04\x1f\x02\x03\
    \x05\x12\x04\x92\x02\x04\x08\n\r\n\x05\x04\x1f\x02\x03\x01\x12\x04\x92\
    \x02\t\x15\n\r\n\x05\x04\x1f\x02\x03\x03\x12\x04\x92\x02\x18\x19\n\x0c\n\
    \x04\x04\x1f\x02\x04\x12\x04\x93\x02\x04\x1b\n\x0f\n\x05\x04\x1f\x02\x04\
    \x04\x12\x06\x93\x02\x04\x92\x02\x1a\n\r\n\x05\x04\x1f\x02\x04\x05\x12\
    \x04\x93\x02\x04\x08\n\r\n\x05\x04\x1f\x02\x04\x01\x12\x04\x93\x02\t\x16\
    \n\r\n\x05\x04\x1f\x02\x04\x03\x12\x04\x93\x02\x19\x1a\n\x0c\n\x04\x04\
    \x1f\x02\x05\x12\x04\x94\x02\x04\x17\n\x0f\n\x05\x04\x1f\x02\x05\x04\x12\
    \x06\x94\x02\x04\x93\x02\x1b\n\r\n\x05\x04\x1f\x02\x05\x05\x12\x04\x94\
    \x02\x04\x08\n\r\n\x05\x04\x1f\x02\x05\x01\x12\x04\x94\x02\t\x12\n\r\n\
    \x05\x04\x1f\x02\x05\x03\x12\x04\x94\x02\x15\x16\n\x0c\n\x04\x04\x1f\x02\
    \x06\x12\x04\x95\x02\x04\x16\n\x0f\n\x05\x04\x1f\x02\x06\x04\x12\x06\x95\
    \x02\x04\x94\x02\x17\n\r\n\x05\x04\x1f\x02\x06\x05\x12\x04\x95\x02\x04\
    \x08\n\r\n\x05\x04\x1f\x02\x06\x01\x12\x04\x95\x02\t\x11\n\r\n\x05\x04\
    \x1f\x02\x06\x03\x12\x04\x95\x02\x14\x15\n\x0c\n\x04\x04\x1f\x02\x07\x12\
    \x04\x96\x02\x04\x19\n\x0f\n\x05\x04\x1f\x02\x07\x04\x12\x06\x96\x02\x04\
    \x95\x02\x16\n\r\n\x05\x04\x1f\x02\x07\x05\x12\x04\x96\x02\x04\x08\n\r\n\
    \x05\x04\x1f\x02\x07\x01\x12\x04\x96\x02\t\x14\n\r\n\x05\x04\x1f\x02\x07\
    \x03\x12\x04\x96\x02\x17\x18\n\x0c\n\x04\x04\x1f\x02\x08\x12\x04\x97\x02\
    \x04\x18\n\x0f\n\x05\x04\x1f\x02\x08\x04\x12\x06\x97\x02\x04\x96\x02\x19\
    \n\r\n\x05\x04\x1f\x02\x08\x05\x12\x04\x97\x02\x04\x08\n\r\n\x05\x04\x1f\
    \x02\x08\x01\x12\x04\x97\x02\t\x13\n\r\n\x05\x04\x1f\x02\x08\x03\x12\x04\
    \x97\x02\x16\x17\n\x0c\n\x04\x04\x1f\x02\t\x12\x04\x98\x02\x04\x1f\n\x0f\
    \n\x05\x04\x1f\x02\t\x04\x12\x06\x98\x02\x04\x97\x02\x18\n\r\n\x05\x04\
    \x1f\x02\t\x05\x12\x04\x98\x02\x04\x08\n\r\n\x05\x04\x1f\x02\t\x01\x12\
    \x04\x98\x02\t\x19\n\r\n\x05\x04\x1f\x02\t\x03\x12\x04\x98\x02\x1c\x1e\n\
    \x0c\n\x04\x04\x1f\x02\n\x12\x04\x99\x02\x04\x1a\n\x0f\n\x05\x04\x1f\x02\
    \n\x04\x12\x06\x99\x02\x04\x98\x02\x1f\n\r\n\x05\x04\x1f\x02\n\x05\x12\
    \x04\x99\x02\x04\x08\n\r\n\x05\x04\x1f\x02\n\x01\x12\x04\x99\x02\t\x14\n\
    \r\n\x05\x04\x1f\x02\n\x03\x12\x04\x99\x02\x17\x19\n\x0c\n\x04\x04\x1f\
    \x02\x0b\x12\x04\x9a\x02\x04!\n\x0f\n\x05\x04\x1f\x02\x0b\x04\x12\x06\
    \x9a\x02\x04\x99\x02\x1a\n\r\n\x05\x04\x1f\x02\x0b\x05\x12\x04\x9a\x02\
    \x04\n\n\r\n\x05\x04\x1f\x02\x0b\x01\x12\x04\x9a\x02\x0b\x1b\n\r\n\x05\
    \x04\x1f\x02\x0b\x03\x12\x04\x9a\x02\x1e\x20\n\x0c\n\x04\x04\x1f\x02\x0c\
    \x12\x04\x9b\x02\x04#\n\x0f\n\x05\x04\x1f\x02\x0c\x04\x12\x06\x9b\x02\
    \x04\x9a\x02!\n\r\n\x05\x04\x1f\x02\x0c\x05\x12\x04\x9b\x02\x04\n\n\r\n\
    \x05\x04\x1f\x02\x0c\x01\x12\x04\x9b\x02\x0b\x1d\n\r\n\x05\x04\x1f\x02\
    \x0c\x03\x12\x04\x9b\x02\x20\"\n\x0c\n\x04\x04\x1f\x02\r\x12\x04\x9c\x02\
    \x04\x16\n\x0f\n\x05\x04\x1f\x02\r\x04\x12\x06\x9c\x02\x04\x9b\x02#\n\r\
    \n\x05\x04\x1f\x02\r\x05\x12\x04\x9c\x02\x04\n\n\r\n\x05\x04\x1f\x02\r\
    \x01\x12\x04\x9c\x02\x0b\x10\n\r\n\x05\x04\x1f\x02\r\x03\x12\x04\x9c\x02\
    \x13\x15\n\x0c\n\x04\x04\x1f\x02\x0e\x12\x04\x9d\x02\x042\n\r\n\x05\x04\
    \x1f\x02\x0e\x04\x12\x04\x9d\x02\x04\x0c\n\r\n\x05\x04\x1f\x02\x0e\x06\
    \x12\x04\x9d\x02\r\x20\n\r\n\x05\x04\x1f\x02\x0e\x01\x12\x04\x9d\x02!,\n\
    \r\n\x05\x04\x1f\x02\x0e\x03\x12\x04\x9d\x02/1\n\x0c\n\x04\x04\x1f\x02\
    \x0f\x12\x04\x9e\x02\x04\x15\n\x0f\n\x05\x04\x1f\x02\x0f\x04\x12\x06\x9e\
    \x02\x04\x9d\x022\n\r\n\x05\x04\x1f\x02\x0f\x05\x12\x04\x9e\x02\x04\n\n\
    \r\n\x05\x04\x1f\x02\x0f\x01\x12\x04\x9e\x02\x0b\x0f\n\r\n\x05\x04\x1f\
    \x02\x0f\x03\x12\x04\x9e\x02\x12\x14\n\x0c\n\x02\x04\x20\x12\x06\xa1\x02\
    \0\xa5\x02\x01\n\x0b\n\x03\x04\x20\x01\x12\x04\xa1\x02\x08&\n\x0c\n\x04\
    \x04\x20\x02\0\x12\x04\xa2\x02\x04\x1e\n\x0f\n\x05\x04\x20\x02\0\x04\x12\
    \x06\xa2\x02\x04\xa1\x02(\n\r\n\x05\x04\x20\x02\0\x06\x12\x04\xa2\x02\
    \x04\x0e\n\r\n\x05\x04\x20\x02\0\x01\x12\x04\xa2\x02\x0f\x19\n\r\n\x05\
    \x04\x20\x02\0\x03\x12\x04\xa2\x02\x1c\x1d\n\x0c\n\x04\x04\x20\x02\x01\
    \x12\x04\xa3\x02\x04\x12\n\x0f\n\x05\x04\x20\x02\x01\x04\x12\x06\xa3\x02\
    \x04\xa2\x02\x1e\n\r\n\x05\x04\x20\x02\x01\x06\x12\x04\xa3\x02\x04\x08\n\
    \r\n\x05\x04\x20\x02\x01\x01\x12\x04\xa3\x02\t\r\n\r\n\x05\x04\x20\x02\
    \x01\x03\x12\x04\xa3\x02\x10\x11\n\x0c\n\x04\x04\x20\x02\x02\x12\x04\xa4\
    \x02\x041\n\r\n\x05\x04\x20\x02\x02\x04\x12\x04\xa4\x02\x04\x0c\n\r\n\
    \x05\x04\x20\x02\x02\x06\x12\x04\xa4\x02\r\x20\n\r\n\x05\x04\x20\x02\x02\
    \x01\x12\x04\xa4\x02!,\n\r\n\x05\x04\x20\x02\x02\x03\x12\x04\xa4\x02/0\n\
    \x0c\n\x02\x04!\x12\x06\xa7\x02\0\xa9\x02\x01\n\x0b\n\x03\x04!\x01\x12\
    \x04\xa7\x02\x08\x1c\n\x0c\n\x04\x04!\x02\0\x12\x04\xa8\x02\x04\x15\n\
    \x0f\n\x05\x04!\x02\0\x04\x12\x06\xa8\x02\x04\xa7\x02\x1e\n\r\n\x05\x04!\
    \x02\0\x05\x12\x04\xa8\x02\x04\t\n\r\n\x05\x04!\x02\0\x01\x12\x04\xa8\
    \x02\n\x10\n\r\n\x05\x04!\x02\0\x03\x12\x04\xa8\x02\x13\x14\n\x0c\n\x02\
    \x04\"\x12\x06\xab\x02\0\xb0\x02\x01\n\x0b\n\x03\x04\"\x01\x12\x04\xab\
    \x02\x08\x1a\n\x0c\n\x04\x04\"\x02\0\x12\x04\xac\x02\x04\x1e\n\x0f\n\x05\
    \x04\"\x02\0\x04\x12\x06\xac\x02\x04\xab\x02\x1c\n\r\n\x05\x04\"\x02\0\
    \x06\x12\x04\xac\x02\x04\x0e\n\r\n\x05\x04\"\x02\0\x01\x12\x04\xac\x02\
    \x0f\x19\n\r\n\x05\x04\"\x02\0\x03\x12\x04\xac\x02\x1c\x1d\n\x0c\n\x04\
    \x04\"\x02\x01\x12\x04\xad\x02\x04\x12\n\x0f\n\x05\x04\"\x02\x01\x04\x12\
    \x06\xad\x02\x04\xac\x02\x1e\n\r\n\x05\x04\"\x02\x01\x06\x12\x04\xad\x02\
    \x04\x08\n\r\n\x05\x04\"\x02\x01\x01\x12\x04\xad\x02\t\r\n\r\n\x05\x04\"\
    \x02\x01\x03\x12\x04\xad\x02\x10\x11\n\x0c\n\x04\x04\"\x02\x02\x12\x04\
    \xae\x02\x04\x15\n\x0f\n\x05\x04\"\x02\x02\x04\x12\x06\xae\x02\x04\xad\
    \x02\x12\n\r\n\x05\x04\"\x02\x02\x05\x12\x04\xae\x02\x04\t\n\r\n\x05\x04\
    \"\x02\x02\x01\x12\x04\xae\x02\n\x10\n\r\n\x05\x04\"\x02\x02\x03\x12\x04\
    \xae\x02\x13\x14\n\x0c\n\x04\x04\"\x02\x03\x12\x04\xaf\x02\x04\x14\n\x0f\
    \n\x05\x04\"\x02\x03\x04\x12\x06\xaf\x02\x04\xae\x02\x15\n\r\n\x05\x04\"\
    \x02\x03\x05\x12\x04\xaf\x02\x04\n\n\r\n\x05\x04\"\x02\x03\x01\x12\x04\
    \xaf\x02\x0b\x0f\n\r\n\x05\x04\"\x02\x03\x03\x12\x04\xaf\x02\x12\x13\n\
    \x0c\n\x02\x04#\x12\x06\xb2\x02\0\xb6\x02\x01\n\x0b\n\x03\x04#\x01\x12\
    \x04\xb2\x02\x08\x1b\n\x0c\n\x04\x04#\x02\0\x12\x04\xb3\x02\x04\x1e\n\
    \x0f\n\x05\x04#\x02\0\x04\x12\x06\xb3\x02\x04\xb2\x02\x1d\n\r\n\x05\x04#\
    \x02\0\x06\x12\x04\xb3\x02\x04\x0e\n\r\n\x05\x04#\x02\0\x01\x12\x04\xb3\
    \x02\x0f\x19\n\r\n\x05\x04#\x02\0\x03\x12\x04\xb3\x02\x1c\x1d\n\x0c\n\
    \x04\x04#\x02\x01\x12\x04\xb4\x02\x04\x12\n\x0f\n\x05\x04#\x02\x01\x04\
    \x12\x06\xb4\x02\x04\xb3\x02\x1e\n\r\n\x05\x04#\x02\x01\x06\x12\x04\xb4\
    \x02\x04\x08\n\r\n\x05\x04#\x02\x01\x01\x12\x04\xb4\x02\t\r\n\r\n\x05\
    \x04#\x02\x01\x03\x12\x04\xb4\x02\x10\x11\n\x0c\n\x04\x04#\x02\x02\x12\
    \x04\xb5\x02\x04\x15\n\x0f\n\x05\x04#\x02\x02\x04\x12\x06\xb5\x02\x04\
    \xb4\x02\x12\n\r\n\x05\x04#\x02\x02\x05\x12\x04\xb5\x02\x04\t\n\r\n\x05\
    \x04#\x02\x02\x01\x12\x04\xb5\x02\n\x10\n\r\n\x05\x04#\x02\x02\x03\x12\
    \x04\xb5\x02\x13\x14\n\x0c\n\x02\x04$\x12\x06\xb8\x02\0\xbc\x02\x01\n\
    \x0b\n\x03\x04$\x01\x12\x04\xb8\x02\x08\x13\n\x0c\n\x04\x04$\x02\0\x12\
    \x04\xb9\x02\x04\x1e\n\x0f\n\x05\x04$\x02\0\x04\x12\x06\xb9\x02\x04\xb8\
    \x02\x15\n\r\n\x05\x04$\x02\0\x06\x12\x04\xb9\x02\x04\x0e\n\r\n\x05\x04$\
    \x02\0\x01\x12\x04\xb9\x02\x0f\x19\n\r\n\x05\x04$\x02\0\x03\x12\x04\xb9\
    \x02\x1c\x1d\n\x0c\n\x04\x04$\x02\x01\x12\x04\xba\x02\x04\x11\n\x0f\n\
    \x05\x04$\x02\x01\x04\x12\x06\xba\x02\x04\xb9\x02\x1e\n\r\n\x05\x04$\x02\
    \x01\x06\x12\x04\xba\x02\x04\x08\n\r\n\x05\x04$\x02\x01\x01\x12\x04\xba\
    \x02\t\x0c\n\r\n\x05\x04$\x02\x01\x03\x12\x04\xba\x02\x0f\x10\n\x0c\n\
    \x04\x04$\x02\x02\x12\x04\xbb\x02\x04\x17\n\x0f\n\x05\x04$\x02\x02\x04\
    \x12\x06\xbb\x02\x04\xba\x02\x11\n\r\n\x05\x04$\x02\x02\x05\x12\x04\xbb\
    \x02\x04\x08\n\r\n\x05\x04$\x02\x02\x01\x12\x04\xbb\x02\t\x12\n\r\n\x05\
    \x04$\x02\x02\x03\x12\x04\xbb\x02\x15\x16\n\x0c\n\x02\x04%\x12\x06\xbe\
    \x02\0\xc0\x02\x01\n\x0b\n\x03\x04%\x01\x12\x04\xbe\x02\x08\x20\n\x0c\n\
    \x04\x04%\x02\0\x12\x04\xbf\x02\x04\x19\n\x0f\n\x05\x04%\x02\0\x04\x12\
    \x06\xbf\x02\x04\xbe\x02\"\n\r\n\x05\x04%\x02\0\x05\x12\x04\xbf\x02\x04\
    \n\n\r\n\x05\x04%\x02\0\x01\x12\x04\xbf\x02\x0b\x14\n\r\n\x05\x04%\x02\0\
    \x03\x12\x04\xbf\x02\x17\x18\n\x0c\n\x02\x04&\x12\x06\xc2\x02\0\xcd\x02\
    \x01\n\x0b\n\x03\x04&\x01\x12\x04\xc2\x02\x08\x1e\n\x0c\n\x04\x04&\x02\0\
    \x12\x04\xc3\x02\x04\x17\n\x0f\n\x05\x04&\x02\0\x04\x12\x06\xc3\x02\x04\
    \xc2\x02\x20\n\r\n\x05\x04&\x02\0\x05\x12\x04\xc3\x02\x04\n\n\r\n\x05\
    \x04&\x02\0\x01\x12\x04\xc3\x02\x0b\x12\n\r\n\x05\x04&\x02\0\x03\x12\x04\
    \xc3\x02\x15\x16\n\x0c\n\x04\x04&\x02\x01\x12\x04\xc4\x02\x04\x18\n\x0f\
    \n\x05\x04&\x02\x01\x04\x12\x06\xc4\x02\x04\xc3\x02\x17\n\r\n\x05\x04&\
    \x02\x01\x05\x12\x04\xc4\x02\x04\n\n\r\n\x05\x04&\x02\x01\x01\x12\x04\
    \xc4\x02\x0b\x13\n\r\n\x05\x04&\x02\x01\x03\x12\x04\xc4\x02\x16\x17\n\
    \x0c\n\x04\x04&\x02\x02\x12\x04\xc5\x02\x04'\n\x0f\n\x05\x04&\x02\x02\
    \x04\x12\x06\xc5\x02\x04\xc4\x02\x18\n\r\n\x05\x04&\x02\x02\x06\x12\x04\
    \xc5\x02\x04\x17\n\r\n\x05\x04&\x02\x02\x01\x12\x04\xc5\x02\x18\"\n\r\n\
    \x05\x04&\x02\x02\x03\x12\x04\xc5\x02%&\n\x0e\n\x04\x04&\x08\0\x12\x06\
    \xc6\x02\x04\xcc\x02\x05\n\r\n\x05\x04&\x08\0\x01\x12\x04\xc6\x02\n\x14\
    \n\x0c\n\x04\x04&\x02\x03\x12\x04\xc7\x02\x089\n\r\n\x05\x04&\x02\x03\
    \x06\x12\x04\xc7\x02\x08\x1d\n\r\n\x05\x04&\x02\x03\x01\x12\x04\xc7\x02\
    \x1e4\n\r\n\x05\x04&\x02\x03\x03\x12\x04\xc7\x0278\n\x0c\n\x04\x04&\x02\
    \x04\x12\x04\xc8\x02\x083\n\r\n\x05\x04&\x02\x04\x06\x12\x04\xc8\x02\x08\
    \x1a\n\r\n\x05\x04&\x02\x04\x01\x12\x04\xc8\x02\x1b.\n\r\n\x05\x04&\x02\
    \x04\x03\x12\x04\xc8\x0212\n\x0c\n\x04\x04&\x02\x05\x12\x04\xc9\x02\x081\
    \n\r\n\x05\x04&\x02\x05\x06\x12\x04\xc9\x02\x08\x19\n\r\n\x05\x04&\x02\
    \x05\x01\x12\x04\xc9\x02\x1a,\n\r\n\x05\x04&\x02\x05\x03\x12\x04\xc9\x02\
    /0\n\x0c\n\x04\x04&\x02\x06\x12\x04\xca\x02\x08)\n\r\n\x05\x04&\x02\x06\
    \x06\x12\x04\xca\x02\x08\x15\n\r\n\x05\x04&\x02\x06\x01\x12\x04\xca\x02\
    \x16$\n\r\n\x05\x04&\x02\x06\x03\x12\x04\xca\x02'(\n\x0c\n\x04\x04&\x02\
    \x07\x12\x04\xcb\x02\x08/\n\r\n\x05\x04&\x02\x07\x06\x12\x04\xcb\x02\x08\
    \x18\n\r\n\x05\x04&\x02\x07\x01\x12\x04\xcb\x02\x19*\n\r\n\x05\x04&\x02\
    \x07\x03\x12\x04\xcb\x02-.\n1\n\x02\x04'\x12\x06\xd0\x02\0\xd2\x02\x01\
    \x1a#\x20Handle\x20for\x20Xenon\x20Scheduler\x20object\n\n\x0b\n\x03\x04\
    '\x01\x12\x04\xd0\x02\x08\x11\n\x0c\n\x04\x04'\x02\0\x12\x04\xd1\x02\x04\
    \x12\n\x0f\n\x05\x04'\x02\0\x04\x12\x06\xd1\x02\x04\xd0\x02\x13\n\r\n\
    \x05\x04'\x02\0\x05\x12\x04\xd1\x02\x04\n\n\r\n\x05\x04'\x02\0\x01\x12\
    \x04\xd1\x02\x0b\r\n\r\n\x05\x04'\x02\0\x03\x12\x04\xd1\x02\x10\x11\n\
    \x0c\n\x02\x04(\x12\x06\xd4\x02\0\xd6\x02\x01\n\x0b\n\x03\x04(\x01\x12\
    \x04\xd4\x02\x08\x12\n\x0c\n\x04\x04(\x02\0\x12\x04\xd5\x02\x04&\n\r\n\
    \x05\x04(\x02\0\x04\x12\x04\xd5\x02\x04\x0c\n\r\n\x05\x04(\x02\0\x06\x12\
    \x04\xd5\x02\r\x16\n\r\n\x05\x04(\x02\0\x01\x12\x04\xd5\x02\x17!\n\r\n\
    \x05\x04(\x02\0\x03\x12\x04\xd5\x02$%\n\x0c\n\x02\x04)\x12\x06\xd8\x02\0\
    \xec\x02\x01\n\x0b\n\x03\x04)\x01\x12\x04\xd8\x02\x08\x16\n\x0c\n\x04\
    \x04)\x02\0\x12\x04\xd9\x02\x04\x1a\n\x0f\n\x05\x04)\x02\0\x04\x12\x06\
    \xd9\x02\x04\xd8\x02\x18\n\r\n\x05\x04)\x02\0\x05\x12\x04\xd9\x02\x04\n\
    \n\r\n\x05\x04)\x02\0\x01\x12\x04\xd9\x02\x0b\x15\n\r\n\x05\x04)\x02\0\
    \x03\x12\x04\xd9\x02\x18\x19\n\x0c\n\x04\x04)\x02\x01\x12\x04\xda\x02\
    \x04\"\n\r\n\x05\x04)\x02\x01\x04\x12\x04\xda\x02\x04\x0c\n\r\n\x05\x04)\
    \x02\x01\x05\x12\x04\xda\x02\r\x13\n\r\n\x05\x04)\x02\x01\x01\x12\x04\
    \xda\x02\x14\x1d\n\r\n\x05\x04)\x02\x01\x03\x12\x04\xda\x02\x20!\n\x0c\n\
    \x04\x04)\x02\x02\x12\x04\xdb\x02\x04!\n\x0f\n\x05\x04)\x02\x02\x04\x12\
    \x06\xdb\x02\x04\xda\x02\"\n\r\n\x05\x04)\x02\x02\x05\x12\x04\xdb\x02\
    \x04\n\n\r\n\x05\x04)\x02\x02\x01\x12\x04\xdb\x02\x0b\x1c\n\r\n\x05\x04)\
    \x02\x02\x03\x12\x04\xdb\x02\x1f\x20\n\x0c\n\x04\x04)\x02\x03\x12\x04\
    \xdc\x02\x04(\n\x0f\n\x05\x04)\x02\x03\x04\x12\x06\xdc\x02\x04\xdb\x02!\
    \n\r\n\x05\x04)\x02\x03\x06\x12\x04\xdc\x02\x04\x17\n\r\n\x05\x04)\x02\
    \x03\x01\x12\x04\xdc\x02\x18#\n\r\n\x05\x04)\x02\x03\x03\x12\x04\xdc\x02\
    &'\n\x0c\n\x04\x04)\x02\x04\x12\x04\xdd\x02\x04\x1a\n\x0f\n\x05\x04)\x02\
    \x04\x04\x12\x06\xdd\x02\x04\xdc\x02(\n\r\n\x05\x04)\x02\x04\x05\x12\x04\
    \xdd\x02\x04\n\n\r\n\x05\x04)\x02\x04\x01\x12\x04\xdd\x02\x0b\x15\n\r\n\
    \x05\x04)\x02\x04\x03\x12\x04\xdd\x02\x18\x19\n\x0c\n\x04\x04)\x02\x05\
    \x12\x04\xde\x02\x04\x1b\n\x0f\n\x05\x04)\x02\x05\x04\x12\x06\xde\x02\
    \x04\xdd\x02\x1a\n\r\n\x05\x04)\x02\x05\x05\x12\x04\xde\x02\x04\n\n\r\n\
    \x05\x04)\x02\x05\x01\x12\x04\xde\x02\x0b\x16\n\r\n\x05\x04)\x02\x05\x03\
    \x12\x04\xde\x02\x19\x1a\n\x0c\n\x04\x04)\x02\x06\x12\x04\xdf\x02\x04\
    \x17\n\x0f\n\x05\x04)\x02\x06\x04\x12\x06\xdf\x02\x04\xde\x02\x1b\n\r\n\
    \x05\x04)\x02\x06\x05\x12\x04\xdf\x02\x04\n\n\r\n\x05\x04)\x02\x06\x01\
    \x12\x04\xdf\x02\x0b\x11\n\r\n\x05\x04)\x02\x06\x03\x12\x04\xdf\x02\x14\
    \x16\n\x0c\n\x04\x04)\x02\x07\x12\x04\xe0\x02\x04\x16\n\x0f\n\x05\x04)\
    \x02\x07\x04\x12\x06\xe0\x02\x04\xdf\x02\x17\n\r\n\x05\x04)\x02\x07\x05\
    \x12\x04\xe0\x02\x04\n\n\r\n\x05\x04)\x02\x07\x01\x12\x04\xe0\x02\x0b\
    \x10\n\r\n\x05\x04)\x02\x07\x03\x12\x04\xe0\x02\x13\x15\n\x0c\n\x04\x04)\
    \x02\x08\x12\x04\xe1\x02\x04\x17\n\x0f\n\x05\x04)\x02\x08\x04\x12\x06\
    \xe1\x02\x04\xe0\x02\x16\n\r\n\x05\x04)\x02\x08\x05\x12\x04\xe1\x02\x04\
    \n\n\r\n\x05\x04)\x02\x08\x01\x12\x04\xe1\x02\x0b\x11\n\r\n\x05\x04)\x02\
    \x08\x03\x12\x04\xe1\x02\x14\x16\n\x0c\n\x04\x04)\x02\t\x12\x04\xe2\x02\
    \x04\x15\n\x0f\n\x05\x04)\x02\t\x04\x12\x06\xe2\x02\x04\xe1\x02\x17\n\r\
    \n\x05\x04)\x02\t\x05\x12\x04\xe2\x02\x04\n\n\r\n\x05\x04)\x02\t\x01\x12\
    \x04\xe2\x02\x0b\x0f\n\r\n\x05\x04)\x02\t\x03\x12\x04\xe2\x02\x12\x14\n\
    \x0c\n\x04\x04)\x02\n\x12\x04\xe3\x02\x04\x1b\n\x0f\n\x05\x04)\x02\n\x04\
    \x12\x06\xe3\x02\x04\xe2\x02\x15\n\r\n\x05\x04)\x02\n\x05\x12\x04\xe3\
    \x02\x04\n\n\r\n\x05\x04)\x02\n\x01\x12\x04\xe3\x02\x0b\x15\n\r\n\x05\
    \x04)\x02\n\x03\x12\x04\xe3\x02\x18\x1a\n\x0c\n\x04\x04)\x02\x0b\x12\x04\
    \xe4\x02\x04-\n\r\n\x05\x04)\x02\x0b\x04\x12\x04\xe4\x02\x04\x0c\n\r\n\
    \x05\x04)\x02\x0b\x05\x12\x04\xe4\x02\r\x13\n\r\n\x05\x04)\x02\x0b\x01\
    \x12\x04\xe4\x02\x14'\n\r\n\x05\x04)\x02\x0b\x03\x12\x04\xe4\x02*,\n\x0c\
    \n\x04\x04)\x02\x0c\x12\x04\xe5\x02\x04\x16\n\x0f\n\x05\x04)\x02\x0c\x04\
    \x12\x06\xe5\x02\x04\xe4\x02-\n\r\n\x05\x04)\x02\x0c\x05\x12\x04\xe5\x02\
    \x04\n\n\r\n\x05\x04)\x02\x0c\x01\x12\x04\xe5\x02\x0b\x10\n\r\n\x05\x04)\
    \x02\x0c\x03\x12\x04\xe5\x02\x13\x15\n\x0c\n\x04\x04)\x02\r\x12\x04\xe6\
    \x02\x04\x1f\n\x0f\n\x05\x04)\x02\r\x04\x12\x06\xe6\x02\x04\xe5\x02\x16\
    \n\r\n\x05\x04)\x02\r\x05\x12\x04\xe6\x02\x04\n\n\r\n\x05\x04)\x02\r\x01\
    \x12\x04\xe6\x02\x0b\x19\n\r\n\x05\x04)\x02\r\x03\x12\x04\xe6\x02\x1c\
    \x1e\n\x0c\n\x04\x04)\x02\x0e\x12\x04\xe7\x02\x04\x1f\n\x0f\n\x05\x04)\
    \x02\x0e\x04\x12\x06\xe7\x02\x04\xe6\x02\x1f\n\r\n\x05\x04)\x02\x0e\x05\
    \x12\x04\xe7\x02\x04\n\n\r\n\x05\x04)\x02\x0e\x01\x12\x04\xe7\x02\x0b\
    \x19\n\r\n\x05\x04)\x02\x0e\x03\x12\x04\xe7\x02\x1c\x1e\nx\n\x04\x04)\
    \x02\x0f\x12\x04\xe9\x02\x04\x1d\x1aj\x20In\x20Xenon\x20if\x20true\x20th\
    en\x20uses\x20setStartPerTask\x20else\x20uses\x20setStartPerJob\x20to\
    \x20configure\x20how\x20to\x20start\x20executable\n\n\x0f\n\x05\x04)\x02\
    \x0f\x04\x12\x06\xe9\x02\x04\xe7\x02\x1f\n\r\n\x05\x04)\x02\x0f\x05\x12\
    \x04\xe9\x02\x04\x08\n\r\n\x05\x04)\x02\x0f\x01\x12\x04\xe9\x02\t\x17\n\
    \r\n\x05\x04)\x02\x0f\x03\x12\x04\xe9\x02\x1a\x1c\n\x0c\n\x04\x04)\x02\
    \x10\x12\x04\xea\x02\x04\x1b\n\x0f\n\x05\x04)\x02\x10\x04\x12\x06\xea\
    \x02\x04\xe9\x02\x1d\n\r\n\x05\x04)\x02\x10\x05\x12\x04\xea\x02\x04\n\n\
    \r\n\x05\x04)\x02\x10\x01\x12\x04\xea\x02\x0b\x15\n\r\n\x05\x04)\x02\x10\
    \x03\x12\x04\xea\x02\x18\x1a\n\x0c\n\x04\x04)\x02\x11\x12\x04\xeb\x02\
    \x04\x1b\n\x0f\n\x05\x04)\x02\x11\x04\x12\x06\xeb\x02\x04\xea\x02\x1b\n\
    \r\n\x05\x04)\x02\x11\x05\x12\x04\xeb\x02\x04\n\n\r\n\x05\x04)\x02\x11\
    \x01\x12\x04\xeb\x02\x0b\x15\n\r\n\x05\x04)\x02\x11\x03\x12\x04\xeb\x02\
    \x18\x1a\n\x0c\n\x02\x04*\x12\x06\xee\x02\0\xf1\x02\x01\n\x0b\n\x03\x04*\
    \x01\x12\x04\xee\x02\x08\x1d\n\x0c\n\x04\x04*\x02\0\x12\x04\xef\x02\x04\
    \x1c\n\x0f\n\x05\x04*\x02\0\x04\x12\x06\xef\x02\x04\xee\x02\x1f\n\r\n\
    \x05\x04*\x02\0\x06\x12\x04\xef\x02\x04\r\n\r\n\x05\x04*\x02\0\x01\x12\
    \x04\xef\x02\x0e\x17\n\r\n\x05\x04*\x02\0\x03\x12\x04\xef\x02\x1a\x1b\n\
    \x0c\n\x04\x04*\x02\x01\x12\x04\xf0\x02\x04#\n\x0f\n\x05\x04*\x02\x01\
    \x04\x12\x06\xf0\x02\x04\xef\x02\x1c\n\r\n\x05\x04*\x02\x01\x06\x12\x04\
    \xf0\x02\x04\x12\n\r\n\x05\x04*\x02\x01\x01\x12\x04\xf0\x02\x13\x1e\n\r\
    \n\x05\x04*\x02\x01\x03\x12\x04\xf0\x02!\"\n\x0c\n\x02\x04+\x12\x06\xf3\
    \x02\0\xf7\x02\x01\n\x0b\n\x03\x04+\x01\x12\x04\xf3\x02\x08#\n\x0c\n\x04\
    \x04+\x02\0\x12\x04\xf4\x02\x04\x1c\n\x0f\n\x05\x04+\x02\0\x04\x12\x06\
    \xf4\x02\x04\xf3\x02%\n\r\n\x05\x04+\x02\0\x06\x12\x04\xf4\x02\x04\r\n\r\
    \n\x05\x04+\x02\0\x01\x12\x04\xf4\x02\x0e\x17\n\r\n\x05\x04+\x02\0\x03\
    \x12\x04\xf4\x02\x1a\x1b\n\x0c\n\x04\x04+\x02\x01\x12\x04\xf5\x02\x04#\n\
    \x0f\n\x05\x04+\x02\x01\x04\x12\x06\xf5\x02\x04\xf4\x02\x1c\n\r\n\x05\
    \x04+\x02\x01\x06\x12\x04\xf5\x02\x04\x12\n\r\n\x05\x04+\x02\x01\x01\x12\
    \x04\xf5\x02\x13\x1e\n\r\n\x05\x04+\x02\x01\x03\x12\x04\xf5\x02!\"\n\x0c\
    \n\x04\x04+\x02\x02\x12\x04\xf6\x02\x04\x14\n\x0f\n\x05\x04+\x02\x02\x04\
    \x12\x06\xf6\x02\x04\xf5\x02#\n\r\n\x05\x04+\x02\x02\x05\x12\x04\xf6\x02\
    \x04\t\n\r\n\x05\x04+\x02\x02\x01\x12\x04\xf6\x02\n\x0f\n\r\n\x05\x04+\
    \x02\x02\x03\x12\x04\xf6\x02\x12\x13\n\x0c\n\x02\x04,\x12\x06\xf9\x02\0\
    \xfb\x02\x01\n\x0b\n\x03\x04,\x01\x12\x04\xf9\x02\x08\x0b\n\x0c\n\x04\
    \x04,\x02\0\x12\x04\xfa\x02\x04\x12\n\x0f\n\x05\x04,\x02\0\x04\x12\x06\
    \xfa\x02\x04\xf9\x02\r\n\r\n\x05\x04,\x02\0\x05\x12\x04\xfa\x02\x04\n\n\
    \r\n\x05\x04,\x02\0\x01\x12\x04\xfa\x02\x0b\r\n\r\n\x05\x04,\x02\0\x03\
    \x12\x04\xfa\x02\x10\x11\n\x0c\n\x02\x04-\x12\x06\xfd\x02\0\x80\x03\x01\
    \n\x0b\n\x03\x04-\x01\x12\x04\xfd\x02\x08\x12\n\x0c\n\x04\x04-\x02\0\x12\
    \x04\xfe\x02\x04\x1c\n\x0f\n\x05\x04-\x02\0\x04\x12\x06\xfe\x02\x04\xfd\
    \x02\x14\n\r\n\x05\x04-\x02\0\x06\x12\x04\xfe\x02\x04\r\n\r\n\x05\x04-\
    \x02\0\x01\x12\x04\xfe\x02\x0e\x17\n\r\n\x05\x04-\x02\0\x03\x12\x04\xfe\
    \x02\x1a\x1b\n\x0c\n\x04\x04-\x02\x01\x12\x04\xff\x02\x04\x10\n\x0f\n\
    \x05\x04-\x02\x01\x04\x12\x06\xff\x02\x04\xfe\x02\x1c\n\r\n\x05\x04-\x02\
    \x01\x06\x12\x04\xff\x02\x04\x07\n\r\n\x05\x04-\x02\x01\x01\x12\x04\xff\
    \x02\x08\x0b\n\r\n\x05\x04-\x02\x01\x03\x12\x04\xff\x02\x0e\x0f\n\x0c\n\
    \x02\x04.\x12\x06\x82\x03\0\x84\x03\x01\n\x0b\n\x03\x04.\x01\x12\x04\x82\
    \x03\x08\x0c\n\x0c\n\x04\x04.\x02\0\x12\x04\x83\x03\x04\x1a\n\r\n\x05\
    \x04.\x02\0\x04\x12\x04\x83\x03\x04\x0c\n\r\n\x05\x04.\x02\0\x06\x12\x04\
    \x83\x03\r\x10\n\r\n\x05\x04.\x02\0\x01\x12\x04\x83\x03\x11\x15\n\r\n\
    \x05\x04.\x02\0\x03\x12\x04\x83\x03\x18\x19\n\x0c\n\x02\x04/\x12\x06\x86\
    \x03\0\x89\x03\x01\n\x0b\n\x03\x04/\x01\x12\x04\x86\x03\x08\x1d\n\x0c\n\
    \x04\x04/\x02\0\x12\x04\x87\x03\x04\x1c\n\x0f\n\x05\x04/\x02\0\x04\x12\
    \x06\x87\x03\x04\x86\x03\x1f\n\r\n\x05\x04/\x02\0\x06\x12\x04\x87\x03\
    \x04\r\n\r\n\x05\x04/\x02\0\x01\x12\x04\x87\x03\x0e\x17\n\r\n\x05\x04/\
    \x02\0\x03\x12\x04\x87\x03\x1a\x1b\n\x0c\n\x04\x04/\x02\x01\x12\x04\x88\
    \x03\x04\x1a\n\r\n\x05\x04/\x02\x01\x04\x12\x04\x88\x03\x04\x0c\n\r\n\
    \x05\x04/\x02\x01\x06\x12\x04\x88\x03\r\x10\n\r\n\x05\x04/\x02\x01\x01\
    \x12\x04\x88\x03\x11\x15\n\r\n\x05\x04/\x02\x01\x03\x12\x04\x88\x03\x18\
    \x19\n\x0c\n\x02\x040\x12\x06\x8b\x03\0\x8f\x03\x01\n\x0b\n\x03\x040\x01\
    \x12\x04\x8b\x03\x08\x13\n\x0c\n\x04\x040\x02\0\x12\x04\x8c\x03\x04\x1c\
    \n\x0f\n\x05\x040\x02\0\x04\x12\x06\x8c\x03\x04\x8b\x03\x15\n\r\n\x05\
    \x040\x02\0\x06\x12\x04\x8c\x03\x04\r\n\r\n\x05\x040\x02\0\x01\x12\x04\
    \x8c\x03\x0e\x17\n\r\n\x05\x040\x02\0\x03\x12\x04\x8c\x03\x1a\x1b\n\x0c\
    \n\x04\x040\x02\x01\x12\x04\x8d\x03\x04\x10\n\x0f\n\x05\x040\x02\x01\x04\
    \x12\x06\x8d\x03\x04\x8c\x03\x1c\n\r\n\x05\x040\x02\x01\x06\x12\x04\x8d\
    \x03\x04\x07\n\r\n\x05\x040\x02\x01\x01\x12\x04\x8d\x03\x08\x0b\n\r\n\
    \x05\x040\x02\x01\x03\x12\x04\x8d\x03\x0e\x0f\n\x0c\n\x04\x040\x02\x02\
    \x12\x04\x8e\x03\x04\x17\n\x0f\n\x05\x040\x02\x02\x04\x12\x06\x8e\x03\
    \x04\x8d\x03\x10\n\r\n\x05\x040\x02\x02\x05\x12\x04\x8e\x03\x04\n\n\r\n\
    \x05\x040\x02\x02\x01\x12\x04\x8e\x03\x0b\x12\n\r\n\x05\x040\x02\x02\x03\
    \x12\x04\x8e\x03\x15\x16\n\x0c\n\x02\x041\x12\x06\x91\x03\0\x93\x03\x01\
    \n\x0b\n\x03\x041\x01\x12\x04\x91\x03\x08\r\n\x0c\n\x04\x041\x02\0\x12\
    \x04\x92\x03\x04\x14\n\x0f\n\x05\x041\x02\0\x04\x12\x06\x92\x03\x04\x91\
    \x03\x0f\n\r\n\x05\x041\x02\0\x05\x12\x04\x92\x03\x04\n\n\r\n\x05\x041\
    \x02\0\x01\x12\x04\x92\x03\x0b\x0f\n\r\n\x05\x041\x02\0\x03\x12\x04\x92\
    \x03\x12\x13\n\x0c\n\x02\x042\x12\x06\x95\x03\0\x97\x03\x01\n\x0b\n\x03\
    \x042\x01\x12\x04\x95\x03\x08\x0e\n\x0c\n\x04\x042\x02\0\x12\x04\x96\x03\
    \x04\x1d\n\r\n\x05\x042\x02\0\x04\x12\x04\x96\x03\x04\x0c\n\r\n\x05\x042\
    \x02\0\x05\x12\x04\x96\x03\r\x13\n\r\n\x05\x042\x02\0\x01\x12\x04\x96\
    \x03\x14\x18\n\r\n\x05\x042\x02\0\x03\x12\x04\x96\x03\x1b\x1c\n\x0c\n\
    \x02\x043\x12\x06\x99\x03\0\x9c\x03\x01\n\x0b\n\x03\x043\x01\x12\x04\x99\
    \x03\x08\x1a\n\x0c\n\x04\x043\x02\0\x12\x04\x9a\x03\x04\x1c\n\x0f\n\x05\
    \x043\x02\0\x04\x12\x06\x9a\x03\x04\x99\x03\x1c\n\r\n\x05\x043\x02\0\x06\
    \x12\x04\x9a\x03\x04\r\n\r\n\x05\x043\x02\0\x01\x12\x04\x9a\x03\x0e\x17\
    \n\r\n\x05\x043\x02\0\x03\x12\x04\x9a\x03\x1a\x1b\n\x0c\n\x04\x043\x02\
    \x01\x12\x04\x9b\x03\x04\x1f\n\r\n\x05\x043\x02\x01\x04\x12\x04\x9b\x03\
    \x04\x0c\n\r\n\x05\x043\x02\x01\x05\x12\x04\x9b\x03\r\x13\n\r\n\x05\x043\
    \x02\x01\x01\x12\x04\x9b\x03\x14\x1a\n\r\n\x05\x043\x02\x01\x03\x12\x04\
    \x9b\x03\x1d\x1e\n\x0c\n\x02\x044\x12\x06\x9e\x03\0\xa1\x03\x01\n\x0b\n\
    \x03\x044\x01\x12\x04\x9e\x03\x08\x1d\n\x0c\n\x04\x044\x02\0\x12\x04\x9f\
    \x03\x04\x1c\n\x0f\n\x05\x044\x02\0\x04\x12\x06\x9f\x03\x04\x9e\x03\x1f\
    \n\r\n\x05\x044\x02\0\x06\x12\x04\x9f\x03\x04\r\n\r\n\x05\x044\x02\0\x01\
    \x12\x04\x9f\x03\x0e\x17\n\r\n\x05\x044\x02\0\x03\x12\x04\x9f\x03\x1a\
    \x1b\n\x0c\n\x04\x044\x02\x01\x12\x04\xa0\x03\x04\x15\n\x0f\n\x05\x044\
    \x02\x01\x04\x12\x06\xa0\x03\x04\x9f\x03\x1c\n\r\n\x05\x044\x02\x01\x05\
    \x12\x04\xa0\x03\x04\n\n\r\n\x05\x044\x02\x01\x01\x12\x04\xa0\x03\x0b\
    \x10\n\r\n\x05\x044\x02\x01\x03\x12\x04\xa0\x03\x13\x14\n\x0c\n\x02\x045\
    \x12\x06\xa3\x03\0\xbc\x03\x01\n\x0b\n\x03\x045\x01\x12\x04\xa3\x03\x08\
    \x11\n\x0c\n\x04\x045\x02\0\x12\x04\xa4\x03\x04\x10\n\x0f\n\x05\x045\x02\
    \0\x04\x12\x06\xa4\x03\x04\xa3\x03\x13\n\r\n\x05\x045\x02\0\x06\x12\x04\
    \xa4\x03\x04\x07\n\r\n\x05\x045\x02\0\x01\x12\x04\xa4\x03\x08\x0b\n\r\n\
    \x05\x045\x02\0\x03\x12\x04\xa4\x03\x0e\x0f\n\x0c\n\x04\x045\x02\x01\x12\
    \x04\xa5\x03\x04\x15\n\x0f\n\x05\x045\x02\x01\x04\x12\x06\xa5\x03\x04\
    \xa4\x03\x10\n\r\n\x05\x045\x02\x01\x05\x12\x04\xa5\x03\x04\n\n\r\n\x05\
    \x045\x02\x01\x01\x12\x04\xa5\x03\x0b\x10\n\r\n\x05\x045\x02\x01\x03\x12\
    \x04\xa5\x03\x13\x14\n\x0c\n\x04\x045\x02\x02\x12\x04\xa6\x03\x04\x15\n\
    \x0f\n\x05\x045\x02\x02\x04\x12\x06\xa6\x03\x04\xa5\x03\x15\n\r\n\x05\
    \x045\x02\x02\x05\x12\x04\xa6\x03\x04\x08\n\r\n\x05\x045\x02\x02\x01\x12\
    \x04\xa6\x03\t\x10\n\r\n\x05\x045\x02\x02\x03\x12\x04\xa6\x03\x13\x14\n\
    \x0c\n\x04\x045\x02\x03\x12\x04\xa7\x03\x04\x12\n\x0f\n\x05\x045\x02\x03\
    \x04\x12\x06\xa7\x03\x04\xa6\x03\x15\n\r\n\x05\x045\x02\x03\x05\x12\x04\
    \xa7\x03\x04\x08\n\r\n\x05\x045\x02\x03\x01\x12\x04\xa7\x03\t\r\n\r\n\
    \x05\x045\x02\x03\x03\x12\x04\xa7\x03\x10\x11\n\x0c\n\x04\x045\x02\x04\
    \x12\x04\xa8\x03\x04;\n\x0f\n\x05\x045\x02\x04\x04\x12\x06\xa8\x03\x04\
    \xa7\x03\x12\n\r\n\x05\x045\x02\x04\x06\x12\x04\xa8\x03\x04\x17\n\r\n\
    \x05\x045\x02\x04\x01\x12\x04\xa8\x03\x186\n\r\n\x05\x045\x02\x04\x03\
    \x12\x04\xa8\x039:\n\x0c\n\x04\x045\x02\x05\x12\x04\xa9\x03\x04\x18\n\
    \x0f\n\x05\x045\x02\x05\x04\x12\x06\xa9\x03\x04\xa8\x03;\n\r\n\x05\x045\
    \x02\x05\x05\x12\x04\xa9\x03\x04\t\n\r\n\x05\x045\x02\x05\x01\x12\x04\
    \xa9\x03\n\x13\n\r\n\x05\x045\x02\x05\x03\x12\x04\xa9\x03\x16\x17\n\x0c\
    \n\x04\x045\x02\x06\x12\x04\xaa\x03\x04\x1d\n\x0f\n\x05\x045\x02\x06\x04\
    \x12\x06\xaa\x03\x04\xa9\x03\x18\n\r\n\x05\x045\x02\x06\x05\x12\x04\xaa\
    \x03\x04\n\n\r\n\x05\x045\x02\x06\x01\x12\x04\xaa\x03\x0b\x18\n\r\n\x05\
    \x045\x02\x06\x03\x12\x04\xaa\x03\x1b\x1c\n\x0e\n\x04\x045\x04\0\x12\x06\
    \xab\x03\x04\xb9\x03\x05\n\r\n\x05\x045\x04\0\x01\x12\x04\xab\x03\t\x12\
    \n\x1a\n\x06\x045\x04\0\x02\0\x12\x04\xad\x03\x08\x11\x1a\n\x20No\x20err\
    or\n\n\x0f\n\x07\x045\x04\0\x02\0\x01\x12\x04\xad\x03\x08\x0c\n\x0f\n\
    \x07\x045\x04\0\x02\0\x02\x12\x04\xad\x03\x0f\x10\n$\n\x06\x045\x04\0\
    \x02\x01\x12\x04\xaf\x03\x08\x16\x1a\x14\x20NoSuchJobException\n\n\x0f\n\
    \x07\x045\x04\0\x02\x01\x01\x12\x04\xaf\x03\x08\x11\n\x0f\n\x07\x045\x04\
    \0\x02\x01\x02\x12\x04\xaf\x03\x14\x15\n&\n\x06\x045\x04\0\x02\x02\x12\
    \x04\xb1\x03\x08\x16\x1a\x16\x20JobCanceledException\n\n\x0f\n\x07\x045\
    \x04\0\x02\x02\x01\x12\x04\xb1\x03\x08\x11\n\x0f\n\x07\x045\x04\0\x02\
    \x02\x02\x12\x04\xb1\x03\x14\x15\n'\n\x06\x045\x04\0\x02\x03\x12\x04\xb3\
    \x03\x08\x1a\x1a\x17\x20NotConnectedException\n\n\x0f\n\x07\x045\x04\0\
    \x02\x03\x01\x12\x04\xb3\x03\x08\x15\n\x0f\n\x07\x045\x04\0\x02\x03\x02\
    \x12\x04\xb3\x03\x18\x19\n\x20\n\x06\x045\x04\0\x02\x04\x12\x04\xb5\x03\
    \x08\x12\x1a\x10\x20XenonException\n\n\x0f\n\x07\x045\x04\0\x02\x04\x01\
    \x12\x04\xb5\x03\x08\r\n\x0f\n\x07\x045\x04\0\x02\x04\x02\x12\x04\xb5\
    \x03\x10\x11\n\x1d\n\x06\x045\x04\0\x02\x05\x12\x04\xb7\x03\x08\x0f\x1a\
    \r\x20IOException\n\n\x0f\n\x07\x045\x04\0\x02\x05\x01\x12\x04\xb7\x03\
    \x08\n\n\x0f\n\x07\x045\x04\0\x02\x05\x02\x12\x04\xb7\x03\r\x0e\n\x0e\n\
    \x06\x045\x04\0\x02\x06\x12\x04\xb8\x03\x08\x12\n\x0f\n\x07\x045\x04\0\
    \x02\x06\x01\x12\x04\xb8\x03\x08\r\n\x0f\n\x07\x045\x04\0\x02\x06\x02\
    \x12\x04\xb8\x03\x10\x11\n\x0c\n\x04\x045\x02\x07\x12\x04\xba\x03\x04\
    \x1d\n\x0f\n\x05\x045\x02\x07\x04\x12\x06\xba\x03\x04\xb9\x03\x05\n\r\n\
    \x05\x045\x02\x07\x06\x12\x04\xba\x03\x04\r\n\r\n\x05\x045\x02\x07\x01\
    \x12\x04\xba\x03\x0e\x18\n\r\n\x05\x045\x02\x07\x03\x12\x04\xba\x03\x1b\
    \x1c\n\x0c\n\x04\x045\x02\x08\x12\x04\xbb\x03\x04\x14\n\x0f\n\x05\x045\
    \x02\x08\x04\x12\x06\xbb\x03\x04\xba\x03\x1d\n\r\n\x05\x045\x02\x08\x05\
    \x12\x04\xbb\x03\x04\n\n\r\n\x05\x045\x02\x08\x01\x12\x04\xbb\x03\x0b\
    \x0f\n\r\n\x05\x045\x02\x08\x03\x12\x04\xbb\x03\x12\x13\n\x0c\n\x02\x046\
    \x12\x06\xbe\x03\0\xc0\x03\x01\n\x0b\n\x03\x046\x01\x12\x04\xbe\x03\x08\
    \x1e\n\x0c\n\x04\x046\x02\0\x12\x04\xbf\x03\x04$\n\r\n\x05\x046\x02\0\
    \x04\x12\x04\xbf\x03\x04\x0c\n\r\n\x05\x046\x02\0\x06\x12\x04\xbf\x03\r\
    \x16\n\r\n\x05\x046\x02\0\x01\x12\x04\xbf\x03\x17\x1f\n\r\n\x05\x046\x02\
    \0\x03\x12\x04\xbf\x03\"#\n\x0c\n\x02\x047\x12\x06\xc2\x03\0\xd5\x03\x01\
    \n\x0b\n\x03\x047\x01\x12\x04\xc2\x03\x08\x13\n(\n\x04\x047\x02\0\x12\
    \x04\xc4\x03\x04\x14\x1a\x1a\x20In\x20Xenon\x20named\x20queueName\n\n\
    \x0f\n\x05\x047\x02\0\x04\x12\x06\xc4\x03\x04\xc2\x03\x15\n\r\n\x05\x047\
    \x02\0\x05\x12\x04\xc4\x03\x04\n\n\r\n\x05\x047\x02\0\x01\x12\x04\xc4\
    \x03\x0b\x0f\n\r\n\x05\x047\x02\0\x03\x12\x04\xc4\x03\x12\x13\n\x0c\n\
    \x04\x047\x02\x01\x12\x04\xc5\x03\x04;\n\x0f\n\x05\x047\x02\x01\x04\x12\
    \x06\xc5\x03\x04\xc4\x03\x14\n\r\n\x05\x047\x02\x01\x06\x12\x04\xc5\x03\
    \x04\x17\n\r\n\x05\x047\x02\x01\x01\x12\x04\xc5\x03\x186\n\r\n\x05\x047\
    \x02\x01\x03\x12\x04\xc5\x039:\n\x0c\n\x04\x047\x02\x02\x12\x04\xc6\x03\
    \x04\x1d\n\x0f\n\x05\x047\x02\x02\x04\x12\x06\xc6\x03\x04\xc5\x03;\n\r\n\
    \x05\x047\x02\x02\x05\x12\x04\xc6\x03\x04\n\n\r\n\x05\x047\x02\x02\x01\
    \x12\x04\xc6\x03\x0b\x18\n\r\n\x05\x047\x02\x02\x03\x12\x04\xc6\x03\x1b\
    \x1c\n\x0e\n\x04\x047\x04\0\x12\x06\xc7\x03\x04\xd3\x03\x05\n\r\n\x05\
    \x047\x04\0\x01\x12\x04\xc7\x03\t\x12\n\x1a\n\x06\x047\x04\0\x02\0\x12\
    \x04\xc9\x03\x08\x11\x1a\n\x20No\x20error\n\n\x0f\n\x07\x047\x04\0\x02\0\
    \x01\x12\x04\xc9\x03\x08\x0c\n\x0f\n\x07\x047\x04\0\x02\0\x02\x12\x04\
    \xc9\x03\x0f\x10\n&\n\x06\x047\x04\0\x02\x01\x12\x04\xcb\x03\x08\x16\x1a\
    \x16\x20NoSuchQueueException\n\n\x0f\n\x07\x047\x04\0\x02\x01\x01\x12\
    \x04\xcb\x03\x08\x11\n\x0f\n\x07\x047\x04\0\x02\x01\x02\x12\x04\xcb\x03\
    \x14\x15\n'\n\x06\x047\x04\0\x02\x02\x12\x04\xcd\x03\x08\x1a\x1a\x17\x20\
    NotConnectedException\n\n\x0f\n\x07\x047\x04\0\x02\x02\x01\x12\x04\xcd\
    \x03\x08\x15\n\x0f\n\x07\x047\x04\0\x02\x02\x02\x12\x04\xcd\x03\x18\x19\
    \n\x20\n\x06\x047\x04\0\x02\x03\x12\x04\xcf\x03\x08\x12\x1a\x10\x20Xenon\
    Exception\n\n\x0f\n\x07\x047\x04\0\x02\x03\x01\x12\x04\xcf\x03\x08\r\n\
    \x0f\n\x07\x047\x04\0\x02\x03\x02\x12\x04\xcf\x03\x10\x11\n\x1d\n\x06\
    \x047\x04\0\x02\x04\x12\x04\xd1\x03\x08\x0f\x1a\r\x20IOException\n\n\x0f\
    \n\x07\x047\x04\0\x02\x04\x01\x12\x04\xd1\x03\x08\n\n\x0f\n\x07\x047\x04\
    \0\x02\x04\x02\x12\x04\xd1\x03\r\x0e\n\x0e\n\x06\x047\x04\0\x02\x05\x12\
    \x04\xd2\x03\x08\x12\n\x0f\n\x07\x047\x04\0\x02\x05\x01\x12\x04\xd2\x03\
    \x08\r\n\x0f\n\x07\x047\x04\0\x02\x05\x02\x12\x04\xd2\x03\x10\x11\n\x0c\
    \n\x04\x047\x02\x03\x12\x04\xd4\x03\x04\x1d\n\x0f\n\x05\x047\x02\x03\x04\
    \x12\x06\xd4\x03\x04\xd3\x03\x05\n\r\n\x05\x047\x02\x03\x06\x12\x04\xd4\
    \x03\x04\r\n\r\n\x05\x047\x02\x03\x01\x12\x04\xd4\x03\x0e\x18\n\r\n\x05\
    \x047\x02\x03\x03\x12\x04\xd4\x03\x1b\x1c\n\x0c\n\x02\x048\x12\x06\xd7\
    \x03\0\xd9\x03\x01\n\x0b\n\x03\x048\x01\x12\x04\xd7\x03\x08\x15\n\x0c\n\
    \x04\x048\x02\0\x12\x04\xd8\x03\x04&\n\r\n\x05\x048\x02\0\x04\x12\x04\
    \xd8\x03\x04\x0c\n\r\n\x05\x048\x02\0\x06\x12\x04\xd8\x03\r\x18\n\r\n\
    \x05\x048\x02\0\x01\x12\x04\xd8\x03\x19!\n\r\n\x05\x048\x02\0\x03\x12\
    \x04\xd8\x03$%\n\x0c\n\x02\x049\x12\x06\xdb\x03\0\xdf\x03\x01\n\x0b\n\
    \x03\x049\x01\x12\x04\xdb\x03\x08$\n\x0c\n\x04\x049\x02\0\x12\x04\xdc\
    \x03\x04\x10\n\x0f\n\x05\x049\x02\0\x04\x12\x06\xdc\x03\x04\xdb\x03&\n\r\
    \n\x05\x049\x02\0\x06\x12\x04\xdc\x03\x04\x07\n\r\n\x05\x049\x02\0\x01\
    \x12\x04\xdc\x03\x08\x0b\n\r\n\x05\x049\x02\0\x03\x12\x04\xdc\x03\x0e\
    \x0f\n\x0c\n\x04\x049\x02\x01\x12\x04\xdd\x03\x04\x15\n\x0f\n\x05\x049\
    \x02\x01\x04\x12\x06\xdd\x03\x04\xdc\x03\x10\n\r\n\x05\x049\x02\x01\x05\
    \x12\x04\xdd\x03\x04\t\n\r\n\x05\x049\x02\x01\x01\x12\x04\xdd\x03\n\x10\
    \n\r\n\x05\x049\x02\x01\x03\x12\x04\xdd\x03\x13\x14\n\x0c\n\x04\x049\x02\
    \x02\x12\x04\xde\x03\x04\x15\n\x0f\n\x05\x049\x02\x02\x04\x12\x06\xde\
    \x03\x04\xdd\x03\x15\n\r\n\x05\x049\x02\x02\x05\x12\x04\xde\x03\x04\t\n\
    \r\n\x05\x049\x02\x02\x01\x12\x04\xde\x03\n\x10\n\r\n\x05\x049\x02\x02\
    \x03\x12\x04\xde\x03\x13\x14\n\x0c\n\x02\x04:\x12\x06\xe1\x03\0\xe3\x03\
    \x01\n\x0b\n\x03\x04:\x01\x12\x04\xe1\x03\x08\n\n\x0c\n\x04\x04:\x02\0\
    \x12\x04\xe2\x03\x04\x13\n\x0f\n\x05\x04:\x02\0\x04\x12\x06\xe2\x03\x04\
    \xe1\x03\x0c\n\r\n\x05\x04:\x02\0\x05\x12\x04\xe2\x03\x04\x08\n\r\n\x05\
    \x04:\x02\0\x01\x12\x04\xe2\x03\t\x0e\n\r\n\x05\x04:\x02\0\x03\x12\x04\
    \xe2\x03\x11\x12\n\x0c\n\x02\x04;\x12\x06\xe5\x03\0\xe7\x03\x01\n\x0b\n\
    \x03\x04;\x01\x12\x04\xe5\x03\x08!\n\x0c\n\x04\x04;\x02\0\x12\x04\xe6\
    \x03\x04\x15\n\x0f\n\x05\x04;\x02\0\x04\x12\x06\xe6\x03\x04\xe5\x03#\n\r\
    \n\x05\x04;\x02\0\x05\x12\x04\xe6\x03\x04\n\n\r\n\x05\x04;\x02\0\x01\x12\
    \x04\xe6\x03\x0b\x10\n\r\n\x05\x04;\x02\0\x03\x12\x04\xe6\x03\x13\x14\n\
    \xe3\x01\n\x02\x06\0\x12\x06\xeb\x03\0\xb5\x04\x01\x1a\xd4\x01\x20XenonF\
    iles\x20represents\x20the\x20Xenon\x20nl.esciencecenter.xenon.filesystem\
    s.FileSystem\x20class.\n\x20This\x20interface\x20contains\x20various\x20\
    methods\x20for\x20creating\x20and\x20closing\x20FileSystems,\x20creating\
    \x20Paths\x20and\x20operations\x20on\x20these\x20Paths.\n\n\x0b\n\x03\
    \x06\0\x01\x12\x04\xeb\x03\x08\x19\nK\n\x04\x06\0\x02\0\x12\x04\xed\x03\
    \x04P\x1a=\x20Gives\x20a\x20list\x20of\x20the\x20descriptions\x20of\x20t\
    he\x20available\x20adaptors.\n\n\r\n\x05\x06\0\x02\0\x01\x12\x04\xed\x03\
    \x08\x1e\n\r\n\x05\x06\0\x02\0\x02\x12\x04\xed\x03\x1f$\n\r\n\x05\x06\0\
    \x02\0\x03\x12\x04\xed\x03/L\n=\n\x04\x06\0\x02\x01\x12\x04\xef\x03\x048\
    \x1a/\x20Gives\x20a\x20list\x20names\x20of\x20the\x20available\x20adapto\
    rs.\n\n\r\n\x05\x06\0\x02\x01\x01\x12\x04\xef\x03\x08\x17\n\r\n\x05\x06\
    \0\x02\x01\x02\x12\x04\xef\x03\x18\x1d\n\r\n\x05\x06\0\x02\x01\x03\x12\
    \x04\xef\x03(4\nI\n\x04\x06\0\x02\x02\x12\x04\xf1\x03\x04T\x1a;\x20Gives\
    \x20the\x20description\x20of\x20the\x20adaptor\x20with\x20the\x20given\
    \x20name.\n\n\r\n\x05\x06\0\x02\x02\x01\x12\x04\xf1\x03\x08\x1d\n\r\n\
    \x05\x06\0\x02\x02\x02\x12\x04\xf1\x03\x1e)\n\r\n\x05\x06\0\x02\x02\x03\
    \x12\x04\xf1\x034P\n\x88\x01\n\x04\x06\0\x02\x03\x12\x04\xf3\x03\x04?\
    \x1az\x20Create\x20a\x20new\x20FileSystem\x20using\x20the\x20adaptor\x20\
    that\x20connects\x20to\x20a\x20data\x20store\x20at\x20location\x20using\
    \x20the\x20credentials\x20to\x20get\x20access.\n\n\r\n\x05\x06\0\x02\x03\
    \x01\x12\x04\xf3\x03\x08\x0e\n\r\n\x05\x06\0\x02\x03\x02\x12\x04\xf3\x03\
    \x0f&\n\r\n\x05\x06\0\x02\x03\x03\x12\x04\xf3\x031;\nI\n\x04\x06\0\x02\
    \x04\x12\x04\xf5\x03\x04;\x1a;\x20Get\x20the\x20name\x20of\x20the\x20ada\
    ptor\x20that\x20created\x20this\x20FileSystem.\n\n\r\n\x05\x06\0\x02\x04\
    \x01\x12\x04\xf5\x03\x08\x16\n\r\n\x05\x06\0\x02\x04\x02\x12\x04\xf5\x03\
    \x17!\n\r\n\x05\x06\0\x02\x04\x03\x12\x04\xf5\x03,7\nF\n\x04\x06\0\x02\
    \x05\x12\x04\xf7\x03\x045\x1a8\x20Get\x20the\x20location\x20that\x20this\
    \x20FileSystem\x20is\x20connected\x20to.\n\n\r\n\x05\x06\0\x02\x05\x01\
    \x12\x04\xf7\x03\x08\x13\n\r\n\x05\x06\0\x02\x05\x02\x12\x04\xf7\x03\x14\
    \x1e\n\r\n\x05\x06\0\x02\x05\x03\x12\x04\xf7\x03)1\nB\n\x04\x06\0\x02\
    \x06\x12\x04\xf9\x03\x04D\x1a4\x20Get\x20the\x20credential\x20used\x20to\
    \x20create\x20this\x20FileSystem.\n\n\r\n\x05\x06\0\x02\x06\x01\x12\x04\
    \xf9\x03\x08\x15\n\r\n\x05\x06\0\x02\x06\x02\x12\x04\xf9\x03\x16\x20\n\r\
    \n\x05\x06\0\x02\x06\x03\x12\x04\xf9\x03+@\nB\n\x04\x06\0\x02\x07\x12\
    \x04\xfb\x03\x049\x1a4\x20Get\x20the\x20properties\x20used\x20to\x20crea\
    te\x20this\x20FileSystem.\n\n\r\n\x05\x06\0\x02\x07\x01\x12\x04\xfb\x03\
    \x08\x15\n\r\n\x05\x06\0\x02\x07\x02\x12\x04\xfb\x03\x16\x20\n\r\n\x05\
    \x06\0\x02\x07\x03\x12\x04\xfb\x03+5\no\n\x04\x06\0\x02\x08\x12\x04\xfd\
    \x03\x049\x1aa\x20Creates\x20a\x20new\x20directory,\x20including\x20pare\
    nt\x20directories,\x20failing\x20if\x20the\x20directory\x20already\x20ex\
    ists.\n\n\r\n\x05\x06\0\x02\x08\x01\x12\x04\xfd\x03\x08\x19\n\r\n\x05\
    \x06\0\x02\x08\x02\x12\x04\xfd\x03\x1a%\n\r\n\x05\x06\0\x02\x08\x03\x12\
    \x04\xfd\x0305\nQ\n\x04\x06\0\x02\t\x12\x04\xff\x03\x047\x1aC\x20Creates\
    \x20a\x20new\x20directory,\x20failing\x20if\x20the\x20directory\x20alrea\
    dy\x20exists.\n\n\r\n\x05\x06\0\x02\t\x01\x12\x04\xff\x03\x08\x17\n\r\n\
    \x05\x06\0\x02\t\x02\x12\x04\xff\x03\x18#\n\r\n\x05\x06\0\x02\t\x03\x12\
    \x04\xff\x03.3\nM\n\x04\x06\0\x02\n\x12\x04\x81\x04\x042\x1a?\x20Creates\
    \x20a\x20new\x20empty\x20file,\x20failing\x20if\x20the\x20file\x20alread\
    y\x20exists.\n\n\r\n\x05\x06\0\x02\n\x01\x12\x04\x81\x04\x08\x12\n\r\n\
    \x05\x06\0\x02\n\x02\x12\x04\x81\x04\x13\x1e\n\r\n\x05\x06\0\x02\n\x03\
    \x12\x04\x81\x04).\nO\n\x04\x06\0\x02\x0b\x12\x04\x83\x04\x04H\x1aA\x20C\
    reates\x20a\x20new\x20symbolic\x20link,\x20failing\x20if\x20the\x20link\
    \x20already\x20exists\n\n\r\n\x05\x06\0\x02\x0b\x01\x12\x04\x83\x04\x08\
    \x1a\n\r\n\x05\x06\0\x02\x0b\x02\x12\x04\x83\x04\x1b4\n\r\n\x05\x06\0\
    \x02\x0b\x03\x12\x04\x83\x04?D\nh\n\x04\x06\0\x02\x0c\x12\x04\x85\x04\
    \x044\x1aZ\x20Asynchronously\x20Copy\x20an\x20existing\x20source\x20path\
    \x20to\x20a\x20target\x20path\x20on\x20a\x20different\x20file\x20system.\
    \n\n\r\n\x05\x06\0\x02\x0c\x01\x12\x04\x85\x04\x08\x0c\n\r\n\x05\x06\0\
    \x02\x0c\x02\x12\x04\x85\x04\r\x18\n\r\n\x05\x06\0\x02\x0c\x03\x12\x04\
    \x85\x04#0\n(\n\x04\x06\0\x02\r\x12\x04\x87\x04\x04<\x1a\x1a\x20Cancel\
    \x20a\x20copy\x20operation.\n\n\r\n\x05\x06\0\x02\r\x01\x12\x04\x87\x04\
    \x08\x0e\n\r\n\x05\x06\0\x02\r\x02\x12\x04\x87\x04\x0f#\n\r\n\x05\x06\0\
    \x02\r\x03\x12\x04\x87\x04.8\n/\n\x04\x06\0\x02\x0e\x12\x04\x89\x04\x04?\
    \x1a!\x20Retrieve\x20the\x20status\x20of\x20an\x20copy.\n\n\r\n\x05\x06\
    \0\x02\x0e\x01\x12\x04\x89\x04\x08\x11\n\r\n\x05\x06\0\x02\x0e\x02\x12\
    \x04\x89\x04\x12&\n\r\n\x05\x06\0\x02\x0e\x03\x12\x04\x89\x041;\nL\n\x04\
    \x06\0\x02\x0f\x12\x04\x8b\x04\x040\x1a>\x20Rename\x20an\x20existing\x20\
    source\x20path\x20to\x20a\x20non-existing\x20target\x20path\n\n\r\n\x05\
    \x06\0\x02\x0f\x01\x12\x04\x8b\x04\x08\x0e\n\r\n\x05\x06\0\x02\x0f\x02\
    \x12\x04\x8b\x04\x0f\x1c\n\r\n\x05\x06\0\x02\x0f\x03\x12\x04\x8b\x04',\n\
    )\n\x04\x06\0\x02\x10\x12\x04\x8d\x04\x040\x1a\x1b\x20Deletes\x20an\x20e\
    xisting\x20path.\n\n\r\n\x05\x06\0\x02\x10\x01\x12\x04\x8d\x04\x08\x0e\n\
    \r\n\x05\x06\0\x02\x10\x02\x12\x04\x8d\x04\x0f\x1c\n\r\n\x05\x06\0\x02\
    \x10\x03\x12\x04\x8d\x04',\n'\n\x04\x06\0\x02\x11\x12\x04\x8f\x04\x04+\
    \x1a\x19\x20Tests\x20if\x20a\x20path\x20exists.\n\n\r\n\x05\x06\0\x02\
    \x11\x01\x12\x04\x8f\x04\x08\x0e\n\r\n\x05\x06\0\x02\x11\x02\x12\x04\x8f\
    \x04\x0f\x1a\n\r\n\x05\x06\0\x02\x11\x03\x12\x04\x8f\x04%'\nW\n\x04\x06\
    \0\x02\x12\x12\x04\x91\x04\x04J\x1aI\x20Open\x20an\x20existing\x20file\
    \x20and\x20return\x20an\x20InputStream\x20to\x20read\x20from\x20this\x20\
    file.\n\n\r\n\x05\x06\0\x02\x12\x01\x12\x04\x91\x04\x08\x14\n\r\n\x05\
    \x06\0\x02\x12\x02\x12\x04\x91\x04\x15\x20\n\r\n\x05\x06\0\x02\x12\x06\
    \x12\x04\x91\x04+1\n\r\n\x05\x06\0\x02\x12\x03\x12\x04\x91\x042F\n\xeb\
    \x01\n\x04\x06\0\x02\x13\x12\x04\x95\x04\x04A\x1a\xdc\x01\x20Open\x20a\
    \x20file\x20and\x20return\x20an\x20OutputStream\x20to\x20write\x20to\x20\
    this\x20file.\n\x20In\x20Xenon\x20library\x20if\x20request\x20is\x20miss\
    ing\x20size\x20field\x20then\x20FileSystem.writeToFile(Path\x20file)\x20\
    is\x20used\n\x20else\x20FileSystem.writeToFile(Path\x20path,\x20long\x20\
    size)\x20is\x20used\n\n\r\n\x05\x06\0\x02\x13\x01\x12\x04\x95\x04\x08\
    \x13\n\r\n\x05\x06\0\x02\x13\x05\x12\x04\x95\x04\x14\x1a\n\r\n\x05\x06\0\
    \x02\x13\x02\x12\x04\x95\x04\x1b-\n\r\n\x05\x06\0\x02\x13\x03\x12\x04\
    \x95\x048=\n]\n\x04\x06\0\x02\x14\x12\x04\x97\x04\x04C\x1aO\x20Open\x20a\
    n\x20existing\x20file\x20and\x20return\x20an\x20OutputStream\x20to\x20ap\
    pend\x20data\x20to\x20this\x20file.\n\n\r\n\x05\x06\0\x02\x14\x01\x12\
    \x04\x97\x04\x08\x14\n\r\n\x05\x06\0\x02\x14\x05\x12\x04\x97\x04\x15\x1b\
    \n\r\n\x05\x06\0\x02\x14\x02\x12\x04\x97\x04\x1c/\n\r\n\x05\x06\0\x02\
    \x14\x03\x12\x04\x97\x04:?\n6\n\x04\x06\0\x02\x15\x12\x04\x99\x04\x04<\
    \x1a(\x20List\x20all\x20entries\x20in\x20the\x20directory\x20dir.\n\n\r\
    \n\x05\x06\0\x02\x15\x01\x12\x04\x99\x04\x08\x0c\n\r\n\x05\x06\0\x02\x15\
    \x02\x12\x04\x99\x04\r\x18\n\r\n\x05\x06\0\x02\x15\x06\x12\x04\x99\x04#)\
    \n\r\n\x05\x06\0\x02\x15\x03\x12\x04\x99\x04*8\n;\n\x04\x06\0\x02\x16\
    \x12\x04\x9b\x04\x04>\x1a-\x20Get\x20the\x20PathAttributes\x20of\x20an\
    \x20existing\x20path.\n\n\r\n\x05\x06\0\x02\x16\x01\x12\x04\x9b\x04\x08\
    \x15\n\r\n\x05\x06\0\x02\x16\x02\x12\x04\x9b\x04\x16!\n\r\n\x05\x06\0\
    \x02\x16\x03\x12\x04\x9b\x04,:\nF\n\x04\x06\0\x02\x17\x12\x04\x9d\x04\
    \x049\x1a8\x20Get\x20the\x20current\x20working\x20directory\x20of\x20thi\
    s\x20file\x20system.\n\n\r\n\x05\x06\0\x02\x17\x01\x12\x04\x9d\x04\x08\
    \x1b\n\r\n\x05\x06\0\x02\x17\x02\x12\x04\x9d\x04\x1c&\n\r\n\x05\x06\0\
    \x02\x17\x03\x12\x04\x9d\x0415\nS\n\x04\x06\0\x02\x18\x12\x04\x9f\x04\
    \x04;\x1aE\x20Set\x20the\x20current\x20working\x20directory\x20of\x20thi\
    s\x20file\x20system\x20to\x20directory.\n\n\r\n\x05\x06\0\x02\x18\x01\
    \x12\x04\x9f\x04\x08\x1b\n\r\n\x05\x06\0\x02\x18\x02\x12\x04\x9f\x04\x1c\
    '\n\r\n\x05\x06\0\x02\x18\x03\x12\x04\x9f\x0427\n4\n\x04\x06\0\x02\x19\
    \x12\x04\xa1\x04\x04R\x1a&\x20Sets\x20the\x20POSIX\x20permissions\x20of\
    \x20a\x20path\n\n\r\n\x05\x06\0\x02\x19\x01\x12\x04\xa1\x04\x08\x1f\n\r\
    \n\x05\x06\0\x02\x19\x02\x12\x04\xa1\x04\x20>\n\r\n\x05\x06\0\x02\x19\
    \x03\x12\x04\xa1\x04IN\n3\n\x04\x06\0\x02\x1a\x12\x04\xa3\x04\x047\x1a%\
    \x20Reads\x20the\x20target\x20of\x20a\x20symbolic\x20link\n\n\r\n\x05\
    \x06\0\x02\x1a\x01\x12\x04\xa3\x04\x08\x18\n\r\n\x05\x06\0\x02\x1a\x02\
    \x12\x04\xa3\x04\x19$\n\r\n\x05\x06\0\x02\x1a\x03\x12\x04\xa3\x04/3\n@\n\
    \x04\x06\0\x02\x1b\x12\x04\xa5\x04\x04J\x1a2\x20Get\x20the\x20path\x20se\
    parator\x20used\x20by\x20this\x20file\x20system.\n\n\r\n\x05\x06\0\x02\
    \x1b\x01\x12\x04\xa5\x04\x08\x18\n\r\n\x05\x06\0\x02\x1b\x02\x12\x04\xa5\
    \x04\x19#\n\r\n\x05\x06\0\x02\x1b\x03\x12\x04\xa5\x04.F\nC\n\x04\x06\0\
    \x02\x1c\x12\x04\xa7\x04\x04*\x1a5\x20Return\x20if\x20the\x20connection\
    \x20to\x20the\x20FileSystem\x20is\x20open.\n\n\r\n\x05\x06\0\x02\x1c\x01\
    \x12\x04\xa7\x04\x08\x0e\n\r\n\x05\x06\0\x02\x1c\x02\x12\x04\xa7\x04\x0f\
    \x19\n\r\n\x05\x06\0\x02\x1c\x03\x12\x04\xa7\x04$&\n\x92\x01\n\x04\x06\0\
    \x02\x1d\x12\x04\xab\x04\x04,\x1a\x83\x01\x20Close\x20this\x20filestem\n\
    \x20Any\x20pending/running\x20copy\x20operations\x20of\x20this\x20filest\
    ystem\x20will\x20be\x20terminated\n\x20Will\x20also\x20forget\x20this\
    \x20filesystem\n\n\r\n\x05\x06\0\x02\x1d\x01\x12\x04\xab\x04\x08\r\n\r\n\
    \x05\x06\0\x02\x1d\x02\x12\x04\xab\x04\x0e\x18\n\r\n\x05\x06\0\x02\x1d\
    \x03\x12\x04\xab\x04#(\nO\n\x04\x06\0\x02\x1e\x12\x04\xad\x04\x04C\x1aA\
    \x20Wait\x20until\x20a\x20copy\x20operation\x20is\x20done\x20or\x20until\
    \x20a\x20timeout\x20expires.\n\n\r\n\x05\x06\0\x02\x1e\x01\x12\x04\xad\
    \x04\x08\x15\n\r\n\x05\x06\0\x02\x1e\x02\x12\x04\xad\x04\x16*\n\r\n\x05\
    \x06\0\x02\x1e\x03\x12\x04\xad\x045?\n\xb2\x01\n\x04\x06\0\x02\x1f\x12\
    \x04\xb1\x04\x048\x1a\xa3\x01\x20Returns\x20filesystems\x20for\x20all\
    \x20local\x20drives\n\x20Not\x20part\x20of\x20FileSystem\x20class\x20in\
    \x20Xenon\x20library\n\x20In\x20Xenon\x20library\x20available\x20as\x20L\
    ocalFileSystemUtils.getLocalFileSystems()\n\n\r\n\x05\x06\0\x02\x1f\x01\
    \x12\x04\xb1\x04\x08\x18\n\r\n\x05\x06\0\x02\x1f\x02\x12\x04\xb1\x04\x19\
    \x1e\n\r\n\x05\x06\0\x02\x1f\x03\x12\x04\xb1\x04)4\nY\n\x04\x06\0\x02\
    \x20\x12\x04\xb4\x04\x047\x1aK\x20List\x20the\x20created\x20filesystems\
    \n\x20Specific\x20to\x20grpc,\x20not\x20part\x20of\x20Xenon\x20library\n\
    \n\r\n\x05\x06\0\x02\x20\x01\x12\x04\xb4\x04\x08\x17\n\r\n\x05\x06\0\x02\
    \x20\x02\x12\x04\xb4\x04\x18\x1d\n\r\n\x05\x06\0\x02\x20\x03\x12\x04\xb4\
    \x04(3\n\xba\x01\n\x02\x06\x01\x12\x06\xb8\x04\0\xf4\x04\x01\x1a\xab\x01\
    \x20The\x20Jobs\x20API\x20of\x20Xenon.\x20This\x20interface\x20creates\
    \x20various\x20methods\x20for\x20creating\x20and\x20closing\x20Scheduler\
    s,\x20submitting\x20jobs,\x20and\x20retrieving\x20information\x20about\
    \x20schedulers\x20and\x20jobs.\n\n\x0b\n\x03\x06\x01\x01\x12\x04\xb8\x04\
    \x08\x18\nK\n\x04\x06\x01\x02\0\x12\x04\xba\x04\x04O\x1a=\x20Gives\x20a\
    \x20list\x20of\x20the\x20descriptions\x20of\x20the\x20available\x20adapt\
    ors.\n\n\r\n\x05\x06\x01\x02\0\x01\x12\x04\xba\x04\x08\x1e\n\r\n\x05\x06\
    \x01\x02\0\x02\x12\x04\xba\x04\x1f$\n\r\n\x05\x06\x01\x02\0\x03\x12\x04\
    \xba\x04/K\n=\n\x04\x06\x01\x02\x01\x12\x04\xbc\x04\x048\x1a/\x20Gives\
    \x20a\x20list\x20names\x20of\x20the\x20available\x20adaptors.\n\n\r\n\
    \x05\x06\x01\x02\x01\x01\x12\x04\xbc\x04\x08\x17\n\r\n\x05\x06\x01\x02\
    \x01\x02\x12\x04\xbc\x04\x18\x1d\n\r\n\x05\x06\x01\x02\x01\x03\x12\x04\
    \xbc\x04(4\nI\n\x04\x06\x01\x02\x02\x12\x04\xbe\x04\x04S\x1a;\x20Gives\
    \x20the\x20description\x20of\x20the\x20adaptor\x20with\x20the\x20given\
    \x20name.\n\n\r\n\x05\x06\x01\x02\x02\x01\x12\x04\xbe\x04\x08\x1d\n\r\n\
    \x05\x06\x01\x02\x02\x02\x12\x04\xbe\x04\x1e)\n\r\n\x05\x06\x01\x02\x02\
    \x03\x12\x04\xbe\x044O\nt\n\x04\x06\x01\x02\x03\x12\x04\xc0\x04\x04=\x1a\
    f\x20Create\x20a\x20new\x20Scheduler\x20using\x20the\x20adaptor\x20conne\
    cting\x20to\x20the\x20location\x20using\x20credentials\x20to\x20get\x20a\
    ccess.\n\n\r\n\x05\x06\x01\x02\x03\x01\x12\x04\xc0\x04\x08\x0e\n\r\n\x05\
    \x06\x01\x02\x03\x02\x12\x04\xc0\x04\x0f%\n\r\n\x05\x06\x01\x02\x03\x03\
    \x12\x04\xc0\x0409\nH\n\x04\x06\x01\x02\x04\x12\x04\xc2\x04\x04:\x1a:\
    \x20Get\x20the\x20name\x20of\x20the\x20adaptor\x20that\x20created\x20thi\
    s\x20Scheduler.\n\n\r\n\x05\x06\x01\x02\x04\x01\x12\x04\xc2\x04\x08\x16\
    \n\r\n\x05\x06\x01\x02\x04\x02\x12\x04\xc2\x04\x17\x20\n\r\n\x05\x06\x01\
    \x02\x04\x03\x12\x04\xc2\x04+6\nE\n\x04\x06\x01\x02\x05\x12\x04\xc4\x04\
    \x044\x1a7\x20Get\x20the\x20location\x20that\x20this\x20Scheduler\x20is\
    \x20connected\x20to.\n\n\r\n\x05\x06\x01\x02\x05\x01\x12\x04\xc4\x04\x08\
    \x13\n\r\n\x05\x06\x01\x02\x05\x02\x12\x04\xc4\x04\x14\x1d\n\r\n\x05\x06\
    \x01\x02\x05\x03\x12\x04\xc4\x04(0\nA\n\x04\x06\x01\x02\x06\x12\x04\xc6\
    \x04\x04C\x1a3\x20Get\x20the\x20credential\x20used\x20to\x20create\x20th\
    is\x20Scheduler.\n\n\r\n\x05\x06\x01\x02\x06\x01\x12\x04\xc6\x04\x08\x15\
    \n\r\n\x05\x06\x01\x02\x06\x02\x12\x04\xc6\x04\x16\x1f\n\r\n\x05\x06\x01\
    \x02\x06\x03\x12\x04\xc6\x04*?\nA\n\x04\x06\x01\x02\x07\x12\x04\xc8\x04\
    \x048\x1a3\x20Get\x20the\x20properties\x20used\x20to\x20create\x20this\
    \x20Scheduler.\n\n\r\n\x05\x06\x01\x02\x07\x01\x12\x04\xc8\x04\x08\x15\n\
    \r\n\x05\x06\x01\x02\x07\x02\x12\x04\xc8\x04\x16\x1f\n\r\n\x05\x06\x01\
    \x02\x07\x03\x12\x04\xc8\x04*4\n#\n\x04\x06\x01\x02\x08\x12\x04\xca\x04\
    \x04>\x1a\x15\x20Submit\x20a\x20batch\x20job.\n\n\r\n\x05\x06\x01\x02\
    \x08\x01\x12\x04\xca\x04\x08\x16\n\r\n\x05\x06\x01\x02\x08\x02\x12\x04\
    \xca\x04\x17,\n\r\n\x05\x06\x01\x02\x08\x03\x12\x04\xca\x047:\n\xf9\x01\
    \n\x04\x06\x01\x02\t\x12\x04\xce\x04\x04q\x1a\xea\x01\x20Submit\x20an\
    \x20interactive\x20job\n\x20The\x20first\x20response\x20message\x20in\
    \x20the\x20response\x20stream\x20will\x20contain\x20the\x20job\x20identi\
    fier\x20and\x20empty\x20stdout\x20and\x20stdout.\n\x20Other\x20response\
    \x20messages\x20will\x20also\x20contain\x20the\x20job\x20identifier\x20a\
    nd\x20filled\x20stdout\x20and/or\x20stderr.\n\n\r\n\x05\x06\x01\x02\t\
    \x01\x12\x04\xce\x04\x08\x1c\n\r\n\x05\x06\x01\x02\t\x05\x12\x04\xce\x04\
    \x1d#\n\r\n\x05\x06\x01\x02\t\x02\x12\x04\xce\x04$?\n\r\n\x05\x06\x01\
    \x02\t\x06\x12\x04\xce\x04JP\n\r\n\x05\x06\x01\x02\t\x03\x12\x04\xce\x04\
    Qm\n@\n\x04\x06\x01\x02\n\x12\x04\xd0\x04\x044\x1a2\x20Get\x20the\x20que\
    ue\x20names\x20supported\x20by\x20this\x20Scheduler.\n\n\r\n\x05\x06\x01\
    \x02\n\x01\x12\x04\xd0\x04\x08\x15\n\r\n\x05\x06\x01\x02\n\x02\x12\x04\
    \xd0\x04\x16\x1f\n\r\n\x05\x06\x01\x02\n\x03\x12\x04\xd0\x04*0\n2\n\x04\
    \x06\x01\x02\x0b\x12\x04\xd2\x04\x049\x1a$\x20Get\x20the\x20name\x20of\
    \x20the\x20default\x20queue.\n\n\r\n\x05\x06\x01\x02\x0b\x01\x12\x04\xd2\
    \x04\x08\x1b\n\r\n\x05\x06\x01\x02\x0b\x02\x12\x04\xd2\x04\x1c%\n\r\n\
    \x05\x06\x01\x02\x0b\x03\x12\x04\xd2\x0405\nR\n\x04\x06\x01\x02\x0c\x12\
    \x04\xd4\x04\x045\x1aD\x20Get\x20all\x20job\x20identifier\x20of\x20jobs\
    \x20currently\x20in\x20(one\x20ore\x20more)\x20queues.\n\n\r\n\x05\x06\
    \x01\x02\x0c\x01\x12\x04\xd4\x04\x08\x0f\n\r\n\x05\x06\x01\x02\x0c\x02\
    \x12\x04\xd4\x04\x10\"\n\r\n\x05\x06\x01\x02\x0c\x03\x12\x04\xd4\x04-1\n\
    (\n\x04\x06\x01\x02\r\x12\x04\xd6\x04\x047\x1a\x1a\x20Get\x20the\x20stat\
    us\x20of\x20a\x20Job.\n\n\r\n\x05\x06\x01\x02\r\x01\x12\x04\xd6\x04\x08\
    \x14\n\r\n\x05\x06\x01\x02\r\x02\x12\x04\xd6\x04\x15\x1f\n\r\n\x05\x06\
    \x01\x02\r\x03\x12\x04\xd6\x04*3\n5\n\x04\x06\x01\x02\x0e\x12\x04\xd8\
    \x04\x04Q\x1a'\x20Get\x20the\x20status\x20of\x20all\x20specified\x20jobs\
    .\n\n\r\n\x05\x06\x01\x02\x0e\x01\x12\x04\xd8\x04\x08\x16\n\r\n\x05\x06\
    \x01\x02\x0e\x02\x12\x04\xd8\x04\x17,\n\r\n\x05\x06\x01\x02\x0e\x03\x12\
    \x04\xd8\x047M\n,\n\x04\x06\x01\x02\x0f\x12\x04\xda\x04\x04F\x1a\x1e\x20\
    Get\x20the\x20status\x20of\x20the\x20queue.\n\n\r\n\x05\x06\x01\x02\x0f\
    \x01\x12\x04\xda\x04\x08\x16\n\r\n\x05\x06\x01\x02\x0f\x02\x12\x04\xda\
    \x04\x17,\n\r\n\x05\x06\x01\x02\x0f\x03\x12\x04\xda\x047B\n-\n\x04\x06\
    \x01\x02\x10\x12\x04\xdc\x04\x04G\x1a\x1f\x20Get\x20the\x20status\x20of\
    \x20all\x20queues.\n\n\r\n\x05\x06\x01\x02\x10\x01\x12\x04\xdc\x04\x08\
    \x18\n\r\n\x05\x06\x01\x02\x10\x02\x12\x04\xdc\x04\x19+\n\r\n\x05\x06\
    \x01\x02\x10\x03\x12\x04\xdc\x046C\nD\n\x04\x06\x01\x02\x11\x12\x04\xde\
    \x04\x049\x1a6\x20Wait\x20until\x20a\x20job\x20is\x20done\x20or\x20until\
    \x20a\x20timeout\x20expires.\n\n\r\n\x05\x06\x01\x02\x11\x01\x12\x04\xde\
    \x04\x08\x15\n\r\n\x05\x06\x01\x02\x11\x02\x12\x04\xde\x04\x16!\n\r\n\
    \x05\x06\x01\x02\x11\x03\x12\x04\xde\x04,5\nL\n\x04\x06\x01\x02\x12\x12\
    \x04\xe0\x04\x04<\x1a>\x20Wait\x20until\x20a\x20job\x20starts\x20running\
    ,\x20or\x20until\x20a\x20timeout\x20expires.\n\n\r\n\x05\x06\x01\x02\x12\
    \x01\x12\x04\xe0\x04\x08\x18\n\r\n\x05\x06\x01\x02\x12\x02\x12\x04\xe0\
    \x04\x19$\n\r\n\x05\x06\x01\x02\x12\x03\x12\x04\xe0\x04/8\nA\n\x04\x06\
    \x01\x02\x13\x12\x04\xe2\x04\x04)\x1a3\x20Test\x20if\x20the\x20connectio\
    n\x20of\x20this\x20Scheduler\x20is\x20open.\n\n\r\n\x05\x06\x01\x02\x13\
    \x01\x12\x04\xe2\x04\x08\x0e\n\r\n\x05\x06\x01\x02\x13\x02\x12\x04\xe2\
    \x04\x0f\x18\n\r\n\x05\x06\x01\x02\x13\x03\x12\x04\xe2\x04#%\n\x1c\n\x04\
    \x06\x01\x02\x14\x12\x04\xe4\x04\x044\x1a\x0e\x20Cancel\x20a\x20job\n\n\
    \r\n\x05\x06\x01\x02\x14\x01\x12\x04\xe4\x04\x08\x11\n\r\n\x05\x06\x01\
    \x02\x14\x02\x12\x04\xe4\x04\x12\x1c\n\r\n\x05\x06\x01\x02\x14\x03\x12\
    \x04\xe4\x04'0\n<\n\x04\x06\x01\x02\x15\x12\x04\xe6\x04\x04K\x1a.\x20Get\
    \x20the\x20default\x20runtime\x20of\x20a\x20job\x20in\x20minutes.\n\n\r\
    \n\x05\x06\x01\x02\x15\x01\x12\x04\xe6\x04\x08\x19\n\r\n\x05\x06\x01\x02\
    \x15\x02\x12\x04\xe6\x04\x1a#\n\r\n\x05\x06\x01\x02\x15\x03\x12\x04\xe6\
    \x04.G\nJ\n\x04\x06\x01\x02\x16\x12\x04\xe8\x04\x048\x1a<\x20Retrieve\
    \x20the\x20FileSystem\x20used\x20internally\x20by\x20this\x20Scheduler.\
    \n\n\r\n\x05\x06\x01\x02\x16\x01\x12\x04\xe8\x04\x08\x15\n\r\n\x05\x06\
    \x01\x02\x16\x02\x12\x04\xe8\x04\x16\x1f\n\r\n\x05\x06\x01\x02\x16\x03\
    \x12\x04\xe8\x04*4\n\x8d\x01\n\x04\x06\x01\x02\x17\x12\x04\xec\x04\x04+\
    \x1a\x7f\x20Close\x20this\x20Scheduler.\n\x20If\x20scheduler\x20is\x20em\
    bedded\x20then\x20any\x20pending/running\x20jobs\x20will\x20be\x20killed\
    \n\x20Will\x20also\x20forget\x20this\x20scheduler\n\n\r\n\x05\x06\x01\
    \x02\x17\x01\x12\x04\xec\x04\x08\r\n\r\n\x05\x06\x01\x02\x17\x02\x12\x04\
    \xec\x04\x0e\x17\n\r\n\x05\x06\x01\x02\x17\x03\x12\x04\xec\x04\"'\n\xcd\
    \x01\n\x04\x06\x01\x02\x18\x12\x04\xf0\x04\x044\x1a\xbe\x01\x20Get\x20sc\
    heduler\x20on\x20local\x20filesystem\x20with\x20default\x20location,\x20\
    credential\x20and\x20no\x20properties\n\x20Not\x20part\x20of\x20Schedule\
    r\x20class\x20in\x20Xenon\x20library\n\x20In\x20Xenon\x20library\x20avai\
    lable\x20as\x20Scheduler.create(\"local\")\n\n\r\n\x05\x06\x01\x02\x18\
    \x01\x12\x04\xf0\x04\x08\x16\n\r\n\x05\x06\x01\x02\x18\x02\x12\x04\xf0\
    \x04\x17\x1c\n\r\n\x05\x06\x01\x02\x18\x03\x12\x04\xf0\x04'0\nX\n\x04\
    \x06\x01\x02\x19\x12\x04\xf3\x04\x045\x1aJ\x20List\x20the\x20created\x20\
    schedulers\n\x20Specific\x20to\x20grpc,\x20not\x20part\x20of\x20Xenon\
    \x20library\n\n\r\n\x05\x06\x01\x02\x19\x01\x12\x04\xf3\x04\x08\x16\n\r\
    \n\x05\x06\x01\x02\x19\x02\x12\x04\xf3\x04\x17\x1c\n\r\n\x05\x06\x01\x02\
    \x19\x03\x12\x04\xf3\x04'1b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
